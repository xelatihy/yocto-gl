//
// # Yocto/glTF: Tiny C++ Library for glTF loading/saving.
//
// Yocto/glTF is a C++ library for loading and saving Khronos gkTF 2.0 with
// support for the whole 2.0 specification and the Pbr and binary glTF
// extensions. All parsing and writing code is autogenerated form the schema.
//
// The library provides a low  level interface that is a direct
// C++ translation of the glTF schemas and should be used if one wants
// complete control over the format or an application wants to have their
// own scene code added. A higher-level interface is provided by Yocto/Scene.
//
// glTF is a very complex file format and was designed mainly with untyped
// languages in mind. We attempt to match the glTF low-level interface
// to C++ as best as it can. Since the code is generated from the schema, we
// follow glTF naming conventions and typing well. To simplify adoption
// and keep the API relatively simple we use vector as arrays and use
// pointers to reference to all glTF objects. While this makes it less
// efficient than it might have been, glTF heavy use of optional values makes
// this necessary. At the same time, we do not keep track of set/unset values
// for basic types (int, float, bool) as a compromise for efficiency.
//
// glTF uses integer indices to access objects.
// While writing code ourselves we found that we add significant problems
// since we would use an index to access the wrong type of scene objects.
// For this reasons, we use an explicit index `glTFid<T>` that can only access
// an object of type T. Internally this is just the same old glTF index. But
// this can used to access the scene data with `glTF::get<T>(index)`.
//
// ## Usage
//
// 1. load a glTF model with `load_gltf()`
// 2. look at the `glTFXXX` data structures for access to individual elements
// 3. save glTF back to disk with `save_gltf()`
//
//

//
// LICENSE:
//
// Copyright (c) 2016 -- 2018 Fabio Pellacini
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
//
// LICENSE OF INCLUDED CODE FOR BASE64 (base64.h, base64.cpp)
//
// Copyright (C) 2004-2008 René Nyffenegger
//
// This source code is provided 'as-is', without any express or implied
// warranty. In no event will the author be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this source code must not be misrepresented; you must not
// claim that you wrote the original source code. If you use this source code
// in a product, an acknowledgment in the product documentation would be
// appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not be
// misrepresented as being the original source code.
//
// 3. This notice may not be removed or altered from any source distribution.
//
// René Nyffenegger rene.nyffenegger@adp-gmbh.ch
//
//

#ifndef _YGLTF_H_
#define _YGLTF_H_

#ifndef YGL_GLTFJSON
#define YGL_GLTFJSON 0
#endif

#include "ygl.h"
#include "yglio.h"

#include <map>
#include <string>
#include <vector>

// include json for glTF
#if YGL_GLTFJSON
#include "ext/json.hpp"
#endif

// -----------------------------------------------------------------------------
// KHRONOS GLTF SUPPORT
// -----------------------------------------------------------------------------
namespace ygl {

// Id for glTF references.
template <typename T>
struct glTFid {
    // Defaoult constructor to an invalid id.
    glTFid() : _id(-1) {}
    // Explicit conversion from integer.
    explicit glTFid(int id) : _id(id) {}
    // Explicit convcersion to integer.
    explicit operator int() const { return _id; }
    // Check if it is valid.
    bool is_valid() const { return _id >= 0; }
    // Check if it is valid.
    explicit operator bool() const { return _id >= 0; }

   private:
    // id
    int _id = -1;
};

// Generic glTF object.
struct glTFProperty {
#if YGL_GLTFJSON
    // Extensions.
    map<string, nlohmann::json> extensions = {};
    // Extra data.
    nlohmann::json extras = {};
#endif
};

// #codegen begin gltf-type

// forward declaration
struct glTFChildOfRootProperty;
struct glTFAccessorSparseIndices;
struct glTFAccessorSparseValues;
struct glTFAccessorSparse;
struct glTFAccessor;
struct glTFAnimationChannelTarget;
struct glTFAnimationChannel;
struct glTFAnimationSampler;
struct glTFAnimation;
struct glTFAsset;
struct glTFBuffer;
struct glTFBufferView;
struct glTFCameraOrthographic;
struct glTFCameraPerspective;
struct glTFCamera;
struct glTFImage;
struct glTFTextureInfo;
struct glTFTexture;
struct glTFMaterialNormalTextureInfo;
struct glTFMaterialOcclusionTextureInfo;
struct glTFMaterialPbrMetallicRoughness;
struct glTFMaterialPbrSpecularGlossiness;
struct glTFMaterial;
struct glTFMeshPrimitive;
struct glTFMesh;
struct glTFNode;
struct glTFSampler;
struct glTFScene;
struct glTFSkin;
struct glTF;

// Generic glTF named object
struct glTFChildOfRootProperty : glTFProperty {
    // The user-defined name of this object.
    std::string name = "";
};

// Values for glTFAccessorSparseIndices::componentType
enum class glTFAccessorSparseIndicesComponentType {
    // Not set
    NotSet = -1,
    // UnsignedByte
    UnsignedByte = 5121,
    // UnsignedShort
    UnsignedShort = 5123,
    // UnsignedInt
    UnsignedInt = 5125,
};

// Indices of those attributes that deviate from their initialization value.
struct glTFAccessorSparseIndices : glTFProperty {
    // The index of the bufferView with sparse indices. Referenced bufferView
    // can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target. [required]
    glTFid<glTFBufferView> bufferView = {};
    // The offset relative to the start of the bufferView in bytes. Must be
    // aligned.
    int byteOffset = 0;
    // The indices data type. [required]
    glTFAccessorSparseIndicesComponentType componentType =
        glTFAccessorSparseIndicesComponentType::NotSet;
};

// Array of size `accessor.sparse.count` times number of components storing the
// displaced accessor attributes pointed by `accessor.sparse.indices`.
struct glTFAccessorSparseValues : glTFProperty {
    // The index of the bufferView with sparse values. Referenced bufferView
    // can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target. [required]
    glTFid<glTFBufferView> bufferView = {};
    // The offset relative to the start of the bufferView in bytes. Must be
    // aligned.
    int byteOffset = 0;
};

// Sparse storage of attributes that deviate from their initialization value.
struct glTFAccessorSparse : glTFProperty {
    // Number of entries stored in the sparse array. [required]
    int count = 0;
    // Index array of size `count` that points to those accessor attributes
    // that deviate from their initialization value. Indices must strictly
    // increase. [required]
    std::shared_ptr<glTFAccessorSparseIndices> indices = nullptr;
    // Array of size `count` times number of components, storing the displaced
    // accessor attributes pointed by `indices`. Substituted values must have
    // the same `componentType` and number of components as the base accessor.
    // [required]
    std::shared_ptr<glTFAccessorSparseValues> values = nullptr;
};

// Values for glTFAccessor::componentType
enum class glTFAccessorComponentType {
    // Not set
    NotSet = -1,
    // Byte
    Byte = 5120,
    // UnsignedByte
    UnsignedByte = 5121,
    // Short
    Short = 5122,
    // UnsignedShort
    UnsignedShort = 5123,
    // UnsignedInt
    UnsignedInt = 5125,
    // Float
    Float = 5126,
};

// Values for glTFAccessor::type
enum class glTFAccessorType {
    // Not set
    NotSet = -1,
    // Scalar
    Scalar = 0,
    // Vec2
    Vec2 = 1,
    // Vec3
    Vec3 = 2,
    // Vec4
    Vec4 = 3,
    // Mat2
    Mat2 = 4,
    // Mat3
    Mat3 = 5,
    // Mat4
    Mat4 = 6,
};

// A typed view into a bufferView.  A bufferView contains raw binary data.  An
// accessor provides a typed view into a bufferView or a subset of a bufferView
// similar to how WebGL's `vertexAttribPointer()` defines an attribute in a
// buffer.
struct glTFAccessor : glTFChildOfRootProperty {
    // The index of the bufferView.
    glTFid<glTFBufferView> bufferView = {};
    // The offset relative to the start of the bufferView in bytes.
    int byteOffset = 0;
    // The datatype of components in the attribute. [required]
    glTFAccessorComponentType componentType = glTFAccessorComponentType::NotSet;
    // Specifies whether integer data values should be normalized.
    bool normalized = false;
    // The number of attributes referenced by this accessor. [required]
    int count = 0;
    // Specifies if the attribute is a scalar, vector, or matrix. [required]
    glTFAccessorType type = glTFAccessorType::NotSet;
    // Maximum value of each component in this attribute.
    std::vector<float> max = {};
    // Minimum value of each component in this attribute.
    std::vector<float> min = {};
    // Sparse storage of attributes that deviate from their initialization
    // value.
    std::shared_ptr<glTFAccessorSparse> sparse = nullptr;
};

// Values for glTFAnimationChannelTarget::path
enum class glTFAnimationChannelTargetPath {
    // Not set
    NotSet = -1,
    // Translation
    Translation = 0,
    // Rotation
    Rotation = 1,
    // Scale
    Scale = 2,
    // Weights
    Weights = 3,
};

// The index of the node and TRS property that an animation channel targets.
struct glTFAnimationChannelTarget : glTFProperty {
    // The index of the node to target. [required]
    glTFid<glTFNode> node = {};
    // The name of the node's TRS property to modify, or the "weights" of the
    // Morph Targets it instantiates. [required]
    glTFAnimationChannelTargetPath path =
        glTFAnimationChannelTargetPath::NotSet;
};

// Targets an animation's sampler at a node's property.
struct glTFAnimationChannel : glTFProperty {
    // The index of a sampler in this animation used to compute the value for
    // the target. [required]
    glTFid<glTFAnimationSampler> sampler = {};
    // The index of the node and TRS property to target. [required]
    std::shared_ptr<glTFAnimationChannelTarget> target = nullptr;
};

// Values for glTFAnimationSampler::interpolation
enum class glTFAnimationSamplerInterpolation {
    // Not set
    NotSet = -1,
    // The animated values are linearly interpolated between keyframes. When
    // targeting a rotation, spherical linear interpolation (slerp) should be
    // used to interpolate quaternions. The number output of elements must equal
    // the number of input elements.
    Linear = 0,
    // The animated values remain constant to the output of the first keyframe,
    // until the next keyframe. The number of output elements must equal the
    // number of input elements.
    Step = 1,
    // The animation's interpolation is computed using a cubic spline with
    // specified tangents. The number of output elements must equal three times
    // the number of input elements. For each input element, the output stores
    // three elements, an in-tangent, a spline vertex, and an out-tangent. There
    // must be at least two keyframes when using this interpolation.
    CubicSpline = 3,
};

// Combines input and output accessors with an interpolation algorithm to
// define a keyframe graph (but not its target).
struct glTFAnimationSampler : glTFProperty {
    // The index of an accessor containing keyframe input values, e.g., time.
    // [required]
    glTFid<glTFAccessor> input = {};
    // Interpolation algorithm.
    glTFAnimationSamplerInterpolation interpolation =
        glTFAnimationSamplerInterpolation::Linear;
    // The index of an accessor, containing keyframe output values. [required]
    glTFid<glTFAccessor> output = {};
};

// A keyframe animation.
struct glTFAnimation : glTFChildOfRootProperty {
    // An array of channels, each of which targets an animation's sampler at a
    // node's property. Different channels of the same animation can't have
    // equal targets. [required]
    std::vector<std::shared_ptr<glTFAnimationChannel>> channels = {};
    // An array of samplers that combines input and output accessors with an
    // interpolation algorithm to define a keyframe graph (but not its target).
    // [required]
    std::vector<std::shared_ptr<glTFAnimationSampler>> samplers = {};

    // typed access for nodes
    std::shared_ptr<glTFAnimationChannel> get(
        const glTFid<glTFAnimationChannel>& id) const {
        if (!id) return nullptr;
        return channels.at((int)id);
    }
    // typed access for nodes
    std::shared_ptr<glTFAnimationSampler> get(
        const glTFid<glTFAnimationSampler>& id) const {
        if (!id) return nullptr;
        return samplers.at((int)id);
    }
};

// Metadata about the glTF asset.
struct glTFAsset : glTFProperty {
    // A copyright message suitable for display to credit the content creator.
    std::string copyright = "";
    // Tool that generated this glTF model.  Useful for debugging.
    std::string generator = "";
    // The glTF version that this asset targets. [required]
    std::string version = "";
    // The minimum glTF version that this asset targets.
    std::string minVersion = "";
};

// A buffer points to binary geometry, animation, or skins.
struct glTFBuffer : glTFChildOfRootProperty {
    // The uri of the buffer.
    std::string uri = "";
    // The length of the buffer in bytes. [required]
    int byteLength = 0;
    // Stores buffer content after loading. [required]
    std::vector<unsigned char> data = {};
};

// Values for glTFBufferView::target
enum class glTFBufferViewTarget {
    // Not set
    NotSet = -1,
    // ArrayBuffer
    ArrayBuffer = 34962,
    // ElementArrayBuffer
    ElementArrayBuffer = 34963,
};

// A view into a buffer generally representing a subset of the buffer.
struct glTFBufferView : glTFChildOfRootProperty {
    // The index of the buffer. [required]
    glTFid<glTFBuffer> buffer = {};
    // The offset into the buffer in bytes.
    int byteOffset = 0;
    // The length of the bufferView in bytes. [required]
    int byteLength = 0;
    // The stride, in bytes.
    int byteStride = 0;
    // The target that the GPU buffer should be bound to.
    glTFBufferViewTarget target = glTFBufferViewTarget::NotSet;
};

// An orthographic camera containing properties to create an orthographic
// projection matrix.
struct glTFCameraOrthographic : glTFProperty {
    // The floating-point horizontal magnification of the view. [required]
    float xmag = 0;
    // The floating-point vertical magnification of the view. [required]
    float ymag = 0;
    // The floating-point distance to the far clipping plane. `zfar` must be
    // greater than `znear`. [required]
    float zfar = 0;
    // The floating-point distance to the near clipping plane. [required]
    float znear = 0;
};

// A perspective camera containing properties to create a perspective
// projection matrix.
struct glTFCameraPerspective : glTFProperty {
    // The floating-point aspect ratio of the field of view.
    float aspectRatio = 0;
    // The floating-point vertical field of view in radians. [required]
    float yfov = 0;
    // The floating-point distance to the far clipping plane.
    float zfar = 0;
    // The floating-point distance to the near clipping plane. [required]
    float znear = 0;
};

// Values for glTFCamera::type
enum class glTFCameraType {
    // Not set
    NotSet = -1,
    // Perspective
    Perspective = 0,
    // Orthographic
    Orthographic = 1,
};

// A camera's projection.  A node can reference a camera to apply a transform
// to place the camera in the scene.
struct glTFCamera : glTFChildOfRootProperty {
    // An orthographic camera containing properties to create an orthographic
    // projection matrix.
    std::shared_ptr<glTFCameraOrthographic> orthographic = nullptr;
    // A perspective camera containing properties to create a perspective
    // projection matrix.
    std::shared_ptr<glTFCameraPerspective> perspective = nullptr;
    // Specifies if the camera uses a perspective or orthographic projection.
    // [required]
    glTFCameraType type = glTFCameraType::NotSet;
};

// Values for glTFImage::mimeType
enum class glTFImageMimeType {
    // Not set
    NotSet = -1,
    // ImageJpeg
    ImageJpeg = 0,
    // ImagePng
    ImagePng = 1,
};

// Image data used to create a texture. Image can be referenced by URI or
// `bufferView` index. `mimeType` is required in the latter case.
struct glTFImage : glTFChildOfRootProperty {
    // The uri of the image.
    std::string uri = "";
    // The image's MIME type.
    glTFImageMimeType mimeType = glTFImageMimeType::NotSet;
    // The index of the bufferView that contains the image. Use this instead of
    // the image's uri property.
    glTFid<glTFBufferView> bufferView = {};

    // Image data (if loaded).
    image4f data = {};
};

// Reference to a texture.
struct glTFTextureInfo : glTFProperty {
    // The index of the texture. [required]
    glTFid<glTFTexture> index = {};
    // The set index of texture's TEXCOORD attribute used for texture
    // coordinate mapping.
    int texCoord = 0;
};

// A texture and its sampler.
struct glTFTexture : glTFChildOfRootProperty {
    // The index of the sampler used by this texture. When undefined, a sampler
    // with repeat wrapping and auto filtering should be used.
    glTFid<glTFSampler> sampler = {};
    // The index of the image used by this texture.
    glTFid<glTFImage> source = {};
};

// Normal texture information.
struct glTFMaterialNormalTextureInfo : glTFTextureInfo {
    // The scalar multiplier applied to each normal vector of the normal
    // texture.
    float scale = 1;
};

// Occlusion texture information.
struct glTFMaterialOcclusionTextureInfo : glTFTextureInfo {
    // A scalar multiplier controlling the amount of occlusion applied.
    float strength = 1;
};

// A set of parameter values that are used to define the metallic-roughness
// material model from Physically-Based Rendering (PBR) methodology.
struct glTFMaterialPbrMetallicRoughness : glTFProperty {
    // The material's base color factor.
    vec4f baseColorFactor = {1, 1, 1, 1};
    // The base color texture.
    std::shared_ptr<glTFTextureInfo> baseColorTexture = nullptr;
    // The metalness of the material.
    float metallicFactor = 1;
    // The roughness of the material.
    float roughnessFactor = 1;
    // The metallic-roughness texture.
    std::shared_ptr<glTFTextureInfo> metallicRoughnessTexture = nullptr;
};

// glTF extension that defines the specular-glossiness material model from
// Physically-Based Rendering (PBR) methodology.
struct glTFMaterialPbrSpecularGlossiness : glTFProperty {
    // The reflected diffuse factor of the material.
    vec4f diffuseFactor = {1, 1, 1, 1};
    // The diffuse texture.
    std::shared_ptr<glTFTextureInfo> diffuseTexture = nullptr;
    // The specular RGB color of the material.
    vec3f specularFactor = {1, 1, 1};
    // The glossiness or smoothness of the material.
    float glossinessFactor = 1;
    // The specular-glossiness texture.
    std::shared_ptr<glTFTextureInfo> specularGlossinessTexture = nullptr;
};

// Values for glTFMaterial::alphaMode
enum class glTFMaterialAlphaMode {
    // Not set
    NotSet = -1,
    // The alpha value is ignored and the rendered output is fully opaque.
    Opaque = 0,
    // The rendered output is either fully opaque or fully transparent depending
    // on the alpha value and the specified alpha cutoff value.
    Mask = 1,
    // The alpha value is used to composite the source and destination areas.
    // The rendered output is combined with the background using the normal
    // painting operation (i.e. the Porter and Duff over operator).
    Blend = 2,
};

// The material appearance of a primitive.
struct glTFMaterial : glTFChildOfRootProperty {
    // A set of parameter values that are used to define the metallic-roughness
    // material model from Physically-Based Rendering (PBR) methodology. When
    // not specified, all the default values of `pbrMetallicRoughness` apply.
    std::shared_ptr<glTFMaterialPbrMetallicRoughness> pbrMetallicRoughness =
        nullptr;
    // A set of parameter values that are used to define the
    // specular-glossiness material model from Physically-Based Rendering (PBR)
    // methodology. When not specified, all the default values of
    // `pbrMetallicRoughness` apply.
    std::shared_ptr<glTFMaterialPbrSpecularGlossiness> pbrSpecularGlossiness =
        nullptr;
    // The normal map texture.
    std::shared_ptr<glTFMaterialNormalTextureInfo> normalTexture = nullptr;
    // The occlusion map texture.
    std::shared_ptr<glTFMaterialOcclusionTextureInfo> occlusionTexture =
        nullptr;
    // The emissive map texture.
    std::shared_ptr<glTFTextureInfo> emissiveTexture = nullptr;
    // The emissive color of the material.
    vec3f emissiveFactor = {0, 0, 0};
    // The alpha rendering mode of the material.
    glTFMaterialAlphaMode alphaMode = glTFMaterialAlphaMode::Opaque;
    // The alpha cutoff value of the material.
    float alphaCutoff = 0.5;
    // Specifies whether the material is double sided.
    bool doubleSided = false;
};

// Values for glTFMeshPrimitive::mode
enum class glTFMeshPrimitiveMode {
    // Not set
    NotSet = -1,
    // Points
    Points = 0,
    // Lines
    Lines = 1,
    // LineLoop
    LineLoop = 2,
    // LineStrip
    LineStrip = 3,
    // Triangles
    Triangles = 4,
    // TriangleStrip
    TriangleStrip = 5,
    // TriangleFan
    TriangleFan = 6,
};

// Geometry to be rendered with the given material.
struct glTFMeshPrimitive : glTFProperty {
    // A dictionary object, where each key corresponds to mesh attribute
    // semantic and each value is the index of the accessor containing
    // attribute's data. [required]
    std::map<std::string, glTFid<glTFAccessor>> attributes = {};
    // The index of the accessor that contains the indices.
    glTFid<glTFAccessor> indices = {};
    // The index of the material to apply to this primitive when rendering.
    glTFid<glTFMaterial> material = {};
    // The type of primitives to render.
    glTFMeshPrimitiveMode mode = glTFMeshPrimitiveMode::Triangles;
    // An array of Morph Targets, each  Morph Target is a dictionary mapping
    // attributes (only `POSITION`, `NORMAL`, and `TANGENT` supported) to their
    // deviations in the Morph Target.
    std::vector<std::map<std::string, glTFid<glTFAccessor>>> targets = {};
};

// A set of primitives to be rendered.  A node can contain one mesh.  A node's
// transform places the mesh in the scene.
struct glTFMesh : glTFChildOfRootProperty {
    // An array of primitives, each defining geometry to be rendered with a
    // material. [required]
    std::vector<std::shared_ptr<glTFMeshPrimitive>> primitives = {};
    // Array of weights to be applied to the Morph Targets.
    std::vector<float> weights = {};
};

// A node in the node hierarchy.  When the node contains `skin`, all
// `mesh.primitives` must contain `JOINTS_0` and `WEIGHTS_0` attributes.  A
// node can have either a `matrix` or any combination of
// `translation`/`rotation`/`scale` (TRS) properties. TRS properties are
// converted to matrices and postmultiplied in the `T * R * S` order to compose
// the transformation matrix; first the scale is applied to the vertices, then
// the rotation, and then the translation. If none are provided, the transform
// is the identity. When a node is targeted for animation (referenced by an
// animation.channel.target), only TRS properties may be present; `matrix` will
// not be present.
struct glTFNode : glTFChildOfRootProperty {
    // The index of the camera referenced by this node.
    glTFid<glTFCamera> camera = {};
    // The indices of this node's children.
    std::vector<glTFid<glTFNode>> children = {};
    // The index of the skin referenced by this node.
    glTFid<glTFSkin> skin = {};
    // A floating-point 4x4 transformation matrix stored in column-major order.
    mat4f matrix = {{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1}};
    // The index of the mesh in this node.
    glTFid<glTFMesh> mesh = {};
    // The node's unit quaternion rotation in the order (x, y, z, w), where w
    // is the scalar.
    vec4f rotation = {0, 0, 0, 1};
    // The node's non-uniform scale.
    vec3f scale = {1, 1, 1};
    // The node's translation.
    vec3f translation = {0, 0, 0};
    // The weights of the instantiated Morph Target. Number of elements must
    // match number of Morph Targets of used mesh.
    std::vector<float> weights = {};
};

// Values for glTFSampler::magFilter
enum class glTFSamplerMagFilter {
    // Not set
    NotSet = -1,
    // Nearest
    Nearest = 9728,
    // Linear
    Linear = 9729,
};

// Values for glTFSampler::minFilter
enum class glTFSamplerMinFilter {
    // Not set
    NotSet = -1,
    // Nearest
    Nearest = 9728,
    // Linear
    Linear = 9729,
    // NearestMipmapNearest
    NearestMipmapNearest = 9984,
    // LinearMipmapNearest
    LinearMipmapNearest = 9985,
    // NearestMipmapLinear
    NearestMipmapLinear = 9986,
    // LinearMipmapLinear
    LinearMipmapLinear = 9987,
};

// glTFSampler::wrapS
enum class glTFSamplerWrapS {
    // Not set
    NotSet = -1,
    // ClampToEdge
    ClampToEdge = 33071,
    // MirroredRepeat
    MirroredRepeat = 33648,
    // Repeat
    Repeat = 10497,
};

// glTFSampler::wrapT
enum class glTFSamplerWrapT {
    // Not set
    NotSet = -1,
    // ClampToEdge
    ClampToEdge = 33071,
    // MirroredRepeat
    MirroredRepeat = 33648,
    // Repeat
    Repeat = 10497,
};

// Texture sampler properties for filtering and wrapping modes.
struct glTFSampler : glTFChildOfRootProperty {
    // Magnification filter.
    glTFSamplerMagFilter magFilter = glTFSamplerMagFilter::NotSet;
    // Minification filter.
    glTFSamplerMinFilter minFilter = glTFSamplerMinFilter::NotSet;
    // s wrapping mode.
    glTFSamplerWrapS wrapS = glTFSamplerWrapS::Repeat;
    // t wrapping mode.
    glTFSamplerWrapT wrapT = glTFSamplerWrapT::Repeat;
};

// The root nodes of a scene.
struct glTFScene : glTFChildOfRootProperty {
    // The indices of each root node.
    std::vector<glTFid<glTFNode>> nodes = {};
};

// Joints and matrices defining a skin.
struct glTFSkin : glTFChildOfRootProperty {
    // The index of the accessor containing the floating-point 4x4 inverse-bind
    // matrices.  The default is that each matrix is a 4x4 identity matrix,
    // which implies that inverse-bind matrices were pre-applied.
    glTFid<glTFAccessor> inverseBindMatrices = {};
    // The index of the node used as a skeleton root. When undefined, joints
    // transforms resolve to scene root.
    glTFid<glTFNode> skeleton = {};
    // Indices of skeleton nodes, used as joints in this skin. [required]
    std::vector<glTFid<glTFNode>> joints = {};
};

// The root object for a glTF asset.
struct glTF : glTFProperty {
    // Names of glTF extensions used somewhere in this asset.
    std::vector<std::string> extensionsUsed = {};
    // Names of glTF extensions required to properly load this asset.
    std::vector<std::string> extensionsRequired = {};
    // An array of accessors.
    std::vector<std::shared_ptr<glTFAccessor>> accessors = {};
    // An array of keyframe animations.
    std::vector<std::shared_ptr<glTFAnimation>> animations = {};
    // Metadata about the glTF asset. [required]
    std::shared_ptr<glTFAsset> asset = nullptr;
    // An array of buffers.
    std::vector<std::shared_ptr<glTFBuffer>> buffers = {};
    // An array of bufferViews.
    std::vector<std::shared_ptr<glTFBufferView>> bufferViews = {};
    // An array of cameras.
    std::vector<std::shared_ptr<glTFCamera>> cameras = {};
    // An array of images.
    std::vector<std::shared_ptr<glTFImage>> images = {};
    // An array of materials.
    std::vector<std::shared_ptr<glTFMaterial>> materials = {};
    // An array of meshes.
    std::vector<std::shared_ptr<glTFMesh>> meshes = {};
    // An array of nodes.
    std::vector<std::shared_ptr<glTFNode>> nodes = {};
    // An array of samplers.
    std::vector<std::shared_ptr<glTFSampler>> samplers = {};
    // The index of the default scene.
    glTFid<glTFScene> scene = {};
    // An array of scenes.
    std::vector<std::shared_ptr<glTFScene>> scenes = {};
    // An array of skins.
    std::vector<std::shared_ptr<glTFSkin>> skins = {};
    // An array of textures.
    std::vector<std::shared_ptr<glTFTexture>> textures = {};

    // typed access for nodes
    std::shared_ptr<glTFAccessor> get(const glTFid<glTFAccessor>& id) const {
        if (!id) return nullptr;
        return accessors.at((int)id);
    }
    // typed access for nodes
    std::shared_ptr<glTFAnimation> get(const glTFid<glTFAnimation>& id) const {
        if (!id) return nullptr;
        return animations.at((int)id);
    }
    // typed access for nodes
    std::shared_ptr<glTFBuffer> get(const glTFid<glTFBuffer>& id) const {
        if (!id) return nullptr;
        return buffers.at((int)id);
    }
    // typed access for nodes
    std::shared_ptr<glTFBufferView> get(
        const glTFid<glTFBufferView>& id) const {
        if (!id) return nullptr;
        return bufferViews.at((int)id);
    }
    // typed access for nodes
    std::shared_ptr<glTFCamera> get(const glTFid<glTFCamera>& id) const {
        if (!id) return nullptr;
        return cameras.at((int)id);
    }
    // typed access for nodes
    std::shared_ptr<glTFImage> get(const glTFid<glTFImage>& id) const {
        if (!id) return nullptr;
        return images.at((int)id);
    }
    // typed access for nodes
    std::shared_ptr<glTFMaterial> get(const glTFid<glTFMaterial>& id) const {
        if (!id) return nullptr;
        return materials.at((int)id);
    }
    // typed access for nodes
    std::shared_ptr<glTFMesh> get(const glTFid<glTFMesh>& id) const {
        if (!id) return nullptr;
        return meshes.at((int)id);
    }
    // typed access for nodes
    std::shared_ptr<glTFNode> get(const glTFid<glTFNode>& id) const {
        if (!id) return nullptr;
        return nodes.at((int)id);
    }
    // typed access for nodes
    std::shared_ptr<glTFSampler> get(const glTFid<glTFSampler>& id) const {
        if (!id) return nullptr;
        return samplers.at((int)id);
    }
    // typed access for nodes
    std::shared_ptr<glTFScene> get(const glTFid<glTFScene>& id) const {
        if (!id) return nullptr;
        return scenes.at((int)id);
    }
    // typed access for nodes
    std::shared_ptr<glTFSkin> get(const glTFid<glTFSkin>& id) const {
        if (!id) return nullptr;
        return skins.at((int)id);
    }
    // typed access for nodes
    std::shared_ptr<glTFTexture> get(const glTFid<glTFTexture>& id) const {
        if (!id) return nullptr;
        return textures.at((int)id);
    }
};
// #codegen end gltf-type

// Load a gltf file `filename` from disk.
inline std::shared_ptr<glTF> load_gltf(
    const std::string& filename, bool load_bin = true);
// Load a binary gltf file `filename` from disk.
inline std::shared_ptr<glTF> load_binary_gltf(
    const std::string& filename, bool load_bin = true);

// Save a gltf file `filename` to disk.
inline void save_gltf(const std::string& filename,
    const std::shared_ptr<glTF>& gltf, bool save_bin = true);
// Save a gltf file `filename` to disk.
inline void save_binary_gltf(const std::string& filename,
    const std::shared_ptr<glTF>& gltf, bool save_bin = true);

// Load glTF texture images.
inline void load_gltf_textures(const std::shared_ptr<glTF>& gltf,
    const std::string& dirname, bool skip_missing = true);
// Save glTF texture images.
inline void save_gltf_textures(const std::shared_ptr<glTF>& gltf,
    const std::string& dirname, bool skip_missing = true);

// Computes the local node transform and its inverse.
inline mat4f node_transform(const std::shared_ptr<glTFNode> node) {
    return frame_to_mat(translation_frame(node->translation) *
                        rotation_frame(node->rotation) *
                        scaling_frame(node->scale)) *
           node->matrix;
}

// A view for gltf array buffers that allows for typed access.
struct accessor_view {
    // Construct a view from an accessor.
    accessor_view(const std::shared_ptr<glTF>& gltf,
        const std::shared_ptr<glTFAccessor>& accessor);

    // Number of elements in the view.
    int size() const { return _size; }
    // Number of elements in the view
    int count() const { return _size; }
    // Number of components per element
    int ncomp() const { return _ncomp; }
    // Check whether the view is valid.
    bool valid() const { return _valid; }

    // Get the idx-th element of fixed length width default values.
    vec2f getv2f(int idx, vec2f def = {0, 0}) const {
        auto v = def;
        for (auto i = 0; i < min(_ncomp, 2); i++) (&v.x)[i] = get(idx, i);
        return v;
    }
    // Get the idx-th element of fixed length width default values.
    vec3f getv3f(int idx, vec3f def = {0, 0, 0}) const {
        auto v = def;
        for (auto i = 0; i < min(_ncomp, 3); i++) (&v.x)[i] = get(idx, i);
        return v;
    }
    // Get the idx-th element of fixed length width default values.
    vec4f getv4f(int idx, vec4f def = {0, 0, 0, 0}) const {
        auto v = def;
        for (auto i = 0; i < min(_ncomp, 4); i++) (&v.x)[i] = get(idx, i);
        return v;
    }

    // Get the idx-th element of fixed length as a matrix.
    mat4f getm4f(int idx) const {
        auto v = mat4f();
        auto vm = &v.x.x;
        for (auto i = 0; i < 16; i++) vm[i] = get(idx, i);
        return v;
    }

    // Get the c-th component of the idx-th element.
    float get(int idx, int c = 0) const;

    // Get the idx-th element as integer with fixed length.
    vec2i getv2i(int idx, vec2i def = {0, 0}) const {
        auto v = def;
        for (auto i = 0; i < min(_ncomp, 2); i++) { (&v.x)[i] = geti(idx, i); }
        return v;
    }
    // Get the idx-th element as integer with fixed length.
    vec3i getv3i(int idx, vec3i def = {0, 0, 0}) const {
        auto v = def;
        for (auto i = 0; i < min(_ncomp, 3); i++) { (&v.x)[i] = geti(idx, i); }
        return v;
    }
    // Get the idx-th element as integer with fixed length.
    vec4i getv4i(int idx, vec4i def = {0, 0, 0, 0}) const {
        auto v = def;
        for (auto i = 0; i < min(_ncomp, 4); i++) { (&v.x)[i] = geti(idx, i); }
        return v;
    }

    // Get the c-th component of the idx-th element as integer.
    int geti(int idx, int c = 0) const;

   private:
    const unsigned char* _data = nullptr;
    int _size = 0;
    int _stride = 0;
    int _ncomp = 0;
    glTFAccessorComponentType _ctype;
    bool _normalize = false;
    bool _valid = false;

    static int _num_components(glTFAccessorType type);
    static int _ctype_size(glTFAccessorComponentType componentType);
};

}  // namespace ygl

#include <fstream>
#include <unordered_map>

#include "json.hpp"

// -----------------------------------------------------------------------------
// IMPLEMENTATION FOR KHRONOS GLTF
// -----------------------------------------------------------------------------
namespace ygl {

// Json alias
using json = nlohmann::json;

// Parse int function.
inline void serialize(int& val, json& js, bool reading) {
    if (reading) {
        if (!js.is_number_integer())
            throw std::runtime_error("integer expected");
        val = js;
    } else {
        js = val;
    }
}

// Parse float function.
inline void serialize(float& val, json& js, bool reading) {
    if (reading) {
        if (!js.is_number()) throw std::runtime_error("number expected");
        val = js;
    } else {
        js = val;
    }
}

// Parse bool function.
inline void serialize(bool& val, json& js, bool reading) {
    if (reading) {
        if (!js.is_boolean()) throw std::runtime_error("bool expected");
        val = js;
    } else {
        js = val;
    }
}

// Parse string function.
inline void serialize(std::string& val, json& js, bool reading) {
    if (reading) {
        if (!js.is_string()) throw std::runtime_error("string expected");
        val = js;
    } else {
        js = val;
    }
}

// Parse support function.
template <typename T>
inline void serialize(std::shared_ptr<T>& val, json& js, bool reading) {
    if (reading) {
        if (js.is_null()) {
            val = nullptr;
            return;
        }
        if (!js.is_object()) throw std::runtime_error("object expected");
        if (!val) val = std::make_shared<T>();
        serialize(*val, js, reading);
    } else {
        if (!val) {
            js = nullptr;
            return;
        }
        if (!js.is_object()) js = json::object();
        serialize(*val, js, reading);
    }
}

// Parse support function.
template <typename T>
inline void serialize(std::vector<T>& vals, json& js, bool reading) {
    if (reading) {
        if (!js.is_array()) throw std::runtime_error("array expected");
        vals.resize(js.size());
        for (auto i = 0; i < js.size(); i++) {
            // this is contrived to support for std::vector<bool>
            auto v = T();
            serialize(v, js[i], reading);
            vals[i] = v;
        }
    } else {
        js = json::array();
        for (auto i = 0; i < vals.size(); i++)
            serialize(vals[i], js[i], reading);
    }
}

// Parse support function.
template <typename T, size_t N>
inline void serialize(std::array<T, N>& vals, json& js, bool reading) {
    if (reading) {
        if (!js.is_array()) throw std::runtime_error("array expected");
        if (N != js.size()) throw std::runtime_error("wrong array size");
        for (auto i = 0; i < N; i++) serialize(vals[i], js.at(i), reading);
    } else {
        js = json::array();
        for (auto i = 0; i < N; i++) serialize(vals[i], js[i], reading);
    }
}

// Parse support function.
template <typename T>
inline void serialize(std::map<std::string, T>& vals, json& js, bool reading) {
    if (reading) {
        if (!js.is_object()) throw std::runtime_error("object expected");
        for (auto kv = js.begin(); kv != js.end(); ++kv) {
            serialize(vals[kv.key()], kv.value(), reading);
        }
    } else {
        js = json::object();
        for (auto& kv : vals) serialize(kv.second, js[kv.first], reading);
    }
}

// Parse support function.
template <typename T, typename T1>
inline void serialize(T& val, json& js, bool reading,
    const std::vector<std::pair<T1, T>>& table) {
    if (reading) {
        auto v = T1();
        serialize(v, js, reading);
        auto found = false;
        for (auto& kv : table) {
            if (kv.first == v) {
                val = kv.second;
                found = true;
                break;
            }
        }
        if (!found) throw std::runtime_error("bad enum value");
    } else {
        auto found = false;
        auto v = T1();
        for (auto& kv : table) {
            if (kv.second == val) {
                v = kv.first;
                found = true;
                break;
            }
        }
        if (!found) throw std::runtime_error("invalid value");
        serialize(v, js, reading);
    }
}

// Parse support function.
template <typename T, typename T1>
inline void serialize(
    T& val, json& js, bool reading, const std::map<T, T1>& table) {
    if (reading) {
        auto v = T1();
        serialize(v, js, reading);
        auto found = false;
        for (auto& kv : table) {
            if (kv.second == v) {
                val = kv.first;
                found = true;
                break;
            }
        }
        if (!found) throw std::runtime_error("bad enum value");
    } else {
        auto found = false;
        auto v = T1();
        for (auto& kv : table) {
            if (kv.first == val) {
                v = kv.second;
                found = true;
                break;
            }
        }
        if (!found) throw std::runtime_error("invalid value");
        serialize(v, js, reading);
    }
}

// Parse support function.
inline void serialize(vec3f& vals, json& js, bool reading) {
    serialize((std::array<float, 3>&)vals, js, reading);
}
inline void serialize(vec4f& vals, json& js, bool reading) {
    serialize((std::array<float, 4>&)vals, js, reading);
}
inline void serialize(mat4f& vals, json& js, bool reading) {
    serialize((std::array<float, 16>&)vals, js, reading);
}

// Parse support function.
inline void serialize_obj(json& js, bool reading) {
    if (reading) {
        if (!js.is_object()) throw std::runtime_error("object expected");
    } else {
        if (!js.is_object()) js = json::object();
    }
}

// Parse support function.
template <typename T>
inline void serialize_attr(T& val, json& js, const char* name, bool reading,
    bool required = true, const T& def = {}) {
    if (reading) {
        if (required) {
            if (!js.count(name)) throw std::runtime_error("missing value");
            serialize(val, js.at(name), reading);
        } else {
            if (!js.count(name))
                val = def;
            else
                serialize(val, js.at(name), reading);
        }
    } else {
        if (required || val != def) serialize(val, js[name], reading);
    }
}

// Dump support function.
template <typename T>
inline void serialize_attr(std::vector<T>& val, json& js, const char* name,
    bool reading, bool required = true, const std::vector<T>& def = {}) {
    if (reading) {
        if (required) {
            if (!js.count(name)) throw std::runtime_error("missing value");
            serialize(val, js.at(name), reading);
        } else {
            if (!js.count(name))
                val = def;
            else
                serialize(val, js.at(name), reading);
        }
    } else {
        if (required || !val.empty()) serialize(val, js[name], reading);
    }
}

// Dump support function.
template <typename T>
inline void serialize_attr(std::map<std::string, T>& val, json& js,
    const char* name, bool reading, bool required = true,
    const std::map<std::string, T>& def = {}) {
    if (reading) {
        if (required) {
            if (!js.count(name)) throw std::runtime_error("missing value");
            serialize(val, js.at(name), reading);
        } else {
            if (!js.count(name))
                val = def;
            else
                serialize(val, js.at(name), reading);
        }
    } else {
        if (required || !val.empty()) serialize(val, js[name], reading);
    }
}

// #codegen begin gltf-func

// Check for default value
template <typename T>
inline bool operator==(const glTFid<T>& a, const glTFid<T>& b) {
    return (int)a == (int)b;
}

// Check for default value
template <typename T>
inline bool operator!=(const glTFid<T>& a, const glTFid<T>& b) {
    return (int)a != (int)b;
}

// Parse id function.
template <typename T>
inline void serialize(glTFid<T>& val, json& js, bool reading) {
    if (reading) {
        if (!js.is_number_integer()) throw std::runtime_error("int expected");
        val = glTFid<T>((int)js);
    } else {
        js = (int)val;
    }
}

// Parses a glTFProperty object
inline void serialize(glTFProperty& val, json& js, bool reading) {
    if (reading) {
        if (!js.is_object()) throw std::runtime_error("object expected");
#if YGL_GLTFJSON
        if (js.count("extensions"))
            serialize(val.extensions, js.at("extensions"), reading);
        if (js.count("extras")) serialize(val.extras, js.at("extras"), reading);
#endif
    } else {
        if (!js.is_object()) js = json::object();
#if YGL_GLTFJSON
        if (!val.extensions.empty())
            serialize(val.extensions, js["extensions"], reading);
        if (!val.extras.is_null()) serialize(val.extras, js["extras"], reading);
#endif
    }
}

// Parses a glTFChildOfRootProperty object
inline void serialize(glTFChildOfRootProperty& val, json& js, bool reading) {
    static auto def = glTFChildOfRootProperty();
    serialize_obj(js, reading);
    serialize((glTFProperty&)val, js, reading);
    serialize_attr(val.name, js, "name", reading, false, def.name);
}
// Parse a glTFAccessorSparseIndicesComponentType enum
inline void serialize(
    glTFAccessorSparseIndicesComponentType& val, json& js, bool reading) {
    static std::vector<std::pair<int, glTFAccessorSparseIndicesComponentType>>
        table = {
            {5121, glTFAccessorSparseIndicesComponentType::UnsignedByte},
            {5123, glTFAccessorSparseIndicesComponentType::UnsignedShort},
            {5125, glTFAccessorSparseIndicesComponentType::UnsignedInt},
        };
    serialize(val, js, reading, table);
}

// Parses a glTFAccessorSparseIndices object
inline void serialize(glTFAccessorSparseIndices& val, json& js, bool reading) {
    static auto def = glTFAccessorSparseIndices();
    serialize_obj(js, reading);
    serialize((glTFProperty&)val, js, reading);
    serialize_attr(
        val.bufferView, js, "bufferView", reading, true, def.bufferView);
    serialize_attr(
        val.byteOffset, js, "byteOffset", reading, false, def.byteOffset);
    serialize_attr(val.componentType, js, "componentType", reading, true,
        def.componentType);
}

// Parses a glTFAccessorSparseValues object
inline void serialize(glTFAccessorSparseValues& val, json& js, bool reading) {
    static auto def = glTFAccessorSparseValues();
    serialize_obj(js, reading);
    serialize((glTFProperty&)val, js, reading);
    serialize_attr(
        val.bufferView, js, "bufferView", reading, true, def.bufferView);
    serialize_attr(
        val.byteOffset, js, "byteOffset", reading, false, def.byteOffset);
}

// Parses a glTFAccessorSparse object
inline void serialize(glTFAccessorSparse& val, json& js, bool reading) {
    static auto def = glTFAccessorSparse();
    serialize_obj(js, reading);
    serialize((glTFProperty&)val, js, reading);
    serialize_attr(val.count, js, "count", reading, true, def.count);
    serialize_attr(val.indices, js, "indices", reading, true, def.indices);
    serialize_attr(val.values, js, "values", reading, true, def.values);
}
// Parse a glTFAccessorComponentType enum
inline void serialize(glTFAccessorComponentType& val, json& js, bool reading) {
    static std::vector<std::pair<int, glTFAccessorComponentType>> table = {
        {5120, glTFAccessorComponentType::Byte},
        {5121, glTFAccessorComponentType::UnsignedByte},
        {5122, glTFAccessorComponentType::Short},
        {5123, glTFAccessorComponentType::UnsignedShort},
        {5125, glTFAccessorComponentType::UnsignedInt},
        {5126, glTFAccessorComponentType::Float},
    };
    serialize(val, js, reading, table);
}

// Parse a glTFAccessorType enum
inline void serialize(glTFAccessorType& val, json& js, bool reading) {
    static std::vector<std::pair<std::string, glTFAccessorType>> table = {
        {"SCALAR", glTFAccessorType::Scalar},
        {"VEC2", glTFAccessorType::Vec2},
        {"VEC3", glTFAccessorType::Vec3},
        {"VEC4", glTFAccessorType::Vec4},
        {"MAT2", glTFAccessorType::Mat2},
        {"MAT3", glTFAccessorType::Mat3},
        {"MAT4", glTFAccessorType::Mat4},
    };
    serialize(val, js, reading, table);
}

// Parses a glTFAccessor object
inline void serialize(glTFAccessor& val, json& js, bool reading) {
    static auto def = glTFAccessor();
    serialize_obj(js, reading);
    serialize((glTFChildOfRootProperty&)val, js, reading);
    serialize_attr(
        val.bufferView, js, "bufferView", reading, false, def.bufferView);
    serialize_attr(
        val.byteOffset, js, "byteOffset", reading, false, def.byteOffset);
    serialize_attr(val.componentType, js, "componentType", reading, true,
        def.componentType);
    serialize_attr(
        val.normalized, js, "normalized", reading, false, def.normalized);
    serialize_attr(val.count, js, "count", reading, true, def.count);
    serialize_attr(val.type, js, "type", reading, true, def.type);
    serialize_attr(val.max, js, "max", reading, false, def.max);
    serialize_attr(val.min, js, "min", reading, false, def.min);
    serialize_attr(val.sparse, js, "sparse", reading, false, def.sparse);
}
// Parse a glTFAnimationChannelTargetPath enum
inline void serialize(
    glTFAnimationChannelTargetPath& val, json& js, bool reading) {
    static std::vector<std::pair<std::string, glTFAnimationChannelTargetPath>>
        table = {
            {"translation", glTFAnimationChannelTargetPath::Translation},
            {"rotation", glTFAnimationChannelTargetPath::Rotation},
            {"scale", glTFAnimationChannelTargetPath::Scale},
            {"weights", glTFAnimationChannelTargetPath::Weights},
        };
    serialize(val, js, reading, table);
}

// Parses a glTFAnimationChannelTarget object
inline void serialize(glTFAnimationChannelTarget& val, json& js, bool reading) {
    static auto def = glTFAnimationChannelTarget();
    serialize_obj(js, reading);
    serialize((glTFProperty&)val, js, reading);
    serialize_attr(val.node, js, "node", reading, true, def.node);
    serialize_attr(val.path, js, "path", reading, true, def.path);
}

// Parses a glTFAnimationChannel object
inline void serialize(glTFAnimationChannel& val, json& js, bool reading) {
    static auto def = glTFAnimationChannel();
    serialize_obj(js, reading);
    serialize((glTFProperty&)val, js, reading);
    serialize_attr(val.sampler, js, "sampler", reading, true, def.sampler);
    serialize_attr(val.target, js, "target", reading, true, def.target);
}
// Parse a glTFAnimationSamplerInterpolation enum
inline void serialize(
    glTFAnimationSamplerInterpolation& val, json& js, bool reading) {
    static std::vector<
        std::pair<std::string, glTFAnimationSamplerInterpolation>>
        table = {
            {"LINEAR", glTFAnimationSamplerInterpolation::Linear},
            {"STEP", glTFAnimationSamplerInterpolation::Step},
            {"CUBICSPLINE", glTFAnimationSamplerInterpolation::CubicSpline},
        };
    serialize(val, js, reading, table);
}

// Parses a glTFAnimationSampler object
inline void serialize(glTFAnimationSampler& val, json& js, bool reading) {
    static auto def = glTFAnimationSampler();
    serialize_obj(js, reading);
    serialize((glTFProperty&)val, js, reading);
    serialize_attr(val.input, js, "input", reading, true, def.input);
    serialize_attr(val.interpolation, js, "interpolation", reading, false,
        def.interpolation);
    serialize_attr(val.output, js, "output", reading, true, def.output);
}

// Parses a glTFAnimation object
inline void serialize(glTFAnimation& val, json& js, bool reading) {
    static auto def = glTFAnimation();
    serialize_obj(js, reading);
    serialize((glTFChildOfRootProperty&)val, js, reading);
    serialize_attr(val.channels, js, "channels", reading, true, def.channels);
    serialize_attr(val.samplers, js, "samplers", reading, true, def.samplers);
}

// Parses a glTFAsset object
inline void serialize(glTFAsset& val, json& js, bool reading) {
    static auto def = glTFAsset();
    serialize_obj(js, reading);
    serialize((glTFProperty&)val, js, reading);
    serialize_attr(
        val.copyright, js, "copyright", reading, false, def.copyright);
    serialize_attr(
        val.generator, js, "generator", reading, false, def.generator);
    serialize_attr(val.version, js, "version", reading, true, def.version);
    serialize_attr(
        val.minVersion, js, "minVersion", reading, false, def.minVersion);
}

// Parses a glTFBuffer object
inline void serialize(glTFBuffer& val, json& js, bool reading) {
    static auto def = glTFBuffer();
    serialize_obj(js, reading);
    serialize((glTFChildOfRootProperty&)val, js, reading);
    serialize_attr(val.uri, js, "uri", reading, false, def.uri);
    serialize_attr(
        val.byteLength, js, "byteLength", reading, true, def.byteLength);
}
// Parse a glTFBufferViewTarget enum
inline void serialize(glTFBufferViewTarget& val, json& js, bool reading) {
    static std::vector<std::pair<int, glTFBufferViewTarget>> table = {
        {34962, glTFBufferViewTarget::ArrayBuffer},
        {34963, glTFBufferViewTarget::ElementArrayBuffer},
    };
    serialize(val, js, reading, table);
}

// Parses a glTFBufferView object
inline void serialize(glTFBufferView& val, json& js, bool reading) {
    static auto def = glTFBufferView();
    serialize_obj(js, reading);
    serialize((glTFChildOfRootProperty&)val, js, reading);
    serialize_attr(val.buffer, js, "buffer", reading, true, def.buffer);
    serialize_attr(
        val.byteOffset, js, "byteOffset", reading, false, def.byteOffset);
    serialize_attr(
        val.byteLength, js, "byteLength", reading, true, def.byteLength);
    serialize_attr(
        val.byteStride, js, "byteStride", reading, false, def.byteStride);
    serialize_attr(val.target, js, "target", reading, false, def.target);
}

// Parses a glTFCameraOrthographic object
inline void serialize(glTFCameraOrthographic& val, json& js, bool reading) {
    static auto def = glTFCameraOrthographic();
    serialize_obj(js, reading);
    serialize((glTFProperty&)val, js, reading);
    serialize_attr(val.xmag, js, "xmag", reading, true, def.xmag);
    serialize_attr(val.ymag, js, "ymag", reading, true, def.ymag);
    serialize_attr(val.zfar, js, "zfar", reading, true, def.zfar);
    serialize_attr(val.znear, js, "znear", reading, true, def.znear);
}

// Parses a glTFCameraPerspective object
inline void serialize(glTFCameraPerspective& val, json& js, bool reading) {
    static auto def = glTFCameraPerspective();
    serialize_obj(js, reading);
    serialize((glTFProperty&)val, js, reading);
    serialize_attr(
        val.aspectRatio, js, "aspectRatio", reading, false, def.aspectRatio);
    serialize_attr(val.yfov, js, "yfov", reading, true, def.yfov);
    serialize_attr(val.zfar, js, "zfar", reading, false, def.zfar);
    serialize_attr(val.znear, js, "znear", reading, true, def.znear);
}
// Parse a glTFCameraType enum
inline void serialize(glTFCameraType& val, json& js, bool reading) {
    static std::vector<std::pair<std::string, glTFCameraType>> table = {
        {"perspective", glTFCameraType::Perspective},
        {"orthographic", glTFCameraType::Orthographic},
    };
    serialize(val, js, reading, table);
}

// Parses a glTFCamera object
inline void serialize(glTFCamera& val, json& js, bool reading) {
    static auto def = glTFCamera();
    serialize_obj(js, reading);
    serialize((glTFChildOfRootProperty&)val, js, reading);
    serialize_attr(
        val.orthographic, js, "orthographic", reading, false, def.orthographic);
    serialize_attr(
        val.perspective, js, "perspective", reading, false, def.perspective);
    serialize_attr(val.type, js, "type", reading, true, def.type);
}
// Parse a glTFImageMimeType enum
inline void serialize(glTFImageMimeType& val, json& js, bool reading) {
    static std::vector<std::pair<std::string, glTFImageMimeType>> table = {
        {"image/jpeg", glTFImageMimeType::ImageJpeg},
        {"image/png", glTFImageMimeType::ImagePng},
    };
    serialize(val, js, reading, table);
}

// Parses a glTFImage object
inline void serialize(glTFImage& val, json& js, bool reading) {
    static auto def = glTFImage();
    serialize_obj(js, reading);
    serialize((glTFChildOfRootProperty&)val, js, reading);
    serialize_attr(val.uri, js, "uri", reading, false, def.uri);
    serialize_attr(val.mimeType, js, "mimeType", reading, false, def.mimeType);
    serialize_attr(
        val.bufferView, js, "bufferView", reading, false, def.bufferView);
}

// Parses a glTFTextureInfo object
inline void serialize(glTFTextureInfo& val, json& js, bool reading) {
    static auto def = glTFTextureInfo();
    serialize_obj(js, reading);
    serialize((glTFProperty&)val, js, reading);
    serialize_attr(val.index, js, "index", reading, true, def.index);
    serialize_attr(val.texCoord, js, "texCoord", reading, false, def.texCoord);
}

// Parses a glTFTexture object
inline void serialize(glTFTexture& val, json& js, bool reading) {
    static auto def = glTFTexture();
    serialize_obj(js, reading);
    serialize((glTFChildOfRootProperty&)val, js, reading);
    serialize_attr(val.sampler, js, "sampler", reading, false, def.sampler);
    serialize_attr(val.source, js, "source", reading, false, def.source);
}

// Parses a glTFMaterialNormalTextureInfo object
inline void serialize(
    glTFMaterialNormalTextureInfo& val, json& js, bool reading) {
    static auto def = glTFMaterialNormalTextureInfo();
    serialize_obj(js, reading);
    serialize((glTFTextureInfo&)val, js, reading);
    serialize_attr(val.scale, js, "scale", reading, false, def.scale);
}

// Parses a glTFMaterialOcclusionTextureInfo object
inline void serialize(
    glTFMaterialOcclusionTextureInfo& val, json& js, bool reading) {
    static auto def = glTFMaterialOcclusionTextureInfo();
    serialize_obj(js, reading);
    serialize((glTFTextureInfo&)val, js, reading);
    serialize_attr(val.strength, js, "strength", reading, false, def.strength);
}

// Parses a glTFMaterialPbrMetallicRoughness object
inline void serialize(
    glTFMaterialPbrMetallicRoughness& val, json& js, bool reading) {
    static auto def = glTFMaterialPbrMetallicRoughness();
    serialize_obj(js, reading);
    serialize((glTFProperty&)val, js, reading);
    serialize_attr(val.baseColorFactor, js, "baseColorFactor", reading, false,
        def.baseColorFactor);
    serialize_attr(val.baseColorTexture, js, "baseColorTexture", reading, false,
        def.baseColorTexture);
    serialize_attr(val.metallicFactor, js, "metallicFactor", reading, false,
        def.metallicFactor);
    serialize_attr(val.roughnessFactor, js, "roughnessFactor", reading, false,
        def.roughnessFactor);
    serialize_attr(val.metallicRoughnessTexture, js, "metallicRoughnessTexture",
        reading, false, def.metallicRoughnessTexture);
}

// Parses a glTFMaterialPbrSpecularGlossiness object
inline void serialize(
    glTFMaterialPbrSpecularGlossiness& val, json& js, bool reading) {
    static auto def = glTFMaterialPbrSpecularGlossiness();
    serialize_obj(js, reading);
    serialize((glTFProperty&)val, js, reading);
    serialize_attr(val.diffuseFactor, js, "diffuseFactor", reading, false,
        def.diffuseFactor);
    serialize_attr(val.diffuseTexture, js, "diffuseTexture", reading, false,
        def.diffuseTexture);
    serialize_attr(val.specularFactor, js, "specularFactor", reading, false,
        def.specularFactor);
    serialize_attr(val.glossinessFactor, js, "glossinessFactor", reading, false,
        def.glossinessFactor);
    serialize_attr(val.specularGlossinessTexture, js,
        "specularGlossinessTexture", reading, false,
        def.specularGlossinessTexture);
}
// Parse a glTFMaterialAlphaMode enum
inline void serialize(glTFMaterialAlphaMode& val, json& js, bool reading) {
    static std::vector<std::pair<std::string, glTFMaterialAlphaMode>> table = {
        {"OPAQUE", glTFMaterialAlphaMode::Opaque},
        {"MASK", glTFMaterialAlphaMode::Mask},
        {"BLEND", glTFMaterialAlphaMode::Blend},
    };
    serialize(val, js, reading, table);
}

// Parses a glTFMaterial object
inline void serialize(glTFMaterial& val, json& js, bool reading) {
    static auto def = glTFMaterial();
    serialize_obj(js, reading);
    serialize((glTFChildOfRootProperty&)val, js, reading);
    serialize_attr(val.pbrMetallicRoughness, js, "pbrMetallicRoughness",
        reading, false, def.pbrMetallicRoughness);
    serialize_attr(val.normalTexture, js, "normalTexture", reading, false,
        def.normalTexture);
    serialize_attr(val.occlusionTexture, js, "occlusionTexture", reading, false,
        def.occlusionTexture);
    serialize_attr(val.emissiveTexture, js, "emissiveTexture", reading, false,
        def.emissiveTexture);
    serialize_attr(val.emissiveFactor, js, "emissiveFactor", reading, false,
        def.emissiveFactor);
    serialize_attr(
        val.alphaMode, js, "alphaMode", reading, false, def.alphaMode);
    serialize_attr(
        val.alphaCutoff, js, "alphaCutoff", reading, false, def.alphaCutoff);
    serialize_attr(
        val.doubleSided, js, "doubleSided", reading, false, def.doubleSided);
    if (reading) {
        if (js.count("extensions")) {
            auto& js_ext = js["extensions"];
            serialize_attr(val.pbrSpecularGlossiness, js_ext,
                "KHR_materials_pbrSpecularGlossiness", reading, false,
                def.pbrSpecularGlossiness);
        }
    } else {
        if (val.pbrSpecularGlossiness != nullptr) {
            auto& js_ext = js["extensions"];
            serialize_attr(val.pbrSpecularGlossiness, js_ext,
                "KHR_materials_pbrSpecularGlossiness", reading, false,
                def.pbrSpecularGlossiness);
        }
    }
}
// Parse a glTFMeshPrimitiveMode enum
inline void serialize(glTFMeshPrimitiveMode& val, json& js, bool reading) {
    static std::vector<std::pair<int, glTFMeshPrimitiveMode>> table = {
        {0, glTFMeshPrimitiveMode::Points},
        {1, glTFMeshPrimitiveMode::Lines},
        {2, glTFMeshPrimitiveMode::LineLoop},
        {3, glTFMeshPrimitiveMode::LineStrip},
        {4, glTFMeshPrimitiveMode::Triangles},
        {5, glTFMeshPrimitiveMode::TriangleStrip},
        {6, glTFMeshPrimitiveMode::TriangleFan},
    };
    serialize(val, js, reading, table);
}

// Parses a glTFMeshPrimitive object
inline void serialize(glTFMeshPrimitive& val, json& js, bool reading) {
    static auto def = glTFMeshPrimitive();
    serialize_obj(js, reading);
    serialize((glTFProperty&)val, js, reading);
    serialize_attr(
        val.attributes, js, "attributes", reading, true, def.attributes);
    serialize_attr(val.indices, js, "indices", reading, false, def.indices);
    serialize_attr(val.material, js, "material", reading, false, def.material);
    serialize_attr(val.mode, js, "mode", reading, false, def.mode);
    serialize_attr(val.targets, js, "targets", reading, false, def.targets);
}

// Parses a glTFMesh object
inline void serialize(glTFMesh& val, json& js, bool reading) {
    static auto def = glTFMesh();
    serialize_obj(js, reading);
    serialize((glTFChildOfRootProperty&)val, js, reading);
    serialize_attr(
        val.primitives, js, "primitives", reading, true, def.primitives);
    serialize_attr(val.weights, js, "weights", reading, false, def.weights);
}

// Parses a glTFNode object
inline void serialize(glTFNode& val, json& js, bool reading) {
    static auto def = glTFNode();
    serialize_obj(js, reading);
    serialize((glTFChildOfRootProperty&)val, js, reading);
    serialize_attr(val.camera, js, "camera", reading, false, def.camera);
    serialize_attr(val.children, js, "children", reading, false, def.children);
    serialize_attr(val.skin, js, "skin", reading, false, def.skin);
    serialize_attr(val.matrix, js, "matrix", reading, false, def.matrix);
    serialize_attr(val.mesh, js, "mesh", reading, false, def.mesh);
    serialize_attr(val.rotation, js, "rotation", reading, false, def.rotation);
    serialize_attr(val.scale, js, "scale", reading, false, def.scale);
    serialize_attr(
        val.translation, js, "translation", reading, false, def.translation);
    serialize_attr(val.weights, js, "weights", reading, false, def.weights);
}
// Parse a glTFSamplerMagFilter enum
inline void serialize(glTFSamplerMagFilter& val, json& js, bool reading) {
    static std::vector<std::pair<int, glTFSamplerMagFilter>> table = {
        {9728, glTFSamplerMagFilter::Nearest},
        {9729, glTFSamplerMagFilter::Linear},
    };
    serialize(val, js, reading, table);
}

// Parse a glTFSamplerMinFilter enum
inline void serialize(glTFSamplerMinFilter& val, json& js, bool reading) {
    static std::vector<std::pair<int, glTFSamplerMinFilter>> table = {
        {9728, glTFSamplerMinFilter::Nearest},
        {9729, glTFSamplerMinFilter::Linear},
        {9984, glTFSamplerMinFilter::NearestMipmapNearest},
        {9985, glTFSamplerMinFilter::LinearMipmapNearest},
        {9986, glTFSamplerMinFilter::NearestMipmapLinear},
        {9987, glTFSamplerMinFilter::LinearMipmapLinear},
    };
    serialize(val, js, reading, table);
}

// Parse a glTFSamplerWrapS enum
inline void serialize(glTFSamplerWrapS& val, json& js, bool reading) {
    static std::vector<std::pair<int, glTFSamplerWrapS>> table = {
        {33071, glTFSamplerWrapS::ClampToEdge},
        {33648, glTFSamplerWrapS::MirroredRepeat},
        {10497, glTFSamplerWrapS::Repeat},
    };
    serialize(val, js, reading, table);
}

// Parse a glTFSamplerWrapT enum
inline void serialize(glTFSamplerWrapT& val, json& js, bool reading) {
    static std::vector<std::pair<int, glTFSamplerWrapT>> table = {
        {33071, glTFSamplerWrapT::ClampToEdge},
        {33648, glTFSamplerWrapT::MirroredRepeat},
        {10497, glTFSamplerWrapT::Repeat},
    };
    serialize(val, js, reading, table);
}

// Parses a glTFSampler object
inline void serialize(glTFSampler& val, json& js, bool reading) {
    static auto def = glTFSampler();
    serialize_obj(js, reading);
    serialize((glTFChildOfRootProperty&)val, js, reading);
    serialize_attr(
        val.magFilter, js, "magFilter", reading, false, def.magFilter);
    serialize_attr(
        val.minFilter, js, "minFilter", reading, false, def.minFilter);
    serialize_attr(val.wrapS, js, "wrapS", reading, false, def.wrapS);
    serialize_attr(val.wrapT, js, "wrapT", reading, false, def.wrapT);
}

// Parses a glTFScene object
inline void serialize(glTFScene& val, json& js, bool reading) {
    static auto def = glTFScene();
    serialize_obj(js, reading);
    serialize((glTFChildOfRootProperty&)val, js, reading);
    serialize_attr(val.nodes, js, "nodes", reading, false, def.nodes);
}

// Parses a glTFSkin object
inline void serialize(glTFSkin& val, json& js, bool reading) {
    static auto def = glTFSkin();
    serialize_obj(js, reading);
    serialize((glTFChildOfRootProperty&)val, js, reading);
    serialize_attr(val.inverseBindMatrices, js, "inverseBindMatrices", reading,
        false, def.inverseBindMatrices);
    serialize_attr(val.skeleton, js, "skeleton", reading, false, def.skeleton);
    serialize_attr(val.joints, js, "joints", reading, true, def.joints);
}

// Parses a glTF object
inline void serialize(glTF& val, json& js, bool reading) {
    static auto def = glTF();
    serialize_obj(js, reading);
    serialize((glTFProperty&)val, js, reading);
    serialize_attr(val.extensionsUsed, js, "extensionsUsed", reading, false,
        def.extensionsUsed);
    serialize_attr(val.extensionsRequired, js, "extensionsRequired", reading,
        false, def.extensionsRequired);
    serialize_attr(
        val.accessors, js, "accessors", reading, false, def.accessors);
    serialize_attr(
        val.animations, js, "animations", reading, false, def.animations);
    serialize_attr(val.asset, js, "asset", reading, true, def.asset);
    serialize_attr(val.buffers, js, "buffers", reading, false, def.buffers);
    serialize_attr(
        val.bufferViews, js, "bufferViews", reading, false, def.bufferViews);
    serialize_attr(val.cameras, js, "cameras", reading, false, def.cameras);
    serialize_attr(val.images, js, "images", reading, false, def.images);
    serialize_attr(
        val.materials, js, "materials", reading, false, def.materials);
    serialize_attr(val.meshes, js, "meshes", reading, false, def.meshes);
    serialize_attr(val.nodes, js, "nodes", reading, false, def.nodes);
    serialize_attr(val.samplers, js, "samplers", reading, false, def.samplers);
    serialize_attr(val.scene, js, "scene", reading, false, def.scene);
    serialize_attr(val.scenes, js, "scenes", reading, false, def.scenes);
    serialize_attr(val.skins, js, "skins", reading, false, def.skins);
    serialize_attr(val.textures, js, "textures", reading, false, def.textures);
}

// #codegen end gltf-func

#if 0
// Encode in base64
static std::string base64_encode(
    unsigned char const* bytes_to_encode, unsigned int in_len) {
    static const std::string base64_chars =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz"
        "0123456789+/";

    std::string ret;
    int i = 0;
    int j = 0;
    unsigned char char_array_3[3];
    unsigned char char_array_4[4];

    while (in_len--) {
        char_array_3[i++] = *(bytes_to_encode++);
        if (i == 3) {
            char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
            char_array_4[1] = ((char_array_3[0] & 0x03) << 4) +
                              ((char_array_3[1] & 0xf0) >> 4);
            char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) +
                              ((char_array_3[2] & 0xc0) >> 6);
            char_array_4[3] = char_array_3[2] & 0x3f;

            for (i = 0; (i < 4); i++) ret += base64_chars[char_array_4[i]];
            i = 0;
        }
    }

    if (i) {
        for (j = i; j < 3; j++) char_array_3[j] = '\0';

        char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
        char_array_4[1] =
            ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
        char_array_4[2] =
            ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
        char_array_4[3] = char_array_3[2] & 0x3f;

        for (j = 0; (j < i + 1); j++) ret += base64_chars[char_array_4[j]];

        while ((i++ < 3)) ret += '=';
    }

    return ret;
}
#endif

// Decode from base64
inline static std::string base64_decode(std::string const& encoded_string) {
    static const std::string base64_chars =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz"
        "0123456789+/";

    auto is_base64 = [](unsigned char c) -> bool {
        return (isalnum(c) || (c == '+') || (c == '/'));
    };

    int in_len = (int)encoded_string.size();
    int i = 0;
    int j = 0;
    int in_ = 0;
    unsigned char char_array_4[4], char_array_3[3];
    std::string ret;

    while (in_len-- && (encoded_string[in_] != '=') &&
           is_base64(encoded_string[in_])) {
        char_array_4[i++] = encoded_string[in_];
        in_++;
        if (i == 4) {
            for (i = 0; i < 4; i++)
                char_array_4[i] = base64_chars.find(char_array_4[i]);

            char_array_3[0] =
                (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
            char_array_3[1] = ((char_array_4[1] & 0xf) << 4) +
                              ((char_array_4[2] & 0x3c) >> 2);
            char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];

            for (i = 0; (i < 3); i++) ret += char_array_3[i];
            i = 0;
        }
    }

    if (i) {
        for (j = i; j < 4; j++) char_array_4[j] = 0;

        for (j = 0; j < 4; j++)
            char_array_4[j] = base64_chars.find(char_array_4[j]);

        char_array_3[0] =
            (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
        char_array_3[1] =
            ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
        char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];

        for (j = 0; (j < i - 1); j++) ret += char_array_3[j];
    }

    return ret;
}

inline static bool startswith(
    const std::string& str, const std::string& substr) {
    if (str.length() < substr.length()) return false;
    for (auto i = 0; i < substr.length(); i++)
        if (str[i] != substr[i]) return false;
    return true;
}

// Load buffer data.
inline void load_buffers(
    const std::shared_ptr<glTF>& gltf, const std::string& dirname) {
    auto load_binary = [](const std::string& filename) {
        // https://stackoverflow.com/questions/174531/easiest-way-to-get-files-contents-in-c
        auto f = fopen(filename.c_str(), "rb");
        if (!f) throw std::runtime_error("cannot read file " + filename);
        fseek(f, 0, SEEK_END);
        auto len = ftell(f);
        fseek(f, 0, SEEK_SET);
        auto buf = std::vector<unsigned char>(len);
        if (fread(buf.data(), 1, len, f) != len)
            throw std::runtime_error("cannot read file " + filename);
        fclose(f);
        return buf;
    };

    for (auto buffer : gltf->buffers) {
        if (buffer->uri == "") continue;
        if (startswith(buffer->uri, "data:")) {
            // assume it is base64 and find ','
            auto pos = buffer->uri.find(',');
            if (pos == buffer->uri.npos) {
                throw std::runtime_error("could not decode base64 data");
            }
            // decode
            auto data = base64_decode(buffer->uri.substr(pos + 1));
            buffer->data =
                std::vector<unsigned char>((unsigned char*)data.c_str(),
                    (unsigned char*)data.c_str() + data.length());
        } else {
            buffer->data =
                load_binary(normalize_path(dirname + "/" + buffer->uri));
            if (buffer->data.empty()) {
                throw std::runtime_error("could not load binary file " +
                                         dirname + "/" + buffer->uri);
            }
        }
        if (buffer->byteLength != buffer->data.size()) {
            throw std::runtime_error("mismatched buffer size");
        }
    }
}

// Loads a gltf.
inline std::shared_ptr<glTF> load_gltf(
    const std::string& filename, bool load_bin) {
    // clear data
    auto gltf = std::make_shared<glTF>();

    // load json
    std::ifstream stream(filename.c_str());
    if (!stream) throw std::runtime_error("could not load json " + filename);
    auto js = json();
    try {
        stream >> js;
    } catch (const std::exception& e) {
        throw std::runtime_error(
            std::string("could not load json with error ") + e.what());
    }

    // parse json
    try {
        serialize(gltf, js, true);
    } catch (const std::exception& e) {
        throw std::runtime_error("error parsing gltf " + std::string(e.what()));
    }

    // load external resources
    auto dirname = get_dirname(filename);
    if (load_bin) load_buffers(gltf, dirname);

    // done
    return gltf;
}

// Save buffer data.
inline void save_buffers(
    const std::shared_ptr<glTF>& gltf, const std::string& dirname) {
    auto save_binary = [](const std::string& filename,
                           const std::vector<unsigned char>& data) {
        auto f = fopen(filename.c_str(), "wb");
        if (!f) throw std::runtime_error("cannot write file " + filename);
        auto num = fwrite(data.data(), 1, data.size(), f);
        if (num != data.size())
            throw std::runtime_error("cannot write file " + filename);
        fclose(f);
    };

    for (auto buffer : gltf->buffers) {
        if (startswith(buffer->uri, "data:")) {
            throw std::runtime_error("saving of embedded data not supported");
        }
        save_binary(dirname + "/" + buffer->uri, buffer->data);
    }
}

// Saves a gltf.
inline void save_gltf(const std::string& filename,
    const std::shared_ptr<glTF>& gltf, bool save_bin) {
    auto save_text = [](const std::string& filename, const std::string& str) {
        auto f = fopen(filename.c_str(), "wb");
        if (!f) throw std::runtime_error("cannot write file " + filename);
        auto num = fwrite(str.c_str(), 1, str.size(), f);
        if (num != str.size())
            throw std::runtime_error("cannot write file " + filename);
        fclose(f);
    };

    // dumps json
    auto js = json();
    serialize((std::shared_ptr<glTF>&)gltf, js, false);

    // save json
    save_text(filename, js.dump(2));

    // save external resources
    auto dirname = get_dirname(filename);
    if (save_bin) save_buffers(gltf, dirname);
}

// reading shortcut
template <typename T>
inline void gltf_fread(FILE* f, T* v, int count) {
    if (fread(v, sizeof(T), count, f) != count)
        throw std::runtime_error("could not read binary file");
}

// writing shortcut
template <typename T>
inline void gltf_fwrite(FILE* f, const T* v, int count) {
    if (fwrite(v, sizeof(T), count, f) != count)
        std::runtime_error("could not write binary file");
}

// Loads a binary gltf.
inline std::shared_ptr<glTF> load_binary_gltf(
    const std::string& filename, bool load_bin) {
    // clear data
    auto gltf = std::make_shared<glTF>();

    // opens binary file
    auto f = fopen(filename.c_str(), "rb");
    if (!f) throw std::runtime_error("could not load binary file " + filename);

    // read magic
    uint32_t magic;
    gltf_fread(f, &magic, 1);
    if (magic != 0x46546C67) throw std::runtime_error("corrupted glb format");

    // read version
    uint32_t version;
    gltf_fread(f, &version, 1);
    if (version != 1 && version != 2)
        throw std::runtime_error("unsupported glb version");

    // read length
    uint32_t length;
    gltf_fread(f, &length, 1);

    // data
    auto json_bytes = std::vector<char>();
    auto buffer_bytes = std::vector<unsigned char>();
    uint32_t buffer_length = 0;

    if (version == 1) {
        // read content length and format
        uint32_t json_length, json_format;
        gltf_fread(f, &json_length, 1);
        gltf_fread(f, &json_format, 1);

        // read json bytes
        json_bytes.resize(json_length);
        gltf_fread(f, json_bytes.data(), json_length);

        // read buffer bytes
        if (load_bin) {
            buffer_bytes.resize(length - json_length - 20);
            gltf_fread(f, buffer_bytes.data(), (int)buffer_bytes.size());
            buffer_length = (int)buffer_bytes.size();
        }
    }

    if (version == 2) {
        // read content length and format
        uint32_t json_length, json_format;
        gltf_fread(f, &json_length, 1);
        gltf_fread(f, &json_format, 1);
        if (json_format != 0x4E4F534A) {
            throw std::runtime_error("corrupt binary format");
            return nullptr;
        }

        // read json bytes
        json_bytes.resize(json_length);
        gltf_fread(f, json_bytes.data(), (int)json_bytes.size());

        // read content length and format
        uint32_t buffer_format;
        gltf_fread(f, &buffer_length, 1);
        gltf_fread(f, &buffer_format, 1);
        if (buffer_format != 0x004E4942)
            throw std::runtime_error("corrupt binary format");

        // read buffer bytes
        if (load_bin) {
            buffer_bytes.resize(buffer_length);
            gltf_fread(f, buffer_bytes.data(), (int)buffer_bytes.size());
        }
    }

    // load json
    auto js = json();
    try {
        json_bytes.push_back(0);
        js = json::parse(json_bytes.data());
    } catch (const std::exception& e) {
        throw std::runtime_error(
            std::string("could not load json with error ") + e.what());
    }

    // parse json
    try {
        serialize(gltf, js, true);
    } catch (const std::exception& e) {
        throw std::runtime_error(
            "cannot parse gltf json " + std::string(e.what()));
        return nullptr;
    }

    // fix internal buffer
    auto buffer = gltf->buffers.at(0);
    buffer->byteLength = buffer_length;
    if (version == 2) buffer->uri = "";
    if (load_bin) { buffer->data = buffer_bytes; }

    // load external resources
    auto dirname = get_dirname(filename);
    if (load_bin) load_buffers(gltf, dirname);

    // close
    fclose(f);

    // done
    return gltf;
}

// Saves a binary gltf.
inline void save_binary_gltf(const std::string& filename,
    const std::shared_ptr<glTF>& gltf, bool save_bin) {
    // opens binary file
    auto f = fopen(filename.c_str(), "wb");
    if (!f) throw std::runtime_error("could not write binary file");

    // dumps json
    auto js = json();
    serialize((std::shared_ptr<glTF>&)gltf, js, false);

    // fix string
    auto js_str = js.dump(2);
    while (js_str.length() % 4) js_str += " ";
    uint32_t json_length = (uint32_t)js_str.size();

    // internal buffer
    auto buffer = gltf->buffers.at(0);
    uint32_t buffer_length = buffer->byteLength;
    if (buffer_length % 4) buffer_length += 4 - buffer_length % 4;

    // write header
    uint32_t magic = 0x46546C67;
    gltf_fwrite(f, &magic, 1);
    uint32_t version = 2;
    gltf_fwrite(f, &version, 1);
    uint32_t length = 12 + 8 + json_length + 8 + buffer_length;
    gltf_fwrite(f, &length, 1);

    // write json
    uint32_t json_type = 0x4E4F534A;
    gltf_fwrite(f, &json_length, 1);
    gltf_fwrite(f, &json_type, 1);
    gltf_fwrite(f, js_str.data(), (int)json_length);

    if (save_bin) {
        uint32_t buffer_type = 0x004E4942;
        gltf_fwrite(f, &buffer_length, 1);
        gltf_fwrite(f, &buffer_type, 1);
        gltf_fwrite(f, buffer->data.data(), (int)buffer->data.size());
        char pad = 0;
        for (auto i = 0; i < buffer_length - buffer->data.size(); i++)
            gltf_fwrite(f, &pad, 1);
    }

    // close
    fclose(f);

    // save external resources
    auto dirname = get_dirname(filename);
    if (save_bin) save_buffers(gltf, dirname);
}

// Load glTF texture images.
void load_gltf_textures(
    glTF* gltf, const std::string& dirname, bool skip_missing) {
    // set gamma
    auto ldr_gamma =
        std::unordered_map<std::shared_ptr<glTFImage>, float>{{nullptr, 1.0f}};
    for (auto gimg : gltf->images) ldr_gamma[gimg] = 2.2f;
    auto set_gamma = [&ldr_gamma, gltf](
                         std::shared_ptr<glTFTextureInfo> info, float gamma) {
        if (!info) return;
        auto gtxt = gltf->get(info->index);
        if (!gtxt) return;
        auto gimg = gltf->get(gtxt->source);
        if (!gimg) return;
        ldr_gamma[gimg] = gamma;
    };
    for (auto mat : gltf->materials) {
        set_gamma(mat->emissiveTexture, 2.2f);
        if (mat->pbrMetallicRoughness) {
            auto mr = mat->pbrMetallicRoughness;
            set_gamma(mr->baseColorTexture, 2.2f);
            set_gamma(mr->metallicRoughnessTexture, 1);
        }
        if (mat->pbrSpecularGlossiness) {
            auto sg = mat->pbrSpecularGlossiness;
            set_gamma(sg->diffuseTexture, 2.2f);
            set_gamma(sg->specularGlossinessTexture, 1);
        }
        set_gamma(mat->normalTexture, 1.0f);
        set_gamma(mat->occlusionTexture, 1.0f);
    }

    // load images
    for (auto gimg : gltf->images) {
        auto filename = std::string();
        gimg->data = {};
        if (gimg->bufferView || startswith(gimg->uri, "data:")) {
            auto buffer = std::string();
            auto data = (unsigned char*)nullptr;
            auto data_size = 0;
            if (gimg->bufferView) {
                auto view = gltf->get(gimg->bufferView);
                auto buffer = gltf->get(view->buffer);
                if (!view || !buffer || view->byteStride) {
                    if (skip_missing) continue;
                    throw std::runtime_error("invalid image buffer view");
                }
                if (gimg->mimeType == glTFImageMimeType::ImagePng)
                    filename = "internal_data.png";
                else if (gimg->mimeType == glTFImageMimeType::ImageJpeg)
                    filename = "internal_data.jpg";
                else {
                    if (skip_missing) continue;
                    throw std::runtime_error("unsupported image format");
                }
                data = buffer->data.data() + view->byteOffset;
                data_size = view->byteLength;
            } else {
                // assume it is base64 and find ','
                auto pos = gimg->uri.find(',');
                if (pos == gimg->uri.npos) {
                    if (skip_missing) continue;
                    throw std::runtime_error("could not decode base64 data");
                }
                auto header = gimg->uri.substr(0, pos);
                for (auto format : {"png", "jpg", "jpeg", "tga", "ppm", "hdr"})
                    if (header.find(format) != header.npos)
                        filename = std::string("fake.") + format;
                if (is_hdr_filename(filename)) {
                    if (skip_missing) continue;
                    throw std::runtime_error(
                        "unsupported embedded image format " +
                        header.substr(0, pos));
                }
                // decode
                buffer = base64_decode(gimg->uri.substr(pos + 1));
                data_size = (int)buffer.size();
                data = (unsigned char*)buffer.data();
            }
            try {
                gimg->data =
                    load_image_from_memory(data, data_size, ldr_gamma.at(gimg));
            } catch (std::exception&) {
                if (skip_missing) continue;
                throw;
            }
        } else {
            filename = normalize_path(dirname + "/" + gimg->uri);
            try {
                gimg->data = load_image4f(filename, ldr_gamma.at(gimg));
            } catch (std::exception&) {
                if (skip_missing) continue;
                throw;
            }
        }
    }
}

// Save glTF texture images.
void save_gltf_textures(const std::shared_ptr<glTF>& gltf,
    const std::string& dirname, bool skip_missing) {
    // set gamma
    auto ldr_gamma =
        std::unordered_map<std::shared_ptr<glTFImage>, float>{{nullptr, 1.0f}};
    for (auto gimg : gltf->images) ldr_gamma[gimg] = 2.2f;
    auto set_gamma = [&ldr_gamma, gltf](
                         std::shared_ptr<glTFTextureInfo> info, float gamma) {
        if (!info) return;
        auto gtxt = gltf->get(info->index);
        if (!gtxt) return;
        auto gimg = gltf->get(gtxt->source);
        if (!gimg) return;
        ldr_gamma[gimg] = gamma;
    };
    for (auto mat : gltf->materials) {
        set_gamma(mat->emissiveTexture, 2.2f);
        if (mat->pbrMetallicRoughness) {
            auto mr = mat->pbrMetallicRoughness;
            set_gamma(mr->baseColorTexture, 2.2f);
            set_gamma(mr->metallicRoughnessTexture, 1);
        }
        if (mat->pbrSpecularGlossiness) {
            auto sg = mat->pbrSpecularGlossiness;
            set_gamma(sg->diffuseTexture, 2.2f);
            set_gamma(sg->specularGlossinessTexture, 1);
        }
        set_gamma(mat->normalTexture, 1.0f);
        set_gamma(mat->occlusionTexture, 1.0f);
    }

    // save images
    for (auto gimg : gltf->images) {
        if (gimg->data.empty()) continue;
        if (startswith(gimg->uri, "data:")) {
            if (skip_missing) continue;
            throw std::runtime_error("saving of embedded data not supported");
        }
        auto filename = normalize_path(dirname + "/" + gimg->uri);
        try {
            save_image4f(filename, gimg->data, ldr_gamma.at(gimg));
        } catch (std::exception&) {
            if (skip_missing) continue;
            throw;
        }
    }
}

inline accessor_view::accessor_view(const std::shared_ptr<glTF>& gltf,
    const std::shared_ptr<glTFAccessor>& accessor) {
    _size = accessor->count;
    _ncomp = _num_components(accessor->type);
    _ctype = accessor->componentType;
    _normalize = accessor->normalized;
    auto buffer_view = gltf->get(accessor->bufferView);
    _stride = (buffer_view->byteStride) ? buffer_view->byteStride :
                                          (_ctype_size(_ctype) * _ncomp);
    auto buffer = gltf->get(buffer_view->buffer);
    _data =
        buffer->data.data() + accessor->byteOffset + buffer_view->byteOffset;
    auto remaining_buffer_bytes =
        buffer->data.size() - (_data - buffer->data.data());
    auto view_bytes = _size * _stride;
    _valid = remaining_buffer_bytes >= view_bytes;
    if (!_valid) throw std::runtime_error("corrupted glTF accessor view");
}

inline float accessor_view::get(int idx, int c) const {
    auto i = min(max(c, 0), ncomp() - 1);
    auto valb = _data + _stride * idx + i * _ctype_size(_ctype);
    // use double for integer conversion to attempt to maintain
    // precision
    if (!_normalize) {
        switch (_ctype) {
            case glTFAccessorComponentType::Float:
                return (float)(*(float*)valb);
            case glTFAccessorComponentType::Byte: return (float)(*(char*)valb);
            case glTFAccessorComponentType::UnsignedByte:
                return (float)(*(unsigned char*)valb);
            case glTFAccessorComponentType::Short:
                return (float)(*(short*)valb);
            case glTFAccessorComponentType::UnsignedShort:
                return (float)(*(unsigned short*)valb);
            case glTFAccessorComponentType::UnsignedInt:
                return (float)(*(unsigned int*)valb);
            case glTFAccessorComponentType::NotSet:
                throw std::runtime_error("bad enum value");
                break;
        }

    } else {
        switch (_ctype) {
            case glTFAccessorComponentType::Float:
                return (float)(*(float*)valb);
            case glTFAccessorComponentType::Byte:
                return (float)max((float)(c / 127.0), -1.0f);
            case glTFAccessorComponentType::UnsignedByte:
                return (float)(c / 255.0);
            case glTFAccessorComponentType::Short:
                return (float)(max((float)(c / 32767.0), -1.0f));
            case glTFAccessorComponentType::UnsignedShort:
                return (float)(c / 65535.0);
            case glTFAccessorComponentType::UnsignedInt:
                return (float)(max((float)(c / 2147483647.0), -1.0f));
            case glTFAccessorComponentType::NotSet:
                throw std::runtime_error("bad enum value");
                break;
        }
    }
    return 0;
}

inline int accessor_view::geti(int idx, int c) const {
    auto i = min(max(c, 0), ncomp() - 1);
    auto valb = _data + _stride * idx + i * _ctype_size(_ctype);
    // use double for integer conversion to attempt to maintain
    // precision
    switch (_ctype) {
        case glTFAccessorComponentType::Float: return (int)(*(float*)valb);
        case glTFAccessorComponentType::Byte: return (int)(*(char*)valb);
        case glTFAccessorComponentType::UnsignedByte:
            return (int)(*(unsigned char*)valb);
        case glTFAccessorComponentType::Short: return (int)(*(short*)valb);
        case glTFAccessorComponentType::UnsignedShort:
            return (int)(*(unsigned short*)valb);
        case glTFAccessorComponentType::UnsignedInt:
            return (int)(*(unsigned int*)valb);
        case glTFAccessorComponentType::NotSet:
            throw std::runtime_error("bad enum value");
            break;
    }
    return 0;
}

inline int accessor_view::_num_components(glTFAccessorType type) {
    switch (type) {
        case glTFAccessorType::NotSet: return 1;
        case glTFAccessorType::Scalar: return 1;
        case glTFAccessorType::Vec2: return 2;
        case glTFAccessorType::Vec3: return 3;
        case glTFAccessorType::Vec4: return 4;
        case glTFAccessorType::Mat2: return 4;
        case glTFAccessorType::Mat3: return 9;
        case glTFAccessorType::Mat4: return 16;
    }
}

inline int accessor_view::_ctype_size(glTFAccessorComponentType componentType) {
    switch (componentType) {
        case glTFAccessorComponentType::NotSet: return 1;
        case glTFAccessorComponentType::Byte: return 1;
        case glTFAccessorComponentType::UnsignedByte: return 1;
        case glTFAccessorComponentType::Short: return 2;
        case glTFAccessorComponentType::UnsignedShort: return 2;
        case glTFAccessorComponentType::UnsignedInt: return 4;
        case glTFAccessorComponentType::Float: return 4;
    }
}

}  // namespace ygl

#endif
