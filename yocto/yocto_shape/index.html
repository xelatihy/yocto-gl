
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <meta name="author" content="Fabio Pellacini">
      
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-7.0.5">
    
    
      
        <title>Shape utilities - Yocto/GL</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.77f3fd56.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.7fa14f5b.min.css">
        
          
          
          <meta name="theme-color" content="#2094f3">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="blue" data-md-color-accent="">
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#yoctoshape-shape-utilities" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Yocto/GL" class="md-header__button md-logo" aria-label="Yocto/GL">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Yocto/GL
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Shape utilities
            
          </span>
        </div>
      </div>
    </div>
    <div class="md-header__options">
      
    </div>
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        
<a href="https://github.com/xelatihy/yocto-gl/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    xelatihy/yocto-gl
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    




<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Yocto/GL" class="md-nav__button md-logo" aria-label="Yocto/GL">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Yocto/GL
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/xelatihy/yocto-gl/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    xelatihy/yocto-gl
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        About
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../gallery/" class="md-nav__link">
        Gallery
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_math/" class="md-nav__link">
        Math types
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_color/" class="md-nav__link">
        Color operations
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_geometry/" class="md-nav__link">
        Geometry operations
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_sampling/" class="md-nav__link">
        Sampling routines
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_noise/" class="md-nav__link">
        Noise functions
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_shading/" class="md-nav__link">
        Shading routines
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_image/" class="md-nav__link">
        Image utilities
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Shape utilities
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Shape utilities
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#shape-representation" class="md-nav__link">
    Shape representation
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shape-serialization" class="md-nav__link">
    Shape serialization
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shape-properties" class="md-nav__link">
    Shape properties
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shape-sampling" class="md-nav__link">
    Shape sampling
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#procedural-shapes" class="md-nav__link">
    Procedural shapes
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-shape-representation" class="md-nav__link">
    Low-level interface: Shape representation
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-vertex-properties" class="md-nav__link">
    Low-level interface: Vertex properties
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-flipping-and-aligning" class="md-nav__link">
    Low-level interface: Flipping and aligning
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-edges-and-adjacencies" class="md-nav__link">
    Low-level interface: Edges and adjacencies
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-ray-intersection-and-point-overlap" class="md-nav__link">
    Low-level interface: Ray-intersection and point-overlap
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-nearest-neighbors" class="md-nav__link">
    Low-level interface: Nearest neighbors
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-element-conversions-and-grouping" class="md-nav__link">
    Low-level interface: Element conversions and grouping
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-shape-subdivision" class="md-nav__link">
    Low-level interface: Shape subdivision
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-shape-sampling" class="md-nav__link">
    Low-level interface: Shape sampling
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-procedural-shapes" class="md-nav__link">
    Low-level interface: Procedural shapes
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_mesh/" class="md-nav__link">
        Mesh processing
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_scene/" class="md-nav__link">
        Scene representation
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_bvh/" class="md-nav__link">
        Ray-scene intersection
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_trace/" class="md-nav__link">
        Path tracing
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_cli/" class="md-nav__link">
        Command-line utilities
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_imageio/" class="md-nav__link">
        Image serialization
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_shapeio/" class="md-nav__link">
        Shape serialization
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_sceneio/" class="md-nav__link">
        Scene serialization
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_commonio/" class="md-nav__link">
        Json and serialization utilities
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_modelio/" class="md-nav__link">
        Model serialization
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../yocto_parallel/" class="md-nav__link">
        Concurrency utilities
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#shape-representation" class="md-nav__link">
    Shape representation
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shape-serialization" class="md-nav__link">
    Shape serialization
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shape-properties" class="md-nav__link">
    Shape properties
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shape-sampling" class="md-nav__link">
    Shape sampling
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#procedural-shapes" class="md-nav__link">
    Procedural shapes
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-shape-representation" class="md-nav__link">
    Low-level interface: Shape representation
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-vertex-properties" class="md-nav__link">
    Low-level interface: Vertex properties
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-flipping-and-aligning" class="md-nav__link">
    Low-level interface: Flipping and aligning
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-edges-and-adjacencies" class="md-nav__link">
    Low-level interface: Edges and adjacencies
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-ray-intersection-and-point-overlap" class="md-nav__link">
    Low-level interface: Ray-intersection and point-overlap
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-nearest-neighbors" class="md-nav__link">
    Low-level interface: Nearest neighbors
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-element-conversions-and-grouping" class="md-nav__link">
    Low-level interface: Element conversions and grouping
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-shape-subdivision" class="md-nav__link">
    Low-level interface: Shape subdivision
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-shape-sampling" class="md-nav__link">
    Low-level interface: Shape sampling
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#low-level-interface-procedural-shapes" class="md-nav__link">
    Low-level interface: Procedural shapes
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="yoctoshape-shape-utilities">Yocto/Shape: Shape utilities</h1>
<p>Yocto/Shape is a collection of utilities for manipulating shapes in 3D
graphics, with a focus on triangle and quad meshes.
Yocto/Shape is implemented in <code>yocto_shape.h</code> and <code>yocto_shape.cpp</code>.</p>
<h2 id="shape-representation">Shape representation</h2>
<p>Yocto/Shape supports shapes defined as collection of either points, lines,
triangles and quads. Shapes are represented as indexed meshes, with arbitrary 
properties for each vertex. Each vertex property is stored as a separate array,
and shape elements are stored as arrays of indices to faces.
For element parametrization, we follow <a href="../yocto_geometry/">Yocto/Geometry</a>.</p>
<p>Shapes are represented as a simple struct called <code>shape_data</code>, that stores
the shape elements and the vertex properties as individual arrays.
Shapes can contain only one type of element, either points, lines, triangles or quads. 
Vertex properties are defined as separate arrays and include
positions, normals, texture coords, colors, radius and tangent spaces.
Vertex data is stored as <code>vector&lt;vecXf&gt;</code>, while element indices are stored
as <code>vector&lt;vec3i&gt;</code>, <code>vector&lt;vec4i&gt;</code>, <code>vector&lt;vec2i&gt;</code>, <code>vector&lt;int&gt;</code>
for triangle meshes, quad meshes, line sets and point sets respectively.</p>
<p>For shapes, you should set the shape elements, i.e. point, limes, triangles
or quads, and the vertex properties, i.e. positions, normals, texture
coordinates, colors and radia. Shapes support only one element type.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">shape_data</span><span class="p">{};</span>             <span class="c1">// create a shape</span>
<span class="n">shape</span><span class="p">.</span><span class="n">triangles</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">{...};</span>  <span class="c1">// set triangle indices</span>
<span class="n">shape</span><span class="p">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>  <span class="c1">// set positions</span>
<span class="n">shape</span><span class="p">.</span><span class="n">normals</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>    <span class="c1">// set normals</span>
<span class="n">shape</span><span class="p">.</span><span class="n">texcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">{...};</span>  <span class="c1">// set texture coordinates</span>
</code></pre></div>
<p>Additionally, Yocto/Scene supports face-varying shape, as <code>fvshape_data</code>,
where each vertex data has its own topology. For now, only face-varying quad 
meshes are supported since fave-varying shapes are used mostly with 
Catmull-Clark subdivision.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">fvshape_data</span><span class="p">{};</span>                <span class="c1">// create a shape</span>
<span class="n">shape</span><span class="p">.</span><span class="n">quadspos</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{...};</span>        <span class="c1">// set face-varying indices</span>
<span class="n">shape</span><span class="p">.</span><span class="n">quadstexcoord</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{...};</span>   <span class="c1">// for positions and textures</span>
<span class="n">shape</span><span class="p">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>       <span class="c1">// set positions</span>
<span class="n">shape</span><span class="p">.</span><span class="n">texcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">{...};</span>       <span class="c1">// set texture coordinates</span>
</code></pre></div>
<p>Conversion to and from face-varying shapes is handled by the 
<code>shape_to_fvshape(shape)</code> and <code>fvshape_to_shape(fvshape)</code> functions.
Note that conversion to an indexed shape is lossy since topology information is
lost and vertices may be duplicated.</p>
<h2 id="shape-serialization">Shape serialization</h2>
<p>Shape loading and saving is defined in <a href="../yocto_shapeio/">Yocto/ShapeIO</a>.</p>
<h2 id="shape-properties">Shape properties</h2>
<p>Several functions are defined to evaluate the geometric properties of points
of shapes, indicated by the shape element id and, when needed, the shape element
barycentric coordinates.
Use <code>eval_position(...)</code> to evaluate the point position,
<code>eval_normal(...)</code> to evaluate the interpolate point normal,
<code>eval_texcoord(...)</code> to evaluate the point texture coordinates,
<code>eval_element_normal(...)</code> to evaluate the point geometric normal, and
<code>eval_color(...)</code> to evaluate the interpolate point color.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">eid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">auto</span> <span class="n">euv</span> <span class="o">=</span> <span class="n">vec3f</span><span class="p">{</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">};</span>    <span class="c1">// element id and uvs</span>
<span class="k">auto</span> <span class="n">pos</span>  <span class="o">=</span> <span class="n">eval_position</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">eid</span><span class="p">,</span> <span class="n">euv</span><span class="p">);</span> <span class="c1">// eval point position</span>
<span class="k">auto</span> <span class="n">norm</span> <span class="o">=</span> <span class="n">eval_normal</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">eid</span><span class="p">,</span> <span class="n">euv</span><span class="p">);</span>   <span class="c1">// eval point normal</span>
<span class="k">auto</span> <span class="n">st</span>   <span class="o">=</span> <span class="n">eval_texcoord</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">eid</span><span class="p">,</span> <span class="n">euv</span><span class="p">);</span> <span class="c1">// eval point texture coords</span>
<span class="k">auto</span> <span class="n">col</span>  <span class="o">=</span> <span class="n">eval_color</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">eid</span><span class="p">,</span> <span class="n">euv</span><span class="p">);</span>    <span class="c1">// eval point color</span>
<span class="k">auto</span> <span class="n">gn</span>   <span class="o">=</span> <span class="n">eval_element_normal</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">eid</span><span class="p">,</span> <span class="n">euv</span><span class="p">);</span> <span class="c1">// eval geometric normal</span>
</code></pre></div>
<p>For shapes, we also support the computation of smooth vertex normals with
<code>compute_normals(shape)</code> and converting to and from face-varying representations
with <code>shape_to_fvshape(shape)</code> and <code>fvshape_to_shape(fvshape)</code>.</p>
<h2 id="shape-sampling">Shape sampling</h2>
<p>Shape support random sampling with a uniform distribution using
<code>sample_shape(...)</code> and <code>sample_shape_cdf(shape)</code>. Sampling works for lines and
triangles in all cases, while for quad it requires that the elements
are rectangular.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">cdf</span> <span class="o">=</span> <span class="n">sample_shape_cdfd</span><span class="p">(</span><span class="n">shape</span><span class="p">);</span>         <span class="c1">// compute the shape CDF</span>
<span class="k">auto</span> <span class="n">points</span> <span class="o">=</span> <span class="n">sample_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">cdf</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span> <span class="c1">// sample many points</span>
<span class="k">auto</span> <span class="n">point</span> <span class="o">=</span> <span class="n">sample_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">cdf</span><span class="p">,</span>        <span class="c1">// sample a single point</span>
  <span class="n">rand1f</span><span class="p">(</span><span class="n">rng</span><span class="p">),</span> <span class="n">rand2f</span><span class="p">(</span><span class="n">rng</span><span class="p">));</span>
</code></pre></div>
<h2 id="procedural-shapes">Procedural shapes</h2>
<p>Yocto/Scene has convenience function to create various procedural shapes,
both for testing and for use in shape creation. These are wrappers to the
corresponding functions in <a href="./">Yocto/Shape</a>, where we maintain
a comprehensive list of all procedural shapes supported.</p>
<p>Procedural shapes take as input the desired shape resolution, the shape scale,
the uv scale, and additional parameters specific to that procedural shape.
These functions return a quad mesh, stored as a <code>shape_data</code> struct.
Use <code>make_rect(...)</code> for a rectangle in the XY plane,
<code>make_bulged_rect(...)</code> for a bulged rectangle,
<code>make_recty(...)</code> for a rectangle in the XZ plane,
<code>make_bulged_recty(...)</code> for a bulged rectangle in the XZ plane,
<code>make_box(...)</code> for a box,
<code>make_rounded_box(...)</code> for a rounded box,
<code>make_floor(...)</code> for a floor in the XZ plane,
<code>make_bent_floor(...)</code> for a bent floor,
<code>make_sphere(...)</code> for a sphere obtained from a cube,
<code>make_uvsphere(...)</code> for a sphere tessellated along its uvs,
<code>make_capped_uvsphere(...)</code> for a sphere with flipped caps,
<code>make_disk(...)</code> for a disk obtained from a quad,
<code>make_bulged_disk(...)</code> for a bulged disk,
<code>make_uvdisk(...)</code> for a disk tessellated along its uvs,
<code>make_uvcylinder(...)</code> for a cylinder tessellated along its uvs,
<code>make_rounded_uvcylinder(...)</code> for a rounded cylinder.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// make shapes with 32 steps in resolution and scale of 1</span>
<span class="k">auto</span> <span class="n">shape_01</span> <span class="o">=</span> <span class="n">make_rect</span><span class="p">({</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="k">auto</span> <span class="n">shape_02</span> <span class="o">=</span> <span class="n">make_bulged_rect</span><span class="p">({</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="k">auto</span> <span class="n">shape_03</span> <span class="o">=</span> <span class="n">make_recty</span><span class="p">({</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="k">auto</span> <span class="n">shape_04</span> <span class="o">=</span> <span class="n">make_box</span><span class="p">({</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="k">auto</span> <span class="n">shape_05</span> <span class="o">=</span> <span class="n">make_rounded_box</span><span class="p">({</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="k">auto</span> <span class="n">shape_06</span> <span class="o">=</span> <span class="n">make_floor</span><span class="p">({</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">});</span>
<span class="k">auto</span> <span class="n">shape_07</span> <span class="o">=</span> <span class="n">make_bent_floor</span><span class="p">({</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">});</span>
<span class="k">auto</span> <span class="n">shape_08</span> <span class="o">=</span> <span class="n">make_sphere</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">shape_09</span> <span class="o">=</span> <span class="n">make_uvsphere</span><span class="p">({</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">shape_10</span> <span class="o">=</span> <span class="n">make_capped_uvsphere</span><span class="p">({</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">shape_11</span> <span class="o">=</span> <span class="n">make_disk</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">shape_12</span> <span class="o">=</span> <span class="n">make_bulged_disk</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">shape_13</span> <span class="o">=</span> <span class="n">make_uvdiskm</span><span class="p">({</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">shape_14</span> <span class="o">=</span> <span class="n">make_uvcylinder</span><span class="p">({</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="k">auto</span> <span class="n">shape_15</span> <span class="o">=</span> <span class="n">make_rounded_uvcylinder</span><span class="p">({</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
</code></pre></div>
<p>Yocto/Shape defines a few procedural face-varying shapes with similar interfaces
to the above functions. In this case, the functions return face-varying quads
packed in a <code>fvshape_data</code> struct.
Use <code>make_fvrect(...)</code> for a rectangle in the XY plane,
<code>make_fvbox(...)</code> for a box,
<code>make_fvsphere(...)</code> for a sphere obtained from a cube.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// make face-varying shapes with 32 steps in resolution and scale of 1</span>
<span class="k">auto</span> <span class="n">fvshape_01</span> <span class="o">=</span> <span class="n">make_fvrect</span><span class="p">({</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="k">auto</span> <span class="n">fvshape_02</span> <span class="o">=</span> <span class="n">make_fvbox</span><span class="p">({</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="k">auto</span> <span class="n">fvshape_03</span> <span class="o">=</span> <span class="n">make_fvsphere</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>Yocto/Shape provides functions to create predefined shapes helpful in testing.
These functions take only a scale and often provide only the positions as
vertex data. These functions return either triangles, quads, or
face-varying quads in a <code>shape_data</code> or <code>fvshape_data</code> struct.
Use <code>make_monkey(...)</code> for the Blender monkey as quads and positions only,
<code>make_quad(...)</code> for a simple quad,
<code>make_quady(...)</code> for a simple quad in the XZ plane,
<code>make_cube(...)</code> for a simple cube as quads and positions only,
<code>make_fvcube(...)</code> for a simple face-varying unit cube,
<code>make_geosphere(...)</code> for a geodesic sphere as triangles and positions only.
These functions return a <code>shape_data</code> or <code>fvshape_data</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">monkey</span> <span class="o">=</span> <span class="n">make_monkey</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">quad</span>   <span class="o">=</span> <span class="n">make_quad</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">quady</span>  <span class="o">=</span> <span class="n">make_quady</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">cube</span>   <span class="o">=</span> <span class="n">make_cube</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">geosph</span> <span class="o">=</span> <span class="n">make_geosphere</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">fvcube</span> <span class="o">=</span> <span class="n">make_fvcube</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>Yocto/Shape supports the generation of points and lines sets.
Use <code>make_lines(...)</code> to create a line set in the XY plane,
<code>make_points(...)</code> for a collection of points at the origin,
adn <code>make_random_points(...)</code> for a point set randomly placed in a box.
These functions return points or lines, packed in a <code>shape_data</code> struct.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">lines_01</span> <span class="o">=</span> <span class="n">make_lines</span><span class="p">({</span><span class="mi">4</span><span class="p">,</span> <span class="mi">65536</span><span class="p">},</span>      <span class="c1">// line steps and number of lines</span>
                           <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>  <span class="c1">// line set scale and uvscale</span>
                           <span class="p">{</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">});</span> <span class="c1">// radius at the bottom and top</span>
<span class="c1">// procedural points return points, positions, normals, texcoords, radia</span>
<span class="k">auto</span> <span class="p">[</span><span class="n">points</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="n">radius</span><span class="p">]</span> <span class="o">=</span> <span class="n">make_points</span><span class="p">(</span><span class="mi">65536</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">points_01</span> <span class="o">=</span> <span class="n">make_points</span><span class="p">(</span><span class="mi">65536</span><span class="p">,</span>        <span class="c1">// number of points</span>
                             <span class="mi">1</span><span class="p">,</span>            <span class="c1">// uvscale</span>
                             <span class="mf">0.001</span><span class="p">);</span>       <span class="c1">// point radius</span>
<span class="k">auto</span> <span class="n">points_02</span> <span class="o">=</span> <span class="n">make_random_points</span><span class="p">(</span><span class="mi">65536</span><span class="p">,</span> <span class="c1">// number of points</span>
                             <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// line set scale and uvscale</span>
                             <span class="mf">0.001</span><span class="p">);</span>       <span class="c1">// point radius</span>
</code></pre></div>
<p>Yocto/Shape also defines a simple functions to generate randomized hairs
on a triangle or quad mesh. Use <code>make_hair(...)</code> to create a hair shape
from a triangle and quad mesh, and return a line set.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Make a hair ball around a shape</span>
<span class="k">auto</span> <span class="n">lines</span> <span class="o">=</span>  <span class="n">make_hair</span><span class="p">(</span>
  <span class="n">make_sphere</span><span class="p">(),</span>  <span class="c1">// sampled surface</span>
  <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">65536</span><span class="p">},</span>     <span class="c1">// steps: line steps and number of lines</span>
  <span class="p">{</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">},</span>     <span class="c1">// length: minimum and maximum length</span>
  <span class="p">{</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">},</span> <span class="c1">// radius: minimum and maximum radius from base to tip</span>
  <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span>        <span class="c1">// noise: noise added to hair (strength/scale)</span>
  <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">},</span>       <span class="c1">// clump: clump added to hair (strength/number)</span>
  <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">});</span>        <span class="c1">// rotation: rotation added to hair (angle/strength)</span>
</code></pre></div>
<p>Finally, Yocto/Shape defines a function to create a quad mesh from a heighfield.
Use <code>make_heightfield(...)</code> to create a heightfield meshes.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">heightfield</span> <span class="o">=</span> <span class="n">vctor</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">{...};</span>             <span class="c1">// heightfield data</span>
<span class="k">auto</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">make_heightfield</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">heightfield</span><span class="p">);</span> <span class="c1">// make heightfield mesh</span>
</code></pre></div>
<h2 id="low-level-interface-shape-representation">Low-level interface: Shape representation</h2>
<p>Yocto/Shape also support an interface where single arrays are passed as opposed
to shape structs. This functionality will slowly be phased out and moved to
the higher level interface in future releases. Here we give example of the 
low-level interface.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">{...};</span>   <span class="c1">// triangle indices</span>
<span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>   <span class="c1">// vertex positions</span>
<span class="k">auto</span> <span class="n">texcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">{...};</span>   <span class="c1">// vertex uvs</span>
</code></pre></div>
<p>Face-varying shapes are also supported by specifying separate element indices
for each vertex property, with arrays of vertex properties possibly of different
length. This makes sure that any topology can be represented. For now, only
face-varying quads are supported.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">quadspos</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{...};</span>        <span class="c1">// quads indices for positions</span>
<span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>       <span class="c1">// vertex positions</span>
<span class="k">auto</span> <span class="n">quadstexcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{...};</span>  <span class="c1">// quads indices for uvs</span>
<span class="k">auto</span> <span class="n">texcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">{...};</span>       <span class="c1">// vertex uvs</span>
</code></pre></div>
<h2 id="low-level-interface-vertex-properties">Low-level interface: Vertex properties</h2>
<p>Yocto/Shape provides many facilities to compute vertex properties for indexed
elements. Use <code>triangles_normals(...)</code> and <code>quads_normals(...)</code> to compute
vertex normals for triangle and quad meshes, and <code>line_tangents(...)</code> for
line tangents. Use <code>skin_vertices(...)</code> to apply linear-blend skinning.
Use <code>triangle_tangent_spaces(...)</code> to compute tangents spaces for each ech
meshes.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">{...};</span>   <span class="c1">// triangle indices</span>
<span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>   <span class="c1">// vertex positions</span>
<span class="k">auto</span> <span class="n">texcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">{...};</span>   <span class="c1">// vertex uvs</span>

<span class="k">auto</span> <span class="n">normals</span> <span class="o">=</span> <span class="n">triangle_normals</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span><span class="n">positions</span><span class="p">);</span>   <span class="c1">// vertex normals</span>
<span class="k">auto</span> <span class="n">tangsp</span> <span class="o">=</span> <span class="n">triangle_tangent_spaces</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;</span><span class="p">{...};</span>   <span class="c1">// skinning weights for 4 bones per vertex</span>
<span class="k">auto</span> <span class="n">joints</span>  <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{...};</span>   <span class="c1">// bine indices for 4 bones per vertex</span>
<span class="k">auto</span> <span class="n">frames</span>  <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">frame3f</span><span class="o">&gt;</span><span class="p">{...};</span> <span class="c1">// bone frames</span>
<span class="k">auto</span> <span class="p">[</span><span class="n">skinned_pos</span><span class="p">,</span> <span class="n">skinned_norm</span><span class="p">]</span> <span class="o">=</span> <span class="n">skin_vertices</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span>
   <span class="n">weights</span><span class="p">,</span> <span class="n">joints</span><span class="p">,</span> <span class="n">frames</span><span class="p">);</span>       <span class="c1">// skinned positions ans normals</span>
</code></pre></div>
<h2 id="low-level-interface-flipping-and-aligning">Low-level interface: Flipping and aligning</h2>
<p>Yocto/Shape provides functions to correct shapes that have inconsistent
orientations or normals. Use <code>flip_normals(normals)</code> to flip all mesh normals.
Use <code>flip_triangles(triangles)</code> and <code>flip_quads(quads)</code> to change face
orientations. Use <code>align_vertices(positions,alignment)</code> to align vertex
positions to the main axes.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">{...};</span>   <span class="c1">// triangle indices</span>
<span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>   <span class="c1">// vertex positions</span>
<span class="k">auto</span> <span class="n">normals</span>   <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>   <span class="c1">// vertex normals</span>

<span class="n">triangles</span> <span class="o">=</span> <span class="n">flip_triangles</span><span class="p">(</span><span class="n">triangles</span><span class="p">);</span> <span class="c1">// flip faces</span>
<span class="n">normals</span> <span class="o">=</span> <span class="n">flip_normals</span><span class="p">(</span><span class="n">normals</span><span class="p">);</span>       <span class="c1">// flip normals</span>

<span class="c1">// align positions to the origin along the y axis only</span>
<span class="n">positions</span> <span class="o">=</span> <span class="n">align_vertices</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">});</span>
</code></pre></div>
<h2 id="low-level-interface-edges-and-adjacencies">Low-level interface: Edges and adjacencies</h2>
<p>Use <code>get_edges(triangles)</code> amd <code>get_edges(quads)</code> to get a list of unique edges
for a triangle or quads mesh.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">{...};</span>  <span class="c1">// triangle indices</span>
<span class="k">auto</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">get_edges</span><span class="p">(</span><span class="n">triangles</span><span class="p">);</span>    <span class="c1">// edge indices</span>
</code></pre></div>
<p>Internally, these functions use an <code>edge_map</code>, that is a dictionary that has
pairs of vertex ids as keys and an edge index as value.
Two opposing half-edges have the same representation in an <code>edge_map</code>,
making it useful in tesselation algorithms to avoid cracks.
In Yocto/Shape, edge maps also stores the number of incident faces per edge,
so that we can determine which edges belong to the boundary.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">{...};</span>  <span class="c1">// triangle indices</span>
<span class="k">auto</span> <span class="n">emap</span> <span class="o">=</span> <span class="n">make_edge_map</span><span class="p">(</span><span class="n">triangles</span><span class="p">);</span> <span class="c1">// edge map</span>
<span class="k">auto</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">get_edges</span><span class="p">(</span><span class="n">emap</span><span class="p">);</span>         <span class="c1">// edge indices</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">edge</span> <span class="p">:</span> <span class="n">edges</span><span class="p">)</span>               <span class="c1">// iterate over edges</span>
   <span class="n">print</span><span class="p">(</span><span class="n">edge_index</span><span class="p">(</span><span class="n">emap</span><span class="p">,</span> <span class="n">edge</span><span class="p">));</span>     <span class="c1">// get edge indices</span>
<span class="k">auto</span> <span class="n">boundary</span> <span class="o">=</span> <span class="n">get_boundary</span><span class="p">(</span><span class="n">emap</span><span class="p">);</span>   <span class="c1">// get unsorted boundary edges</span>
</code></pre></div>
<h2 id="low-level-interface-ray-intersection-and-point-overlap">Low-level interface: Ray-intersection and point-overlap</h2>
<p>Yocto/Shape provides ray-scene intersection for points, lines, triangles and
quads accelerated by a BVH data structure. Our BVH is written for
minimal code and not maximum speed, but still gives fast-enough results.
See <a href="../yocto_geometry/">Yocto/Geometry</a> for intersection parametrization,
and <a href="../yocto_bvh/">Yocto/Bvh</a> for a more comprehensive version.</p>
<p>The BVH tree is stored in a <code>shape_bvh</code> struct. The tree stored an array of
nodes and an array of element indices. Each node in the tree has references
to either other nodes or elements. References are represented as indices
in the nodes or elements arrays. Nodes indices refer to the nodes array,
for internal nodes, or the element arrays, for leaf nodes.
The BVH does not store shape data, which is instead passed explicitly
to all calls.</p>
<p>BVH nodes contain their bounds, indices to the BVH arrays of either
primitives or internal nodes, node element type,
and the split axis. Leaf and internal nodes are identical, except that
indices refer to primitives for leaf nodes or other nodes for internal nodes.</p>
<p>The BVH is initialized with <code>make_triangles_bvh(bvh,triangles,positions)</code> for
triangles, <code>make_quads_bvh(bvh,quads,positions)</code> for quads,
<code>make_lines_bvh(bvh,lines,positions,radius)</code> for lines, and
<code>make_points_bvh(bvh,points,positions,radius)</code> for points.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">{...};</span>                 <span class="c1">// mesh data</span>
<span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="k">auto</span> <span class="n">bvh</span> <span class="o">=</span> <span class="n">make_triangles_bvh</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">positions</span><span class="p">);</span> <span class="c1">// BVH construction</span>
</code></pre></div>
<p>Intersect and overlap functions return a <code>bvh_intersection</code> that bundles
the intersection distance, the intersected element index and uvs,
and a <code>hit</code> flag that signals whether an element was hit.</p>
<p><code>intersect_&lt;element&gt;_bvh(...)</code> computed intersections between rays and shapes.
Use <code>intersect_triangles_bvh(bvh,triangles,positions, ray)</code> for
triangles, <code>intersect_quads_bvh(bvh,quads,positions)</code> for quads,
<code>intersect_lines_bvh(bvh,lines,positions,radius,ray)</code> for lines, and
<code>intersect_points_bvh(bvh,points,positions,radius,ray)</code> for points.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">ray</span> <span class="o">=</span> <span class="n">ray3f</span><span class="p">{...};</span>
<span class="c1">// computes ray-triangles intersection</span>
<span class="k">auto</span> <span class="n">isec</span> <span class="o">=</span> <span class="n">intersect_triangles_bvh</span><span class="p">(</span><span class="n">bvh</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">ray</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">isec</span><span class="p">.</span><span class="n">hit</span><span class="p">)</span> <span class="n">print_info</span><span class="p">(</span><span class="n">isec</span><span class="p">.</span><span class="n">element</span><span class="p">,</span> <span class="n">isec</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">isec</span><span class="p">.</span><span class="n">distance</span><span class="p">);</span>
<span class="k">else</span> <span class="nf">print_info</span><span class="p">(</span><span class="s">&quot;no hit&quot;</span><span class="p">);</span>
</code></pre></div>
<p><code>overlap_&lt;element&gt;_bvh(...)</code> checks whether a shape overlaps a point within a
given maximum distance and returns the distance, element and uv of the
closest element.
Use <code>overlap_triangles_bvh(bvh, triangles, positions, ray)</code> for
triangles, <code>overlap_quads_bvh(bvh, quads, positions)</code> for quads,
<code>overlap_lines_bvh(bvh, lines, positions, radius, ray)</code> for lines, and
<code>overlap_points_bvh(bvh, points, positions, radius, ray)</code> for points.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">pt</span> <span class="o">=</span> <span class="n">vec3f</span><span class="p">{...};</span> <span class="k">auto</span> <span class="n">max_dist</span> <span class="o">=</span> <span class="kt">float</span><span class="p">{...};</span>
<span class="c1">// comnpute point-triangles overlap</span>
<span class="k">auto</span> <span class="n">ovr</span> <span class="o">=</span> <span class="n">overlap_triangles_bvh</span><span class="p">(</span><span class="n">bvh</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">mat_dist</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">ovr</span><span class="p">.</span><span class="n">hit</span><span class="p">)</span> <span class="n">print_info</span><span class="p">(</span><span class="n">ovrl</span><span class="p">.</span><span class="n">element</span><span class="p">,</span> <span class="n">ovrl</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">ovrl</span><span class="p">.</span><span class="n">distance</span><span class="p">);</span>
<span class="k">else</span> <span class="nf">print_info</span><span class="p">(</span><span class="s">&quot;no overlap&quot;</span><span class="p">);</span>
</code></pre></div>
<p>If vertices have moved little, BVHs can be updated instead of fully rebuild.
Use <code>update_triangles_bvh(bvh, triangles, positions)</code> for
triangles, <code>update_quads_bvh(bvh, quads, positions)</code> for quads,
<code>update_lines_bvh(bvh, lines, positions, radius)</code> for lines, and
<code>update_points_bvh(bvh, points, positions, radius)</code> for points.</p>
<div class="highlight"><pre><span></span><code><span class="n">positions</span><span class="p">[...]</span> <span class="o">=</span> <span class="p">{...};</span>                           <span class="c1">// update positions</span>
<span class="n">update_triangles_bvh</span><span class="p">(</span><span class="n">bvh</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">positions</span><span class="p">);</span>  <span class="c1">// update BVH</span>
</code></pre></div>
<h2 id="low-level-interface-nearest-neighbors">Low-level interface: Nearest neighbors</h2>
<p>Nearest neighbors queries are computed by building a sparse hash grid
defined as <code>hash_grid</code>. The grid is created by specifying a cell size for the
underlying volumetric grid. Each cell stores the list of point indices that
are present in that cell. To save memory, the grid is represented sparsely,
using a dictionary, so that only cells with at least one vertex are defined.</p>
<p>Initialize a hash grid with <code>make_hash_grid(positions, size)</code>.
Use <code>find_neighbors(grid, neighbors, position, max_radius)</code> to find
nearest neighbors.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>               <span class="c1">// point positions</span>
<span class="k">auto</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">make_hash_grid</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">cell_size</span><span class="p">);</span>  <span class="c1">// create hash grid</span>
<span class="k">auto</span> <span class="n">pt</span> <span class="o">=</span> <span class="n">vec3f</span><span class="p">{...};</span> <span class="k">auto</span> <span class="n">max_dist</span> <span class="o">=</span> <span class="kt">float</span><span class="p">{...};</span>  <span class="c1">// query point and dist</span>
<span class="k">auto</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{};</span>                    <span class="c1">// neighbor buffer</span>
<span class="n">find_neighbors</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">max_dist</span><span class="p">);</span>     <span class="c1">// find neighbors by pos</span>
<span class="n">find_neighbors</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">max_dist</span><span class="p">);</span>     <span class="c1">// find neighbors by id</span>
</code></pre></div>
<h2 id="low-level-interface-element-conversions-and-grouping">Low-level interface: Element conversions and grouping</h2>
<p>Yocto/Shape support conversion between shape elements.
Use <code>quads_to_triangles(quads)</code> to convert quads to triangles and
<code>triangles_to_quads(triangles)</code> to convert triangles to degenerate quads.
Use <code>bezier_to_lines(lines)</code> to convert Bzier segments to lines using three
lines for each Bzier segment.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">quads</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="k">auto</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">quads_to_triangles</span><span class="p">(</span><span class="n">quads</span><span class="p">);</span>  <span class="c1">// convert quads to triangles</span>
</code></pre></div>
<p>Face-varying meshes are stored by having different face indices for each
vertex propeerty. This way, every vertex property has its own topology.
Use <code>split_facevarying(...)</code> to convert to an indexed mesh. During conversion
vertices may be duplicated since the same topology is used for all vertex
properties.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">fvquadspos</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{...};</span>      <span class="c1">// face-varying indices</span>
<span class="k">auto</span> <span class="n">fvquadsnorm</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{...};</span>     <span class="c1">// arrays have some length</span>
<span class="k">auto</span> <span class="n">fvquadstexcoord</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="k">auto</span> <span class="n">fvpositions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>     <span class="c1">// face-varying vertices</span>
<span class="k">auto</span> <span class="n">fvnormals</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>       <span class="c1">// arrays may have different lengths</span>
<span class="k">auto</span> <span class="n">fvtexcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="k">auto</span> <span class="p">[</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">]</span> <span class="o">=</span> <span class="c1">// convert to indexed mesh</span>
   <span class="n">split_facevarying</span><span class="p">(</span><span class="n">fvquadspos</span><span class="p">,</span> <span class="n">fvquadsnorm</span><span class="p">,</span> <span class="n">fvquadstexcoord</span><span class="p">,</span>
   <span class="n">fvpositions</span><span class="p">,</span> <span class="n">fvnormals</span><span class="p">,</span> <span class="n">fvtexcoords</span><span class="p">);</span>
</code></pre></div>
<p>Yocto/Shape supports eliminating duplicate vertices in triangle and quad meshes.
All vertices within a threshold are merged in a greedy fashion, which works well
when duplicated vertices are near other while other vertices are further away.
Use <code>weld_triangles(triangles, positions, threshold)</code> to eliminate duplicated
triangle vertices and <code>weld_quads(quads, positions, threshold)</code> to eliminate
duplicated quad vertices. For lower-level algorithms, use
<code>weld_vertices(positions, threshold)</code> to group vertices together.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">{...};</span>  <span class="c1">// mesh data</span>
<span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="k">auto</span> <span class="n">tolerance</span> <span class="o">=</span> <span class="mf">0.1f</span><span class="p">;</span>
<span class="k">auto</span> <span class="p">[</span><span class="n">mtriangles</span><span class="p">,</span> <span class="n">mpositions</span><span class="p">]</span> <span class="o">=</span>       <span class="c1">// remove duplicates</span>
   <span class="n">weld_triangles</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">);</span>
</code></pre></div>
<p>Yocto/Shape supports splitting shapes that are tagged by ids. This is helpful
for example when drawing meshes that have per-face materials using renders
that do support one material per shape only. Use <code>ungroup_lines(lines,ids)</code>,
<code>ungroud_triangles(triangles,ids)</code> and <code>ungroup_quads(quads,ids)</code> for lines,
triangles and quads respectively.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">{...};</span>  <span class="c1">// tagged mesh with one id per face</span>
<span class="k">auto</span> <span class="n">ids</span>       <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="k">auto</span> <span class="n">split</span> <span class="o">=</span> <span class="n">ungroup_triangles</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">ids</span><span class="p">);</span> <span class="c1">// returns list of meshes</span>
</code></pre></div>
<p>Yocto/Shape supports merging shape elements. This is useful, for example, when
building up shapes from parts. The merged shapes are just concatenation of
the individual shape without vertex merging. Use <code>merge_lines(...)</code> for lines,
<code>merge_triangles(...)</code> for triangles and <code>merge_quads(...)</code> for quads.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">{...};</span>   <span class="c1">// initial shape</span>
<span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="k">auto</span> <span class="n">normals</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="k">auto</span> <span class="n">texcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="k">auto</span> <span class="n">mtriangles</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">{...};</span>   <span class="c1">// shape to be merged</span>
<span class="k">auto</span> <span class="n">mpositions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="k">auto</span> <span class="n">mnormals</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="k">auto</span> <span class="n">mtexcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="c1">// merge mtriangles into triangles in-placee</span>
<span class="n">merge_triangles</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span>
  <span class="n">mtriangles</span><span class="p">,</span> <span class="n">mpositions</span><span class="p">,</span> <span class="n">mnormals</span><span class="p">,</span> <span class="n">mtexcoords</span><span class="p">);</span>
</code></pre></div>
<p>You can also merge triangles and quads together in other to have one
primitive only. Use <code>merge_triangles_and_quads(triangles, quads, force_triangles)</code>
to merge elements in-place. The algorithms will output quads if present or
triangles if not unless <code>force_triangles</code> is used.</p>
<h2 id="low-level-interface-shape-subdivision">Low-level interface: Shape subdivision</h2>
<p>Yocto/Shape defines functions to subdivide shape elements linearly, in
order to obtain higher shape resolution, for example before applying
displacement mapping. All functions will split all shape elements,
regardless of their size. This ensures that meshes have no cracks.
Use <code>subdivide_lines(lines, vert)</code> for lines,
<code>subdivide_triangles(triangles, vert)</code> for triangles,
<code>subdivide_quads(quads, vert)</code> for quads, and
<code>subdivide_bezier(beziers, vert)</code> for Bezier segments.
Alternatively, shape elemens can be subdivideede multiple times, 
as a convenience, with <code>subdivide_lines(lines, vert, level)</code> for lines,
<code>subdivide_triangles(triangles, vert, level)</code> for triangles,
<code>subdivide_quads(quads, vert, level)</code> for quads, and
<code>subdivide_bezier(beziers, vert, level)</code> for Bezier segments.
In this subdivision, each line is split in two lines,
each triangle in three triangles,
each quad in four quads, and each Bezier segment in two segments.
The functions apply the subdivision rules <code>level</code> number of times
and act on a single vertex property at a time for maximum flexibility.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">{...};</span>   <span class="c1">// initial shape</span>
<span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="c1">// subdivide the triangle mesh recursively two times</span>
<span class="k">auto</span> <span class="p">[</span><span class="n">striangles</span><span class="p">,</span> <span class="n">spositions</span><span class="p">]</span> <span class="o">=</span> <span class="n">subdivide_triangles</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</code></pre></div>
<p>Yocto/Shape also supports Catmull-Clark subdivision surfaces with
<code>subdivide_catmullclark(quads, vert, level, creased)</code>. In this case,
Catmull-Clark subdivision rules are used to smooth the mesh after
linear subdivision. The boundary can be treated as creases with <code>creased</code>,
which is necessary when subdividing texture coordinates.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">quads</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{...};</span>     <span class="c1">// initial shape</span>
<span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="c1">// subdivide the quad mesh recursively two times</span>
<span class="k">auto</span> <span class="p">[</span><span class="n">squads</span><span class="p">,</span> <span class="n">spositions</span><span class="p">]</span> <span class="o">=</span> <span class="n">subdivide_catmullclark</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">tquads</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{...};</span>    <span class="c1">// face-varying shape with texture coords</span>
<span class="k">auto</span> <span class="n">texcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="c1">// subdivide the triangle mesh recursively two times</span>
<span class="k">auto</span> <span class="p">[</span><span class="n">stquads</span><span class="p">,</span> <span class="n">stexcoords</span><span class="p">]</span> <span class="o">=</span> <span class="n">subdivide_catmullclark</span><span class="p">(</span><span class="n">tquads</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>
<h2 id="low-level-interface-shape-sampling">Low-level interface: Shape sampling</h2>
<p>Yocto/Shape supports sampling meshes uniformly. All sampling require to first
compute the shape CDF and then use it to sample the shape. For each shape type,
the sampling functions return the shape element id and the element barycentric
coordinates. Use <code>sample_lines(cdf, re, rn)</code> to sample lines,
<code>sample_triangles(cdf, re, rn)</code> to sample triangles,
<code>sample_quads(cdf, re, rn)</code> to sample quads. The shape CDFs are computed using
<code>sample_lines_dcf(lines, positions)</code>,
<code>sample_triangles_dcf(triangles, positions)</code>,
and <code>sample_quads_dcf(quads, positions)</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">{...};</span>   <span class="c1">// initial shape</span>
<span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="k">auto</span> <span class="n">cdf</span> <span class="o">=</span> <span class="n">sample_triangles_cdf</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">positions</span><span class="p">);</span> <span class="c1">// shape cdf</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">sample</span> <span class="p">:</span> <span class="n">range</span><span class="p">(</span><span class="n">samples</span><span class="p">))</span> <span class="p">{</span>
   <span class="c1">// sample the shape returning element id and uvs</span>
   <span class="k">auto</span> <span class="p">[</span><span class="n">triangle_id</span><span class="p">,</span> <span class="n">uv</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_triangles</span><span class="p">(</span><span class="n">cdf</span><span class="p">,</span> <span class="n">rand1f</span><span class="p">(</span><span class="n">rng</span><span class="p">),</span> <span class="n">rand2f</span><span class="p">(</span><span class="n">rng</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p>For triangles and quads, Yocto/Shape defines convenience functions that
generate a set of points on the shape surface. Use <code>sample_triangles(...)</code>
and <code>sample_quads(...)</code> for triangles and quads respectively.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">{...};</span>   <span class="c1">// initial shape</span>
<span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="k">auto</span> <span class="n">normals</span>   <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="k">auto</span> <span class="n">texcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="k">auto</span> <span class="n">sampled_positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span> <span class="c1">// sampled points</span>
<span class="k">auto</span> <span class="n">sampled_normals</span>   <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="k">auto</span> <span class="n">sampled_texcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">{...};</span>
<span class="c1">// sample a set of npoints on the mesh</span>
<span class="k">auto</span> <span class="n">npoints</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">sample_triangles</span><span class="p">(</span><span class="n">sampled_positions</span><span class="p">,</span> <span class="n">sampled_normals</span><span class="p">,</span> <span class="n">sampled_texcoords</span><span class="p">,</span>
                 <span class="n">triangles</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="n">npoints</span><span class="p">);</span>
</code></pre></div>
<h2 id="low-level-interface-procedural-shapes">Low-level interface: Procedural shapes</h2>
<p>Yocto/Shape defines several procedural shapes used for both testing and
to quickly create shapes for procedural scenes. Procedural shapes take as
input the desired shape resolution, the shape scale, the uv scale, and
additional parameters specific to that procedural shape. These functions
return quads indices and vertex positions, normals and texture coordinates,
with arrays passed in.
Use <code>make_rect(...)</code> for a rectangle in the XY plane,
<code>make_bulged_rect(...)</code> for a bulged rectangle,
<code>make_recty(...)</code> for a rectangle in the XZ plane,
<code>make_bulged_recty(...)</code> for a bulged rectangle in the XZ plane,
<code>make_box(...)</code> for a box,
<code>make_rounded_box(...)</code> for a rounded box,
<code>make_floor(...)</code> for a floor in the XZ plane,
<code>make_bent_floor(...)</code> for a bent floor,
<code>make_sphere(...)</code> for a sphere obtained from a cube,
<code>make_uvsphere(...)</code> for a sphere tessellated along its uvs,
<code>make_capped_uvsphere(...)</code> for a sphere with flipped caps,
<code>make_disk(...)</code> for a disk obtained from a quad,
<code>make_bulged_disk(...)</code> for a bulged disk,
<code>make_uvdisk(...)</code> for a disk tessellated along its uvs,
<code>make_uvcylinder(...)</code> for a cylinder tessellated along its uvs,
<code>make_rounded_uvcylinder(...)</code> for a rounded cylinder.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// most procedural shapes return quads, positions, normals, and texcoords</span>
<span class="k">auto</span> <span class="n">quads</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">normals</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">texcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="c1">// make shapes with 32 steps in resolution and scale of 1</span>
<span class="n">make_rect</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="n">make_bulged_rect</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="n">make_recty</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="n">make_box</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="n">make_rounded_box</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="n">make_floor</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">});</span>
<span class="n">make_bent_floor</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">});</span>
<span class="n">make_sphere</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">make_uvsphere</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">make_capped_uvsphere</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">make_disk</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">make_bulged_disk</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">make_uvdiskm</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">make_uvcylinder</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="n">make_rounded_uvcylinder</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
</code></pre></div>
<p>Yocto/Shape defines a few procedural face-varying shapes with similar interfaces
to the above functions. In this case, the functions return face indices and
vertex data for positions, normals and texture coordinates packed in a
<code>quads_fvshape</code> struct.
Use <code>make_fvrect(...)</code> for a rectangle in the XY plane,
<code>make_fvbox(...)</code> for a box,
<code>make_fvsphere(...)</code> for a sphere obtained from a cube.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// procedural face-varying shapes return positions, normals, and texcoords</span>
<span class="k">auto</span> <span class="n">quadspos</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">quadsnorm</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">quadstexcoord</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">normals</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">texcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="c1">// make face-varying shapes with 32 steps in resolution and scale of 1</span>
<span class="n">make_fvrect</span><span class="p">(</span><span class="n">quadspos</span><span class="p">,</span> <span class="n">quadsnorm</span><span class="p">,</span> <span class="n">quadstexcoord</span><span class="p">,</span>
            <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="n">make_fvbox</span><span class="p">(</span><span class="n">quadspos</span><span class="p">,</span> <span class="n">quadsnorm</span><span class="p">,</span> <span class="n">quadstexcoord</span><span class="p">,</span>
           <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="n">make_fvsphere</span><span class="p">(</span><span class="n">quadspos</span><span class="p">,</span> <span class="n">quadsnorm</span><span class="p">,</span> <span class="n">quadstexcoord</span><span class="p">,</span>
              <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>Yocto/Shape provides functions to create predefined shapes helpful in testing.
These functions take only a scale and often provide only the positions as
vertex data. These functions return either triangles, quads, or
face-varying quads.
Use <code>make_monkey(...)</code> for the Blender monkey as quads and positions only,
<code>make_quad(...)</code> for a simple quad,
<code>make_quady(...)</code> for a simple quad in the XZ plane,
<code>make_cube(...)</code> for a simple cube as quads and positions only,
<code>make_fvcube(...)</code> for a simple face-varying unit cube,
<code>make_geosphere(...)</code> for a geodesic sphere as triangles and positions only.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// built-in shapes return elemeents, positions, normals, and texcoords</span>
<span class="k">auto</span> <span class="n">quads</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">quadspos</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">quadsnorm</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">quadstexcoord</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">normals</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">texcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="c1">// make built-in shapes with scale of 1</span>
<span class="n">make_monkey</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">make_quad</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">make_quady</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">make_cube</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">make_geosphere</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">make_fvcube</span><span class="p">(</span><span class="n">quadspos</span><span class="p">,</span> <span class="n">quadsnorm</span><span class="p">,</span> <span class="n">quadstexcoord</span><span class="p">,</span>
              <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>Yocto/Shape supports the generation of points and lines sets.
Use <code>make_lines(...)</code> to create a line set in the XY plane,
<code>make_points(...)</code> for a collection of points at the origin,
adn <code>make_random_points(...)</code> for a point set randomly placed in a box.
These functions return shapes that are defined in terms of lines or points
and return lines or points indices, and vertex positions,
normals, texture coordinates and radia, packed in a <code>lines_shape</code>
or <code>points_shape</code> struct.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// procedural lines return lines, positions, normals, texcoords, radia</span>
<span class="k">auto</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">normals</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">texcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="n">make_lines</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span>
           <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">65536</span><span class="p">},</span>      <span class="c1">// line steps and number of lines</span>
           <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>  <span class="c1">// line set scale and uvscale</span>
           <span class="p">{</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">});</span> <span class="c1">// radius at the bottom and top</span>
<span class="c1">// procedural points return points, positions, normals, texcoords, radia</span>
<span class="n">make_points</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span>
            <span class="mi">65536</span><span class="p">,</span>        <span class="c1">// number of points</span>
            <span class="mi">1</span><span class="p">,</span>            <span class="c1">// uvscale</span>
            <span class="mf">0.001</span><span class="p">);</span>       <span class="c1">// point radius</span>
<span class="n">make_random_points</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span>
            <span class="mi">65536</span><span class="p">,</span> <span class="c1">// number of points</span>
            <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// line set scale and uvscale</span>
            <span class="mf">0.001</span><span class="p">);</span>       <span class="c1">// point radius</span>
</code></pre></div>
<p>Yocto/Shape also defines a simple function to generate randomized hairs
on a triangle or quad mesh. Use <code>make_hair(...)</code> to create a hair shape
from a triangle and quad mesh, and return a line set.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Make a hair ball around a shape</span>
<span class="k">auto</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">normals</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">texcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="n">make_hair</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span>
  <span class="n">surface_triangles</span><span class="p">,</span> <span class="n">surface_quads</span><span class="p">,</span> <span class="c1">// sampled surface</span>
  <span class="n">surface_positions</span><span class="p">,</span> <span class="n">surface_normals</span><span class="p">,</span> <span class="n">surface_texcoords</span>
  <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">65536</span><span class="p">},</span>     <span class="c1">// steps: line steps and number of lines</span>
  <span class="p">{</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">},</span>     <span class="c1">// length: minimum and maximum length</span>
  <span class="p">{</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">},</span> <span class="c1">// radius: minimum and maximum radius from base to tip</span>
  <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span>        <span class="c1">// noise: noise added to hair (strength/scale)</span>
  <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">},</span>       <span class="c1">// clump: clump added to hair (strength/number)</span>
  <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">});</span>        <span class="c1">// rotation: rotation added to hair (angle/strength)</span>
</code></pre></div>
<p>Finally, Yocto/Shape defines a function to create a quad mesh from a heighfield.
Use <code>make_heightfield(...)</code> to create a heightfield meshes.</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span> <span class="n">quads</span>     <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">{};</span>   <span class="c1">// shape element buffer</span>
<span class="k">auto</span> <span class="n">positions</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{};</span>   <span class="c1">// vertex data buffers</span>
<span class="k">auto</span> <span class="n">normals</span>   <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">texcoords</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">size</span>      <span class="o">=</span> <span class="n">vec2i</span><span class="p">{</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">};</span>   <span class="c1">// heightfield size</span>
<span class="k">auto</span> <span class="n">heightfield</span> <span class="o">=</span> <span class="n">vctor</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">{...};</span>  <span class="c1">// heightfield data</span>
<span class="n">make_heightfield</span><span class="p">(</span><span class="n">quads</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span>
   <span class="n">size</span><span class="p">,</span> <span class="n">heightfield</span><span class="p">);</span>               <span class="c1">// make heightfield mesh</span>
</code></pre></div>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        <a href="../yocto_image/" class="md-footer__link md-footer__link--prev" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Image utilities
            </div>
          </div>
        </a>
      
      
        <a href="../yocto_mesh/" class="md-footer__link md-footer__link--next" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              Mesh processing
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2016 - 2020 Fabio Pellacini
          </div>
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.instant"], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}, "search": "../../assets/javascripts/workers/search.fb4a9340.min.js", "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.5cf3e710.min.js"></script>
      
    
  </body>
</html>