
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <title>Yocto/GL</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
      <link rel="stylesheet" href="style.css">
    </head>
    <body>
    <header>
        <!-- a href="index.html">about</a -->
        <!-- a href="yocto_gl.html">api</a -->
        <!-- a href="https://github.com/xelatihy/yocto-gl">github</a -->
        <p><a href="index.html">Yocto/GL</a> <a href="https://github.com/xelatihy/yocto-gl"><img alt="" src="images/github-logo.png"></a> + <a href="https://twitter.com/intent/tweet?text=Check%20out&amp;url=https%3A%2F%2Fgoo.gl%2FYvQvBr&amp;hashtags=yocto-gl&amp;via=xelatihy"><img alt="" src="images/twitter-logo.png"></a></p>
<ul>
<li><a href="#toc0">About</a></li>
<li><a href="#toc1">Usage</a></li>
<li><a href="#toc2">History</a></li>
<li><a href="#toc3">API Documentation</a></li>
<li><a href="yocto_gl.html#api">API Documentation</a></li>
</ul>
    </header>
    <article>
    <p><a id="toc0"></a></p>
<h1>Yocto/glTF: High-level glTF support for Yocto/GL</h1>
<p>Extension of Yocto/GL that provides a complete high-level interface for
Khronos glTF format. Uses the low-level parser from Yocto/GL.
The high-level interface that is more useful if an aplication needs direct
access to shapes, textures and animations and does not want to deal with
all the intricacies of the format.</p>
<p>Known limitations are: (1) skinning matrices are always in world space
(waiting for the spec to be updated); (2) spline based animation is not
fully implemented yet (waiting for official demo models).</p>
<p>This library depends on <code>yocto_gl.h</code> and its dependencies.</p>
<p><a id="toc1"></a></p>
<h2>Usage</h2>
<ol>
<li>load a group of scens with <code>load_scenes()</code></li>
<li>look at the <code>scene</code> data structures for access to individual elements</li>
<li>to support animation, use <code>update_animated_transforms()</code></li>
<li>to support skinning, use <code>get_skin_transforms()</code></li>
<li>for morphing, use <code>compute_morphing_deformation()</code></li>
<li>can also manipulate the scene by adding missing data with <code>add_XXX()</code>
   functions</li>
<li>for rendering scenes, use <code>get_scene_cameras()</code> and
   <code>get_scene_instances()</code> that avoid the need for explicirtly walking
   the glTF node hierarchy</li>
<li>use <code>save_scenes()</code> to write the data to disk</li>
<li>use <code>convert_to_specgloss()</code> to convert materials to spec-gloss</li>
</ol>
<p><a id="toc2"></a></p>
<h2>History</h2>
<ul>
<li>v 0.1.0: initial release after refactoring</li>
</ul>
<p><a id="api"></a></p>
<p><a id="toc3"></a></p>
<h2>API Documentation</h2>
<h4>Struct gltf_camera</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gltf_camera</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">ortho</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">aspect</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">yfov</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">std</span><span class="o">::</span><span class="n">atan</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">near</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">far</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">focus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">aperture</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Camera</p>
<ul>
<li>Members:<ul>
<li>name:      name</li>
<li>ortho:      orthographic</li>
<li>aspect:      aspect ratio</li>
<li>yfov:      vertical fov (perspective) or size (orthographic)</li>
<li>near:      near plane (0 for default)</li>
<li>far:      far plane (0 for default)</li>
<li>focus:      focus distance (extension not implemented yet)</li>
<li>aperture:      lens aperture (extension not implemented yet)</li>
</ul>
</li>
</ul>
<h4>Struct gltf_texture</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gltf_texture</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">image4b</span> <span class="n">ldr</span><span class="p">;</span>
    <span class="n">image4f</span> <span class="n">hdr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="nf">width</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="nf">height</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>Texture</p>
<ul>
<li>Members:<ul>
<li>name:      name</li>
<li>path:      path</li>
<li>ldr:      8-bit data</li>
<li>hdr:      float data</li>
<li>width():      get texture width</li>
<li>height():      get texture height</li>
</ul>
</li>
</ul>
<h4>Enum gltf_texture_wrap</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">gltf_texture_wrap</span> <span class="p">{</span>
    <span class="n">repeat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">clamp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">mirror</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Texture wrap mode</p>
<ul>
<li>Values:<ul>
<li>repeat:      repeat</li>
<li>clamp:      clamp</li>
<li>mirror:      mirror</li>
</ul>
</li>
</ul>
<h4>Enum gltf_texture_filter</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">gltf_texture_filter</span> <span class="p">{</span>
    <span class="n">linear</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">nearest</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">linear_mipmap_linear</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">nearest_mipmap_nearest</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">linear_mipmap_nearest</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">nearest_mipmap_linear</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Texture filter mode</p>
<ul>
<li>Values:<ul>
<li>linear:      linear</li>
<li>nearest:      nearest</li>
<li>linear_mipmap_linear:      linear mipmap linear</li>
<li>nearest_mipmap_nearest:      nearest mipmap nearest</li>
<li>linear_mipmap_nearest:      linear mipmap nearest</li>
<li>nearest_mipmap_linear:      nearest mipmap linear</li>
</ul>
</li>
</ul>
<h4>Struct gltf_texture_info</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gltf_texture_info</span> <span class="p">{</span>
    <span class="n">gltf_texture_wrap</span> <span class="n">wrap_s</span> <span class="o">=</span> <span class="n">gltf_texture_wrap</span><span class="o">::</span><span class="n">repeat</span><span class="p">;</span>
    <span class="n">gltf_texture_wrap</span> <span class="n">wrap_t</span> <span class="o">=</span> <span class="n">gltf_texture_wrap</span><span class="o">::</span><span class="n">repeat</span><span class="p">;</span>
    <span class="n">gltf_texture_filter</span> <span class="n">filter_mag</span> <span class="o">=</span> <span class="n">gltf_texture_filter</span><span class="o">::</span><span class="n">linear</span><span class="p">;</span>
    <span class="n">gltf_texture_filter</span> <span class="n">filter_min</span> <span class="o">=</span> <span class="n">gltf_texture_filter</span><span class="o">::</span><span class="n">linear_mipmap_linear</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="nf">is_default</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>Texture information</p>
<ul>
<li>Members:<ul>
<li>wrap_s:      wrap mode for s coordinate</li>
<li>wrap_t:      wrap mdoe for t coordinate</li>
<li>filter_mag:      filter mode</li>
<li>filter_min:      filter mode</li>
<li>scale:      texture strength (occlusion and normal)</li>
<li>is_default():      check if it is default</li>
</ul>
</li>
</ul>
<h4>Struct gltf_material_metallic_roughness</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gltf_material_metallic_roughness</span> <span class="p">{</span>
    <span class="n">vec3f</span> <span class="n">base</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">opacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">metallic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">roughness</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">gltf_texture</span><span class="o">*</span> <span class="n">base_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">gltf_texture</span><span class="o">*</span> <span class="n">metallic_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">gltf_texture_info</span><span class="o">*</span> <span class="n">base_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">gltf_texture_info</span><span class="o">*</span> <span class="n">metallic_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">gltf_material_metallic_roughness</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Material PBR metallic roughness</p>
<ul>
<li>Members:<ul>
<li>base:      base color</li>
<li>opacity:      opacity</li>
<li>metallic:      metallic factor</li>
<li>roughness:      metallic roughness</li>
<li>base_txt:      base texture (kb.x, kb.y, kb.z, op)</li>
<li>metallic_txt:      metallic-roughness texture (n/a, roughness, metallic, n/a)</li>
<li>base_txt_info:      texture information for base_txt</li>
<li>metallic_txt_info:      texture information for metallic_txt</li>
<li>~gltf_material_metallic_roughness():      cleanup</li>
</ul>
</li>
</ul>
<h4>Struct gltf_material_specular_glossiness</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gltf_material_specular_glossiness</span> <span class="p">{</span>
    <span class="n">vec3f</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">opacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">specular</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">glossiness</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">gltf_texture</span><span class="o">*</span> <span class="n">diffuse_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">gltf_texture</span><span class="o">*</span> <span class="n">specular_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">gltf_texture_info</span><span class="o">*</span> <span class="n">diffuse_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">gltf_texture_info</span><span class="o">*</span> <span class="n">specular_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">gltf_material_specular_glossiness</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Material PBR specular glossiness</p>
<ul>
<li>Members:<ul>
<li>diffuse:      diffuse color and opacity</li>
<li>opacity:      opacity</li>
<li>specular:      specular color (spec.x, spec.y, spec.z, opacity)</li>
<li>glossiness:      specular glossiness</li>
<li>diffuse_txt:      diffuse texture (diff.x, diff.y, diff.z, opacity)</li>
<li>specular_txt:      specular-glossiness texture (spec.x, spec.y, spec.z, gloss)</li>
<li>diffuse_txt_info:      texture information for base_txt</li>
<li>specular_txt_info:      texture information for metallic_txt</li>
<li>~gltf_material_specular_glossiness():      cleanup</li>
</ul>
</li>
</ul>
<h4>Struct gltf_material</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gltf_material</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">emission</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">gltf_texture</span><span class="o">*</span> <span class="n">emission_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">gltf_texture_info</span><span class="o">*</span> <span class="n">emission_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">gltf_material_metallic_roughness</span><span class="o">*</span> <span class="n">metallic_roughness</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">gltf_material_specular_glossiness</span><span class="o">*</span> <span class="n">specular_glossiness</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">gltf_texture</span><span class="o">*</span> <span class="n">occlusion_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">gltf_texture</span><span class="o">*</span> <span class="n">normal_txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">gltf_texture_info</span><span class="o">*</span> <span class="n">occlusion_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">gltf_texture_info</span><span class="o">*</span> <span class="n">normal_txt_info</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">double_sided</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="o">~</span><span class="n">gltf_material</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Material</p>
<p>glTF 2.0 has two physically-based aterial models: pbrMetallicRoughness
and pbrSpecularGlossiness, the latter as an extension. Here we support both
by including which one is defined. While it would have been more appropriate
to convert them, this requires a rewrite of texture data which w prefer to
avoid.</p>
<ul>
<li>Members:<ul>
<li>name:      name</li>
<li>emission:      emission color</li>
<li>emission_txt:      emissive texture reference</li>
<li>emission_txt_info:      texture information for normal_txt</li>
<li>metallic_roughness:      metallic roughnesss</li>
<li>specular_glossiness:      specular glossiness</li>
<li>occlusion_txt:      occlusion texture</li>
<li>normal_txt:      normal texture</li>
<li>occlusion_txt_info:      texture information for collusion_txt</li>
<li>normal_txt_info:      texture information for normal_txt</li>
<li>double_sided:      double sided</li>
<li>~gltf_material():      cleanup</li>
</ul>
</li>
</ul>
<h4>Struct gltf_shape_morph</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gltf_shape_morph</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">norm</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">tangsp</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">weight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Morph information for shapes</p>
<ul>
<li>Members:<ul>
<li>pos:      morph position</li>
<li>norm:      morph normal</li>
<li>tangsp:      morph tangent</li>
<li>weight:      default weight (the same for each shape in a mesh)</li>
</ul>
</li>
</ul>
<h4>Struct gltf_shape</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gltf_shape</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">gltf_material</span><span class="o">*</span> <span class="n">mat</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">norm</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span> <span class="n">texcoord</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span> <span class="n">texcoord1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;</span> <span class="n">color</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">radius</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;</span> <span class="n">tangsp</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;</span> <span class="n">skin_weights</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span> <span class="n">skin_joints</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;</span> <span class="n">lines</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span> <span class="n">triangles</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gltf_shape_morph</span><span class="o">*&gt;</span> <span class="n">morph_targets</span><span class="p">;</span>
    <span class="o">~</span><span class="n">gltf_shape</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Primitives</p>
<ul>
<li>Members:<ul>
<li>name:      name of the mesh that enclosed it</li>
<li>mat:      material reference</li>
<li>pos:      vertex position</li>
<li>norm:      vertex normal</li>
<li>texcoord:      vertex texcoord</li>
<li>texcoord1:      vertex additional texcoord</li>
<li>color:      vertex color</li>
<li>radius:      vertex radius</li>
<li>tangsp:      vertex tangent space</li>
<li>skin_weights:      vertex skinning weights</li>
<li>skin_joints:      vertex skinning joint indices</li>
<li>points:      point elements</li>
<li>lines:      line elements</li>
<li>triangles:      triangle elements</li>
<li>morph_targets:      morph targets</li>
<li>~gltf_shape():      cleanup</li>
</ul>
</li>
</ul>
<h4>Struct gltf_mesh</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gltf_mesh</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gltf_shape</span><span class="o">*&gt;</span> <span class="n">shapes</span><span class="p">;</span>
    <span class="o">~</span><span class="n">gltf_mesh</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Gltf mesh.</p>
<ul>
<li>Members:<ul>
<li>name:      name</li>
<li>path:      path (only used when writing files on disk with glTF)</li>
<li>shapes:      primitives references</li>
<li>~gltf_mesh():      cleanup</li>
</ul>
</li>
</ul>
<h4>Struct gltf_node</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gltf_node</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">gltf_camera</span><span class="o">*</span> <span class="n">cam</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">gltf_mesh</span><span class="o">*</span> <span class="n">msh</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">gltf_skin</span><span class="o">*</span> <span class="n">skn</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gltf_node</span><span class="o">*&gt;</span> <span class="n">children</span><span class="p">;</span>
    <span class="n">mat4f</span> <span class="n">matrix</span> <span class="o">=</span> <span class="n">identity_mat4f</span><span class="p">;</span>
    <span class="n">quat4f</span> <span class="n">rotation</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">scale</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">translation</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">morph_weights</span><span class="p">;</span>
    <span class="n">gltf_node</span><span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">mat4f</span> <span class="nf">xform</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">mat4f</span> <span class="nf">local_xform</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">mat4f</span> <span class="nf">skin_xform</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">mat4f</span> <span class="n">_xform</span> <span class="o">=</span> <span class="n">identity_mat4f</span><span class="p">;</span>
    <span class="n">mat4f</span> <span class="n">_local_xform</span> <span class="o">=</span> <span class="n">identity_mat4f</span><span class="p">;</span>
    <span class="n">mat4f</span> <span class="n">_skin_xform</span> <span class="o">=</span> <span class="n">identity_mat4f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Node in the hierarchy.</p>
<ul>
<li>Members:<ul>
<li>name:      name</li>
<li>cam:      camera reference</li>
<li>msh:      mesh reference</li>
<li>skn:      mesh reference</li>
<li>children:      children</li>
<li>matrix:      A floating-point 4x4 transformation matrix stored in column-major order.</li>
<li>rotation:      The node's unit quaternion rotation in the order (x, y, z, w), where w
 is the scalar.</li>
<li>scale:      The node's non-uniform scale.</li>
<li>translation:      The node's translation.</li>
<li>morph_weights:      morph target weights</li>
<li>parent:      parent node (computed during update_node_hierarchy())</li>
<li>xform():      transform (computed during update_transforms())</li>
<li>local_xform():      local transform (computed during update_transforms())</li>
<li>skin_xform():      skin transform (computed during update_transforms())</li>
<li>_xform:      transform (computed during update_transforms())</li>
<li>_local_xform:      local transform (computed during update_transforms())</li>
<li>_skin_xform:      skin transform (computed during update_transforms())</li>
</ul>
</li>
</ul>
<h4>Enum gltf_animation_interpolation</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">gltf_animation_interpolation</span> <span class="p">{</span>
    <span class="n">linear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">catmull_rom</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">cubic</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Animation Interpolation</p>
<ul>
<li>Values:<ul>
<li>linear:      linear</li>
<li>step:      step function</li>
<li>catmull_rom:      catmull-rom spline</li>
<li>cubic:      cubic bezier spline</li>
</ul>
</li>
</ul>
<h4>Struct gltf_animation</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gltf_animation</span> <span class="p">{</span>
    <span class="n">gltf_animation_interpolation</span> <span class="n">interp</span> <span class="o">=</span> <span class="n">gltf_animation_interpolation</span><span class="o">::</span><span class="n">step</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gltf_node</span><span class="o">*&gt;</span> <span class="n">nodes</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">time</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">translation</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">quat4f</span><span class="o">&gt;</span> <span class="n">rotation</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">scale</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&gt;</span> <span class="n">morph_weights</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Keyframe data.</p>
<ul>
<li>Members:<ul>
<li>interp:      Interpolation</li>
<li>nodes:      Target nodes</li>
<li>time:      Times</li>
<li>translation:      Translation</li>
<li>rotation:      Rotation</li>
<li>scale:      Scale</li>
<li>morph_weights:      Weights for morphing</li>
</ul>
</li>
</ul>
<h4>Struct gltf_animation_group</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gltf_animation_group</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gltf_animation</span><span class="o">*&gt;</span> <span class="n">animations</span><span class="p">;</span>
    <span class="o">~</span><span class="n">gltf_animation_group</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Animation</p>
<ul>
<li>Members:<ul>
<li>name:      Name</li>
<li>path:      path (only used when writing files on disk with glTF)</li>
<li>animations:      Times</li>
<li>~gltf_animation_group():      cleanup</li>
</ul>
</li>
</ul>
<h4>Struct gltf_skin</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gltf_skin</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">mat4f</span><span class="o">&gt;</span> <span class="n">pose_matrices</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gltf_node</span><span class="o">*&gt;</span> <span class="n">joints</span><span class="p">;</span>
    <span class="n">gltf_node</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Skin</p>
<ul>
<li>Members:<ul>
<li>name:      name</li>
<li>path:      path (only used when writing files on disk with glTF)</li>
<li>pose_matrices:      inverse bind matrix</li>
<li>joints:      joints</li>
<li>root:      skeleton root node</li>
</ul>
</li>
</ul>
<h4>Struct gltf_scene</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gltf_scene</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gltf_node</span><span class="o">*&gt;</span> <span class="n">nodes</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Gltf scene</p>
<ul>
<li>Members:<ul>
<li>name:      name</li>
<li>nodes:      instances</li>
</ul>
</li>
</ul>
<h4>Struct gltf_scene_group</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gltf_scene_group</span> <span class="p">{</span>
    <span class="n">gltf_scene</span><span class="o">*</span> <span class="n">default_scene</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gltf_camera</span><span class="o">*&gt;</span> <span class="n">cameras</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gltf_material</span><span class="o">*&gt;</span> <span class="n">materials</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gltf_texture</span><span class="o">*&gt;</span> <span class="n">textures</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gltf_mesh</span><span class="o">*&gt;</span> <span class="n">meshes</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gltf_scene</span><span class="o">*&gt;</span> <span class="n">scenes</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gltf_node</span><span class="o">*&gt;</span> <span class="n">nodes</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gltf_animation_group</span><span class="o">*&gt;</span> <span class="n">animations</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gltf_skin</span><span class="o">*&gt;</span> <span class="n">skins</span><span class="p">;</span>
    <span class="o">~</span><span class="n">gltf_scene_group</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Gltf model. Objects are shared between scenes.
Scenes and nodes are missing for mesh-only assets.</p>
<ul>
<li>Members:<ul>
<li>default_scene:      default scene (null if not present)</li>
<li>cameras:      cameras</li>
<li>materials:      materials</li>
<li>textures:      textures</li>
<li>meshes:      meshes</li>
<li>scenes:      scenes</li>
<li>nodes:      nodes</li>
<li>animations:      nodes</li>
<li>skins:      skins</li>
<li>~gltf_scene_group():      cleanup</li>
</ul>
</li>
</ul>
<h4>Function load_scenes()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">gltf_scene_group</span><span class="o">*</span> <span class="nf">load_scenes</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">load_textures</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Load scene</p>
<ul>
<li>Parameters:<ul>
<li>filename: filename</li>
<li>load_textures: whether to load textures (default to false)</li>
<li>skip_missing: whether to skip missing buffers and textures</li>
</ul>
</li>
<li>Returns:<ul>
<li>scene (nullptr on error)</li>
</ul>
</li>
</ul>
<h4>Function save_scenes()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">save_scenes</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">buffer_uri</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gltf_scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">save_textures</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">separate_buffers</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Save scene</p>
<ul>
<li>Parameters:<ul>
<li>filename: filename</li>
<li>buffer_uri: name of the main buffer</li>
<li>scn: scene data to save</li>
<li>save_textures: whether to save textures (default to false)</li>
<li>separate_buffers: save separate buffers for each mesh</li>
</ul>
</li>
</ul>
<h4>Function update_node_hierarchy()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_node_hierarchy</span><span class="p">(</span><span class="n">gltf_scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Update node hierarchy</p>
<h4>Function update_transforms()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_transforms</span><span class="p">(</span><span class="n">gltf_scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Update node trasforms</p>
<h4>Function update_animated_transforms()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_animated_transforms</span><span class="p">(</span><span class="n">gltf_scene_group</span><span class="o">*</span> <span class="n">scns</span><span class="p">,</span> <span class="kt">float</span> <span class="n">time</span><span class="p">);</span>
</code></pre></div>


<p>Update animated node</p>
<h4>Function get_mesh_nodes()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gltf_node</span><span class="o">*&gt;</span> <span class="n">get_mesh_nodes</span><span class="p">(</span><span class="k">const</span> <span class="n">gltf_scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Get a list of nodes with meshes</p>
<h4>Function get_camera_nodes()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">gltf_node</span><span class="o">*&gt;</span> <span class="n">get_camera_nodes</span><span class="p">(</span><span class="k">const</span> <span class="n">gltf_scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Get a list of nodes with cameras</p>
<h4>Function get_animation_bounds()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec2f</span> <span class="nf">get_animation_bounds</span><span class="p">(</span><span class="k">const</span> <span class="n">gltf_scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Animation times</p>
<h4>Function get_skin_transforms()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">mat4f</span><span class="o">&gt;</span> <span class="n">get_skin_transforms</span><span class="p">(</span><span class="k">const</span> <span class="n">gltf_skin</span><span class="o">*</span> <span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">xform</span><span class="p">);</span>
</code></pre></div>


<p>Skin transforms (local-to-object) from the node transform that instances the
skin</p>
<h4>Function compute_morphing_deformation()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">compute_morphing_deformation</span><span class="p">(</span><span class="k">const</span> <span class="n">gltf_shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">weights</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">tangsp</span><span class="p">);</span>
</code></pre></div>


<p>Compute shape morphing</p>
<h4>Function compute_scene_bounds()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">bbox3f</span> <span class="nf">compute_scene_bounds</span><span class="p">(</span><span class="k">const</span> <span class="n">gltf_scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Computes a scene bounding box</p>
<h4>Function add_normals()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_normals</span><span class="p">(</span><span class="n">gltf_scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Add missing data to the scene.</p>
<h4>Function add_radius()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_radius</span><span class="p">(</span><span class="n">gltf_scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Add missing data to the scene.</p>
<h4>Function add_tangent_space()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_tangent_space</span><span class="p">(</span><span class="n">gltf_scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Add missing data to the scene.</p>
<h4>Function add_nodes()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_nodes</span><span class="p">(</span><span class="n">gltf_scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Add missing data to the scene.</p>
<h4>Function add_scene()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_scene</span><span class="p">(</span><span class="n">gltf_scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Add missing data to the scene.</p>
<h4>Function add_texture_data()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_texture_data</span><span class="p">(</span><span class="n">gltf_scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Add missing data to the scene.</p>
<h4>Function add_names()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_names</span><span class="p">(</span><span class="n">gltf_scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Add missing data to the scene.</p>
<h4>Function add_default_cameras()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_default_cameras</span><span class="p">(</span><span class="n">gltf_scene_group</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Add a default camera that views the entire scene.</p>
<h4>Function add_unique_path_names()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_unique_path_names</span><span class="p">(</span>
    <span class="n">gltf_scene_group</span><span class="o">*</span> <span class="n">scns</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">buffer_uri</span><span class="p">);</span>
</code></pre></div>


<p>Set unique path names for outputting separate buffers</p>
<h4>Function add_spec_gloss()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">add_spec_gloss</span><span class="p">(</span><span class="n">gltf_scene_group</span><span class="o">*</span> <span class="n">scns</span><span class="p">);</span>
</code></pre></div>


<p>Convert materials to spec gloss</p>
<h4>Function gltf_to_scenes()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">gltf_scene_group</span><span class="o">*</span> <span class="nf">gltf_to_scenes</span><span class="p">(</span><span class="k">const</span> <span class="n">glTF</span><span class="o">*</span> <span class="n">gltf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">scene_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Convert a gltf asset to flattened group of scene.</p>
<h4>Function scenes_to_gltf()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">glTF</span><span class="o">*</span> <span class="nf">scenes_to_gltf</span><span class="p">(</span><span class="k">const</span> <span class="n">gltf_scene_group</span><span class="o">*</span> <span class="n">fl_gltf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">buffer_uri</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">separate_buffers</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Convert a flattened group of scene into a gltf. If separate_buffers,
creates a separate buffer for each each and animation and
prepend buffer_uri to its name.</p>
<h4>Function validate_gltf()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">validate_gltf</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">glTF</span><span class="o">*</span> <span class="n">gltf</span><span class="p">);</span>
</code></pre></div>


<p>Validate a gltf. Missing many validation as of this version.</p>
    <article>
    <footer></footer>
    </body>
    </html>
