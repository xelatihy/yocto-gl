
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <title>Yocto/GL</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
      <link rel="stylesheet" href="style.css">
    </head>
    <body>
    <header>
        <nav>
            <img src="images/logo_white.png">
            <a href="index.html">about</a>
            <a href="yocto_gl.html">api</a>
            <a href="https://github.com/xelatihy/yocto-gl">github</a>
        </nav>
    </header>
    <article>
    <h1>Yocto/GL: Tiny C++ Library for Physically-based Graphics</h1>
<p>Yocto/GL is a collection utiliies for building physically-based graphics
algorithms implemented as a two-file library (<code>yocto_gl.h</code>, <code>yocto_gl.cpp</code>),
and released under the MIT license. Features include:</p>
<ul>
<li>convenience math functions for graphics</li>
<li>static length vectors for 2, 3, 4 length and int and float type</li>
<li>static length matrices for 2x2, 3x3, 4x4 and float type</li>
<li>static length rigid transforms (frames), specialized for 2d and 3d space</li>
<li>linear algebra operations and transforms</li>
<li>axis aligned bounding boxes</li>
<li>rays and ray-primitive intersection</li>
<li>point-primitive distance and overlap tests</li>
<li>normal and tangent computation for meshes and lines</li>
<li>generation of tesselated meshes</li>
<li>mesh refinement with linear tesselation and Catmull-Cark subdivision</li>
<li>random number generation via PCG32</li>
<li>simple image data structure and a few image operations</li>
<li>simple scene format</li>
<li>generation of image examples</li>
<li>generation of scene examples</li>
<li>procedural sun and sky HDR</li>
<li>procedural Perlin noise</li>
<li>BVH for intersection and closest point query</li>
<li>Python-like iterators, string, path and container operations</li>
<li>utilities to load and save entire text and binary files</li>
<li>immediate mode command line parser</li>
<li>simple logger and thread pool</li>
<li>path tracer supporting surfaces and hairs, GGX and MIS</li>
<li>support for loading and saving Wavefront OBJ and Khronos glTF</li>
<li>OpenGL utilities to manage textures, buffers and prograrms</li>
<li>OpenGL shader for image viewing and GGX microfacet and hair rendering</li>
</ul>
<p>The current version is 0.1.0. You can access the previous multi-file version
with tag "v0.0.1" in this repository.</p>
<h2>Credits</h2>
<p>This library includes code from the PCG random number generator,
the LLVM thread pool, boost hash_combine, Pixar multijittered sampling,
code from "Real-Time Collision Detection" by Christer Ericson, base64
encode/decode by Ren√© Nyffenegger and public domain code from
github.com/sgorsten/linalg, gist.github.com/badboy/6267743 and
github.com/nothings/stb_perlin.h.</p>
<p>This library imports many symbols from std for three reasons: avoid
verbosity , esnuring better conventions when calling math functions and
allowing easy overriding of std containers if desired. Just do not
flatten this namespace into yours if this is a concern.</p>
<p>For most components of the library, the use should be relatively easy to
understand if you are familiar with 3d computer graphics. For more complex
components, we follow the usage below.</p>
<h2>Design Considerations</h2>
<p>Yocto/GL tries to follow a simple programming model inspired by C but with
heavy use of operator overloading for math readability. We attempt tp make
the code weasy to use rather than as performant as possible. The APIs
attempt to make using the code as little error prone as possible, sometimes
at the price of some slowdown. We adopt a functional style and only rarely
use classes and methods. Using a function style makes the code easier to
extend, more explicit in the requirements, and easier to write
parallel-friendly APIs. I guess you could call this "data-driven
programming". We use templates very little now, after a major refactoring,
to improve error reporting, reduce compilation times and make the codebase
more accessible to beginners. This lead to a small increase in copied code
that we deem ok at this time. Finally, we often import symbols from the
standard library rather than using the <code>std::name</code> pattern. We found that
this improves consistency, especially when using math functions, is
significantly more readable when using templates and allows to to more
easily switch STL implementation if desired.</p>
<h2>Compilation</h2>
<p>Yocto/GL is written in C++14, with compilation supported on C++11, and
compiles on OSX (clang from Xcode 9+), Linux (gcc 6+, clang 4+)
and Windows (MSVC 2017).</p>
<p>For image loading and saving, Yocto/GL depends on <code>stb_image.h</code>,
<code>stb_image_write.h</code>, <code>stb_image_resize.h</code> and <code>tinyexr.h</code>. These features
can be disabled by defining YGL_IMAGEIO to 0 before including this file.
If these features are useful, then the implementation files need to
included in the manner described by the respective libraries. To simplify
builds, we provice a file that builds these libraries, <code>stb_image.cpp</code>.</p>
<p>To support Khronos glTF, Yocto/GL depends on <code>json.hpp</code>. These feature can
be disabled by defining YGL_GLTF to 0 before including this file.</p>
<p>OpenGL utilities include the OpenGL libaries, use GLEW on Windows/Linux,
GLFW for windows handling and Dear ImGui for UI support.
Since OpenGL is quite onerous and hard to link, its support is disabled by
default. You can enable it by defining YGL_OPENGL to 1 before including
this file. If you use any of the OpenGL calls, make sure to properly link to
the OpenGL libraries on your system. For ImGUI, build with the libraries
<code>imgui.cpp</code>, <code>imgui_draw.cpp</code>, <code>imgui_impl_glfw_gl3.cpp</code>.</p>
<h2>Example Applications</h2>
<p>You can see Yocto/GL in action in the following applications written to
test the library:</p>
<ul>
<li><code>yview.cpp</code>: simple OpenGL viewer for OBJ and glTF scenes</li>
<li><code>ytrace.cpp</code>: offline path-tracer</li>
<li><code>yitrace.cpp.cpp</code>: interactive path-tracer</li>
<li><code>yscnproc.cpp</code>: scene manipulation and conversion to/from OBJ and glTF</li>
<li><code>ytestgen.cpp</code>: creates test cases for the path tracer and GL viewer</li>
<li><code>yimview.cpp</code>: HDR/PNG/JPG image viewer with exposure/gamma tone mapping</li>
<li><code>yimproc.cpp</code>: offline image manipulation.</li>
</ul>
<p>You can build the example applications using CMake with
    <code>mkdir build; cd build; cmake ..; cmake --build</code></p>
<p>Here are two images rendered with the buildin path tracer, where the
scenes are crated with the test generator.</p>
<figure><img alt="Yocto/GL" src="images/shapes.png"></figure>
<figure><img alt="Yocto/GL" src="images/lines.png"></figure>
<h2>Usage</h2>
<p>To use the library simply include this file and setup the compilation
option as described above.
All library features are documented at the definition and should be
relatively easy to use if you are familiar with writing graphics code.
You can find the extracted documentation at <code>yocto_gl.html</code>.
Here we give an overview of some of the main features.</p>
<h3>Small Vectors and Matrices, Frames, Bounding Boxes and Transforms</h3>
<p>We provide common operations for small vectors and matrices typically used
in graphics. In particular, we support 2-4 dimensional float vectors
<code>vec2f</code>, <code>vec3f</code>, <code>vec4f</code>, 2-4 dimensional int vectors <code>vec2i</code>, <code>vec3i</code>,
<code>vec4i</code> and a 4 dimensional byte vector <code>vec4b</code>. The float vectors
support most arithmetic and vector operations.</p>
<p>We support 2-4 dimensional float matrices <code>mat2f</code>, <code>mat3f</code>, <code>mat4f</code>, with
matrix-matrix and matrix-vector products, trasposes and inverses. Matrices
are stored in column-major ordered and are accessed and constructed by
column.</p>
<p>To represent transformations, most of the library facilities prefer the use
cooordinate frames, aka rigid transforms, represented as <code>frame3f</code>.
The structure store three coodinate axis and the frame origin. This is
equivalenent to a rigid transform written as a column-major affine
matrix. Transform operations are better behaved with this representation.</p>
<p>We represent coordinate bounds with axis-aligned bounding boxes in 1-4
dimensions: <code>bbox1f</code>, <code>bbox2f</code>, <code>bbox3f</code>, <code>bbox4f</code>. These types support
expansion operation, union and containment. We provide operations to
compute bounds for points, lines, triangles and quads.</p>
<p>For all basic types we support iteration with <code>begin()</code>/<code>end()</code> pairs
and stream inout and output.</p>
<p>For both matrices and frames we support transform operations for points,
vectors and directions (<code>trasform_point()</code>, <code>trasform_vector()</code>,
<code>trasform_direction()</code>). For frames we also the support inverse operations
(<code>transform_xxx_inverse()</code>). Transform matrices and frames can be
constructed from basic translation, rotation and scaling, e.g. with
<code>translation_mat4f()</code> or <code>translation_frame3f()</code> repsectively, etc. For
rotation we support axis-angle and quaternions, with slerp.</p>
<h3>Random Number Generation, Noise, Hashing and Monte Carlo support</h3>
<p>This library supportds many facitlities helpful in writing sampling
functions targeting path tracing and shape generations.</p>
<ol>
<li>Random number generation with PCG32:<ol>
<li>initialize the random number generator with <code>init_rng()</code></li>
<li>advance the random number state with <code>advance_rng()</code></li>
<li>if necessary, you can reseed the rng with <code>seed_rng()</code></li>
<li>generate random integers in an interval with <code>next_rand1i()</code></li>
<li>generate random floats and double in the [0,1) range with
   <code>next_rand1f()</code>, <code>next_rand2f()</code>, <code>next_rand3f()</code>, <code>next_rand1d()</code></li>
<li>you can skip random numbers with <code>advance_rng()</code> and get the skipped
   length with <code>rng_distance()</code></li>
<li>generate random shaffled sequences with <code>rng_shuffle()</code></li>
</ol>
</li>
<li>Perlin noise: <code>perlin_noise()</code> to generate Perlin noise with optional
   wrapping, with fractal variations <code>perlin_ridge_noise()</code>,
   <code>perlin_fbm_noise()</code>, <code>perlin_turbulence_noise()</code></li>
<li>Integer hashing: public domain hash functions for integer values as
   <code>hash_permute()</code>, <code>hash_uint32()</code>, <code>hash_uint64()</code>, <code>hash_uint64_32()</code>
   and <code>hash_combine()</code>.</li>
<li>Monte Carlo support: warp functions from [0,1)^k domains to domains
   commonly used in path tracing. In particular, use <code>sample_hemisphere()</code>,
   <code>sample_sphere()</code>, <code>sample_hemisphere_cosine()</code>,
   <code>sample_hemisphere_cospower()</code>. <code>sample_disk()</code>. <code>sample_cylinder()</code>.
   <code>sample_triangle()</code>. For each warp, you can compute the PDF with
   <code>sample_xxx_pdf()</code>.</li>
</ol>
<h3>Python-like container operations and iterators</h3>
<p>To make the code more readable, we adopt Python-like iterations and
container operations extensively throughout Yocto/GL. These operations
are mostly for internal use but could also be used externally.</p>
<ol>
<li>Python iterators with <code>range()</code> and <code>enumerate()</code></li>
<li>Python operators for containers: support for + and += for <code>std::vector</code></li>
<li>Check for containment with <code>contains</code>  similarly to <code>in</code> in Python</li>
</ol>
<h3>Shape Utilities</h3>
<p>The library contains a few function to help with typically geometry
manipulation useful to support scene viewing and path tracing.</p>
<ol>
<li>compute line tangents, and triangle and quad areas and normals</li>
<li>compute barycentric interpolation with <code>eval_barycentric_line()</code>,
   <code>eval_barycentric_triangle()</code> and <code>eval_barycentric_quad()</code></li>
<li>evaluate Bezier curve and derivatives with <code>eval_bezier_cubic()</code> and
   <code>eval_bezier_cubic_derivative()</code></li>
<li>compute smooth normals and tangents with <code>compute_normals()</code></li>
<li>compute tangent frames from texture coordinates with
   <code>compute_tangent_space()</code></li>
<li>compute skinning with <code>compute_skinning()</code> and
   <code>compute_matrix_skinning()</code></li>
<li>shape creation with <code>make_points()</code>, <code>make_lines()</code>, <code>make_uvgrid()</code></li>
<li>element merging with <code>marge_elems()</code></li>
<li>facet elements with <code>facet_elems()</code></li>
<li>shape sampling with <code>sample_points()</code>, <code>sample_lines()</code>,
   <code>sample_triangles()</code>; initialize the sampling CDFs with
   <code>sample_points_cdf()</code>, <code>sample_lines_cdf()</code>, <code>sample_triangles_cdf()</code></li>
<li>samnple a could of point over a surface with <code>sample_triangles_points()</code></li>
<li>get edges and boundaries with <code>get_edges()</code> and <code>get_boundary_edges()</code></li>
<li>convert quads to triangles with <code>convert_quads_to_triangles()</code></li>
<li>convert face varying to vertex shared representations with
    <code>convert_face_varying()</code></li>
<li>subdivide elements by edge splits with <code>subdivide_elems()</code> and
    <code>subdivide_vert()</code></li>
<li>Catmull-Clark subdivision surface with <code>subdivide_catmullclark()</code> with
    support for edge and vertex creasing</li>
<li>example shapes: <code>make_cube()</code>, <code>make_uvsphere()</code>, <code>make_uvhemisphere()</code>,
    <code>make_uvquad()</code>, <code>make_uvcube()</code>, <code>make_fvcube()</code>, <code>make_hair()</code>,
    <code>make_suzanne()</code></li>
</ol>
<h3>Image and color</h3>
<p>We support simple containers for either 4-byte per pixel sRGB images
<code>image4b</code>, or 4-float per pixel HDR images <code>image4f</code>.</p>
<ol>
<li>convert between byte and float images with <code>srgb_to_linear()</code> and
   <code>linear_to_srgb()</code></li>
<li>color conversion with <code>hsv_to_rgb()</code>, <code>xyz_to_rgb()</code> and <code>rgb_to_xyz()</code></li>
<li>exposure-gamma tonemapping, with optional filmic curve, with
   <code>tonemap_image()</code></li>
<li>compositing support with <code>image_over()</code></li>
<li>example image generation with <code>m,ake_grid_image()</code>,
   <code>make_checker_image()</code>, <code>make_bumpdimple_image()</code>, <code>make_ramp_image()</code>,
   <code>make_gammaramp_image()</code>, <code>make_gammaramp_imagef()</code>, <code>make_uv_image()</code>,
   <code>make_uvgrid_image()</code>, <code>make_recuvgrid_image()</code></li>
<li>bump to normal mapping with <code>bump_to_normal_map()</code></li>
<li>HDR sun-sky with <code>m ake_sunsky_image()</code></li>
<li>various noise images with <code>make_noise_image()</code>, <code>make_fbm_image()</code>,
   <code>make_ridge_image()</code>, <code>make_turbulence_image()</code></li>
<li>image loading and saving with <code>load_image4b()</code>, <code>load_image4f()</code>,
   <code>save_image4b()</code>, <code>save_image4f()</code></li>
<li>image resizing with <code>resize_image()</code></li>
</ol>
<h3>Ray Intersection and Point Overlap Queries</h3>
<p>We support ray-scene intersection for points, lines and triangles
accelerated by a simple BVH data structure.  Our BVH is written for minimal
code and not maximum speed, but still gives reasonable results. We suggest
the use of Intel's Embree as a fast alternative.</p>
<ol>
<li>use <code>ray3f</code> to represent rays</li>
<li>build the BVH with <code>build_points_bvh()</code>, <code>build_points_bvh()</code> or
  <code>build_points_bvh()</code></li>
<li>perform ray-element intersection with <code>intersect_points_bvh()</code>,
  <code>intersect_lines_bvh()</code> and <code>intersect_triangles_bvh()</code></li>
<li>perform point overlap queries with <code>overlap_points_bvh()</code>,
  <code>overlap_lines_bvh()</code> and <code>overlap_triangles_bvh()</code></li>
<li>to support custom elements, use <code>buid_bvh()</code>, <code>intersect_bvh()</code> and
  <code>overlap_bvh()</code> and provide them with proper callbacks</li>
<li>we also experimentally support quads with the <code>xxx_quads_xxx()</code> functions</li>
</ol>
<h3>Simple scene</h3>
<p>We support a simple scene model used to quickly write demos that lets you
load/save Wavefront OBJ and Khronos glTF and perform several simple scene
manipulation including ray-scene intersection and closest point queries.</p>
<p>The geometry model is comprised of a set of shapes, which are indexed
collections of points, lines, triangles and quads. Each shape may contain
only one element type. Shapes are organized into a scene by creating shape
instances, each its own transform. Materials are specified like in glTF and
include emission, base-metallic and diffuse-specular parametrization,
normal, occlusion and displacement mapping. Finally, the scene containes
caemras and environement maps. Quad support in shapes is experimental and
mostly supported for loading and saving.</p>
<p>For low-level access to OBJ/glTF formats, you are best accssing the formats
directly with Yocto/Obj and Yocto/glTF. This components provides a
simplified high-level access to each format which is sufficient for most
applications and tuned for quick creating viewers, renderers and simulators.</p>
<ol>
<li>load a scene with <code>load_scene()</code> and save it with <code>save_scene()</code>.</li>
<li>add missing data with <code>add_elements()</code></li>
<li>use <code>compute_bounds()</code> to compute element bounds</li>
<li>can merge scene together with <code>merge_into()</code></li>
<li>make example scenes with <code>make_test_scene()</code></li>
</ol>
<p>Ray-intersection and closet-point routines supporting points,
lines and triangles accelerated by a two-level bounding volume
hierarchy (BVH). Quad support is experimental.</p>
<ol>
<li>build the bvh with <code>build_bvh()</code></li>
<li>perform ray-interseciton tests with <code>intersect_ray()</code><ul>
<li>use early_exit=false if you want to know the closest hit point</li>
<li>use early_exit=false if you only need to know whether there is a hit</li>
<li>for points and lines, a radius is required</li>
<li>for triangles, the radius is ignored</li>
</ul>
</li>
<li>perform point overlap tests with <code>overlap_point()</code> to check whether
   a point overlaps with an element within a maximum distance<ul>
<li>use early_exit as above</li>
<li>for all primitives, a radius is used if defined, but should
  be very small compared to the size of the primitive since the radius
  overlap is approximate</li>
</ul>
</li>
<li>perform instance overlap queries with <code>overlap_instance_bounds()</code></li>
<li>use <code>refit_bvh()</code> to recompute the bvh bounds if transforms or vertices
   are changed (you should rebuild the bvh for large changes)</li>
</ol>
<p>Notes: Quads are internally handled as a pair of two triangles v0,v1,v3 and
v2,v3,v1, with the u/v coordinates of the second triangle corrected as 1-u
and 1-v to produce a quad parametrization where u and v go from 0 to 1. This
is equivalent to Intel's Embree.</p>
<h3>Pathtracing</h3>
<p>We supply a path tracer implementation with support for textured mesh
lights, GGX/Phong materials, environment mapping. The interface supports
progressive parallel execution. The path tracer takes as input a scene
and update pixels in image with traced samples. We use a straightfoward
path tracer with MIS and also a few simpler shaders for debugging or
quick image generation.</p>
<p>Materials are represented as sums of an emission term, a diffuse term and
a specular microfacet term (GGX or Phong). Only opaque for now. We pick
a proper material type for each shape element type (points, lines,
triangles).</p>
<p>Lights are defined as any shape with a material emission term. Additionally
one can also add environment maps. But even if you can, you might want to
add a large triangle mesh with inward normals instead. The latter is more
general (you can even more an arbitrary shape sun). For now only the first
env is used.</p>
<ol>
<li>build the ray-tracing acceleration structure with <code>build_bvh()</code></li>
<li>prepare lights for rendering <code>update_lights()</code></li>
<li>define rendering params with the <code>trace_params</code> structure</li>
<li>render blocks of samples with <code>trace_block()</code></li>
</ol>
<p>The code can also run in fully asynchronous mode to preview images in a
window.</p>
<ol>
<li>build the ray-tracing acceleration structure with <code>build_bvh()</code></li>
<li>prepare lights for rendering <code>update_lights()</code></li>
<li>define rendering params with the <code>trace_params</code> structure</li>
<li>initialize the prograssive rendering buffers</li>
<li>start the progressive renderer with <code>trace_async_start()</code></li>
<li>stop the progressive renderer with <code>trace_async_stop()</code></li>
</ol>
<h3>Wavefront OBJ</h3>
<p>Wavefront OBJ/MTL loader and writer with support for points,
lines, triangles and general polygons and all materials properties.
Contains also a few extensions to easily create demos such as per-vertex
color and radius, cameras, environment maps and instances.
Can use either a low-level OBJ representation, from this files,
or a high level flattened representation included in Yocto/Scn.</p>
<p>Both in reading and writing, OBJ has no clear convention on the orientation
of textures Y axis. So in many cases textures appears flipped. To handle
that, use the option to flip textures coordinates on either saving or
loading. By default texture coordinates are flipped since this seems
the convention found on test cases collected on the web. The value Tr
has similar problems, since its relation to opacity is software specific.
Again we let the user chose the convension and set the default to the
one found on the web.</p>
<p>In the high level interface, shapes are indexed meshes and are described
by arrays of vertex indices for points/lines/triangles and arrays for vertex
positions, normals, texcoords, color and radius. The latter two as
extensions. Since OBJ is a complex formats that does not match well with
current GPU rendering / path tracing algorithms, we adopt a simplification
similar to other single file libraries:
1. vertex indices are unique, as in OpenGL and al standard indexed triangle
  meshes data structures, and not OBJ triplets; YOCTO_OBJ ensures that no
  vertex dusplication happens thought for same triplets
2. we split shapes on changes to groups and materials, instead of keeping
  per-face group/material data; this makes the data usable right away in
  a GPU viewer; this is not a major limitation if we accept the previous
  point that already changes shapes topology.</p>
<ol>
<li>load a obj data with <code>load_obj()</code>; can load also textues</li>
<li>look at the <code>obj_XXX</code> data structures for access to individual elements</li>
<li>use obj back to disk with <code>save_obj()</code>; can also save textures</li>
<li>use get_shape() to get a flattened shape version that contains only
   triangles, lines or points</li>
</ol>
<h3>Khronos glTF</h3>
<p>Khronos GLTF loader and writer for Khronos glTF format. Supports
all the glTF spec and the Khronos extensions. All parsing and writing code
is autogenerated form the schema. Supports glTF version 2.0 and the
following extensions: <code>KHR_binary_glTF</code> and <code>KHR_specular_glossiness</code>.</p>
<p>This component depends on <code>json.hpp</code> and, for image loading and saving,
it depends on <code>stb_image.h</code>, <code>stb_image_write.h</code>, <code>stb_image_resize.h</code> and
<code>tinyexr.h</code>. This feature can be disabled as before.</p>
<p>The library provides a low  level interface that is a direct
C++ translation of the glTF schemas and should be used if one wants
complete control over the fromat or an application wants to have their
own scene code added. A higher-level interface is provided by the scene
or by <code>yocto_gltf.h</code>.</p>
<p>glTF is a very complex file format and was designed mainly with untyped
languages in mind. We attempt to match the glTF low-level interface
to C++ as best as it can. Since the code is generated from the schema, we
follow glTF naming conventions and typing quite well. To simplify adoption
and keep the API relatively simple we use vector as arrays and use
pointers to reference to all glTF objects. While this makes it less effcient
than it might have been, glTF heavy use of optional values makes this
necessary. At the same time, we do not keep track of set/unset values
for basic types (int, float, bool) as a compromise for efficieny.</p>
<p>glTF uses integer indices to access objects.
While writing code ourselves we found that we add signiicant problems
since we would use an index to access the wriong type of scene objects.
For this reasons, we use an explit index <code>glTFid&lt;T&gt;</code> that can only access
an object of type T. Internally this is just the same old glTF index. But
this can used to access the scene data with <code>glTF::get&lt;T&gt;(index)</code>.</p>
<ol>
<li>load a glTF model with <code>load_gltf()</code></li>
<li>look at the <code>glTFXXX</code> data structures for access to individual elements</li>
<li>save glTF back to disk with <code>save_gltf()</code></li>
</ol>
<h3>OpenGL support</h3>
<p>We include a set of utilities to draw on screen with OpenGL 3.3, manage
windows with GLFW and draw immediate-mode widgets with ImGui.</p>
<ol>
<li>texture and buffer objects with <code>gl_texture</code> and <code>gl_buffer</code><ul>
<li>create textures/buffers with appropriate constructors</li>
<li>check validity wiht <code>is_valid()</code></li>
<li>update textures/buffers with <code>update()</code> functions</li>
<li>delete textures/buffers with <code>clear()</code></li>
<li>bind/unbind textures/buffers with <code>bind()</code>/<code>unbind()</code></li>
<li>draw elements with <code>gl_buffer::draw_elems()</code></li>
</ul>
</li>
<li>program objects with <code>gl_program</code><ul>
<li>program creation with constructor</li>
<li>check validity wiht <code>is_valid()</code></li>
<li>delete with <code>clear()</code></li>
<li>uniforms with <code>set_program_uniform()</code></li>
<li>vertex attrib with <code>set_program_vertattr()</code></li>
<li>draw elements with <code>gl_buffer::draw_elems()</code></li>
</ul>
</li>
<li>image viewing with <code>gl_stdimage_program</code>, with support for tone mapping.</li>
<li>draw surfaces and hair with GGX/Kayjia-Kay with <code>gl_stdsurface_program</code><ul>
<li>initialize the program with constructor</li>
<li>check validity wiht <code>is_valid()</code></li>
<li>start/end each frame with <code>begin_frame()</code>, <code>end_frame()</code></li>
<li>define lights with <code>set_lights()</code></li>
<li>start/end each shape with <code>begin_shape()</code>, <code>end_shape()</code></li>
<li>define material Parameters with <code>set_material()</code></li>
<li>define vertices with <code>set_vert()</code></li>
<li>draw elements with <code>draw_elems()</code></li>
</ul>
</li>
<li>draw yocto scenes using the above shader<ul>
<li>initialize the rendering state with <code>init_stdprogram_state()</code></li>
<li>load/update meshes and textures with <code>update_stdprogram_state()</code></li>
<li>setup draw params using a <code>gl_stdsurface_params</code> struct</li>
<li>draw scene with <code>draw_stdprogram_scene()</code></li>
</ul>
</li>
<li>also includes other utlities for quick OpenGL hacking</li>
<li>GLFW window with <code>gl_window</code><ul>
<li>create with constructor</li>
<li>delete with <code>clear()</code></li>
<li>set callbacks with <code>set_callbacks()</code></li>
<li>includes carious utiliies to query window, mouse and keyboard</li>
</ul>
</li>
<li>immediate mode widgets using ImGui<ul>
<li>init with <code>init_widget()</code></li>
<li>use the various widget calls to draw the widget and handle events</li>
</ul>
</li>
</ol>
<h3>Other Utilities</h3>
<p>We include additional utilities for writing command line applications and
manipulating files.</p>
<ol>
<li>Python-like string opeations: <code>startswith()</code>, <code>endswith()</code>, <code>contains()</code>,
   <code>splitlines()</code>, <code>partition()</code>, <code>split()</code>, <code>splitlines()</code>, <code>strip()</code>,
   <code>rstrip()</code>, <code>lstrip()</code>, <code>join()</code>, <code>lower()</code>, <code>upper()</code>, <code>isspace()</code>,
   <code>replace()</code></li>
<li>Path-like path operations: <code>path_dirname()</code>, <code>path_extension()</code>,
   <code>path_basename()</code>, <code>path_filename()</code>, <code>replace_path_extension()</code>,
   <code>prepend_path_extension()</code>, <code>split_path()</code></li>
<li>Python-like format strings (only support for position arguments and no
   formatting commands): <code>format()</code>, <code>print()</code></li>
<li>load/save entire files: <code>load_binfile()</code>, <code>load_txtfile()</code>,
   <code>save_binfile()</code> and <code>save_binfile()</code></li>
<li>simple logger with support for console and file streams:<ol>
<li>create a <code>logger</code></li>
<li>add more streams with <code>add_console_stream()</code> or <code>add_file_stream()</code></li>
<li>write log messages with <code>log_msg()</code> and its variants</li>
<li>you can also use a global default logger with the free functions
   <code>log_XXX()</code></li>
</ol>
</li>
<li>thead pool for concurrent execution (waiting the standard to catch up):<ol>
<li>either create a <code>thread_pool</code> or use the global one</li>
<li>run tasks in parallel <code>parallel_for()</code></li>
<li>run tasks asynchronously <code>async()</code></li>
</ol>
</li>
<li>timer for simple access to <code>std::chrono</code>:<ol>
<li>create a <code>timer</code></li>
<li>start and stop the clock with <code>start()</code> and <code>stop()</code></li>
<li>get time with <code>elapsed_time()</code></li>
</ol>
</li>
</ol>
<h3>Command Line Parsing</h3>
<p>The library includes a simple command line parser that parses commands in
immediate mode, i.e. when an option is declared. The parser supports options
and unnamed arguments with generic types parsed using C++ stream. The
parser autogenerates its own documentation. This allows to write complex
command lines with a tiny amount of implementation code on both the library
and user end.</p>
<ol>
<li>create a <code>cmdline</code> parser object by passing <code>argc, argv, name, help</code><ul>
<li>an option for printing help is automatically added</li>
</ul>
</li>
<li>for each option, parse it calling the functions <code>parse_opt()</code><ul>
<li>options are parsed on the fly and a comprehensive help is
  automatically generated</li>
<li>supports bool (flags), int, float, double, string, enums</li>
<li>options names are "--longname" for longname and "-s" for short</li>
<li>command line format is "--longname value", "-s v" for all but flags</li>
<li>values are parsed with <code>iostream &lt;&lt;</code> operators</li>
<li>for general use <code>opt = parse_opt&lt;type&gt;()</code></li>
<li>for boolean flags is <code>parse_flag()</code></li>
<li>for enums use <code>parse_opte()</code></li>
</ul>
</li>
<li>for each unnamed argument, parse it calling the functions parse_arg()<ul>
<li>names are only used for help</li>
<li>supports types as above</li>
<li>for general use <code>arg = parse_arg&lt;type&gt;()</code></li>
<li>to parse all remaining values use <code>args = parse_arga&lt;type&gt;(...)</code></li>
</ul>
</li>
<li>end cmdline parsing with <code>check_parsing()</code> to check for unsued values,
   missing arguments</li>
<li>to check for error use <code>should_exit()</code> and to print the message use
   <code>get_message()</code></li>
<li>since arguments are parsed immediately, one can easily implement
   subcommands by just branching the command line code based on a read
   argument without any need for complex syntax</li>
</ol>
<h2>History</h2>
<p>Here we mark only major features added to the library. Small refactorings
and bug fixes are reported here.</p>
<ul>
<li>v 0.1.0: initial release after refactoring</li>
</ul>
<h2>API Documentation</h2>
<h4>Function Alias sqrt()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">;</span>
</code></pre></div>


<p>sqrt</p>
<h4>Function Alias pow()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">;</span>
</code></pre></div>


<p>pow</p>
<h4>Function Alias exp()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">exp</span><span class="p">;</span>
</code></pre></div>


<p>pow</p>
<h4>Function Alias log()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">log</span><span class="p">;</span>
</code></pre></div>


<p>log</p>
<h4>Function Alias log10()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">log10</span><span class="p">;</span>
</code></pre></div>


<p>log10</p>
<h4>Function Alias sin()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">;</span>
</code></pre></div>


<p>sin</p>
<h4>Function Alias cos()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">;</span>
</code></pre></div>


<p>cos</p>
<h4>Function Alias tan()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">tan</span><span class="p">;</span>
</code></pre></div>


<p>tan</p>
<h4>Function Alias asin()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">asin</span><span class="p">;</span>
</code></pre></div>


<p>asin</p>
<h4>Function Alias acos()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">acos</span><span class="p">;</span>
</code></pre></div>


<p>acos</p>
<h4>Function Alias atan()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">atan</span><span class="p">;</span>
</code></pre></div>


<p>atan</p>
<h4>Function Alias atan2()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">atan2</span><span class="p">;</span>
</code></pre></div>


<p>atan2</p>
<h4>Function Alias abs()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">;</span>
</code></pre></div>


<p>absolute value</p>
<h4>Function Alias fabs()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">fabs</span><span class="p">;</span>
</code></pre></div>


<p>floating point absolute value</p>
<h4>Function Alias floor()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">floor</span><span class="p">;</span>
</code></pre></div>


<p>floor</p>
<h4>Function Alias ceil()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">;</span>
</code></pre></div>


<p>ceil</p>
<h4>Function Alias round()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">round</span><span class="p">;</span>
</code></pre></div>


<p>round</p>
<h4>Function Alias isfinite()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">isfinite</span><span class="p">;</span>
</code></pre></div>


<p>isfinate</p>
<h4>Function Alias string()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
</code></pre></div>


<p>string</p>
<h4>Function Alias vector()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
</code></pre></div>


<p>vector</p>
<h4>Function Alias array()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="p">;</span>
</code></pre></div>


<p>array</p>
<h4>Function Alias map()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="p">;</span>
</code></pre></div>


<p>map</p>
<h4>Function Alias unordered_map()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="p">;</span>
</code></pre></div>


<p>unordered map</p>
<h4>Function Alias unordered_set()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="p">;</span>
</code></pre></div>


<p>unordered set</p>
<h4>Function Alias pair()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="p">;</span>
</code></pre></div>


<p>pair</p>
<h4>Function Alias tuple()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="p">;</span>
</code></pre></div>


<p>tuple</p>
<h4>Function Alias unique_ptr()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="p">;</span>
</code></pre></div>


<p>unique pointer</p>
<h4>Function Alias function()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="p">;</span>
</code></pre></div>


<p>function</p>
<h4>Namespace using std::string_literals;</h4>
<p>string literals</p>
<h4>Function Alias numeric_limits()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="p">;</span>
</code></pre></div>


<p>numeric limits</p>
<h4>Function Alias initializer_list()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="p">;</span>
</code></pre></div>


<p>initializer list</p>
<h4>Function Alias ostream()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="p">;</span>
</code></pre></div>


<p>output stream</p>
<h4>Function Alias istream()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="p">;</span>
</code></pre></div>


<p>input stream</p>
<h4>Function Alias stringstream()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span><span class="p">;</span>
</code></pre></div>


<p>string stream</p>
<h4>Function Alias fstream()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">fstream</span><span class="p">;</span>
</code></pre></div>


<p>file stream</p>
<h4>Function Alias runtime_error()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">;</span>
</code></pre></div>


<p>runtime error</p>
<h4>Function Alias exception()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">;</span>
</code></pre></div>


<p>exception</p>
<h4>Function Alias ios_base()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">ios_base</span><span class="p">;</span>
</code></pre></div>


<p>ios base</p>
<h4>Function Alias find()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">;</span>
</code></pre></div>


<p>find algorithms</p>
<h4>Function Alias swap()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
</code></pre></div>


<p>swap algorithms</p>
<h4>Function Alias getline()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">;</span>
</code></pre></div>


<p>get line from streams</p>
<h4>Function Alias to_string()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">;</span>
</code></pre></div>


<p>convert to string</p>
<h4>Function Alias cout()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
</code></pre></div>


<p>cout object for printing</p>
<h4>Typedef byte</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">byte</span> <span class="o">=</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">;</span>
</code></pre></div>


<p>convenient typedef for bytes</p>
<h4>Typedef uint</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">uint</span> <span class="o">=</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">;</span>
</code></pre></div>


<p>convenient typedef for bytes</p>
<h4>Constant pif</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">pif</span> <span class="o">=</span> <span class="mf">3.14159265f</span><span class="p">;</span>
</code></pre></div>


<p>pi (float)</p>
<h4>Constant pi</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1415926535897932384626433832795</span><span class="p">;</span>
</code></pre></div>


<p>pi (double)</p>
<h4>Constant flt_max</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">flt_max</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
</code></pre></div>


<p>shortcat for float max value</p>
<h4>Constant flt_min</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">flt_min</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">lowest</span><span class="p">();</span>
</code></pre></div>


<p>shortcat for float min value</p>
<h4>Constant flt_eps</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">flt_eps</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">epsilon</span><span class="p">();</span>
</code></pre></div>


<p>shortcat for float epsilon</p>
<h4>Constant int_max</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">int_max</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
</code></pre></div>


<p>shortcat for int max value</p>
<h4>Constant int_min</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">int_min</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">();</span>
</code></pre></div>


<p>shortcat for int min value</p>
<h4>Function min()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">min</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div>


<p>Safe minimum value.</p>
<h4>Function min()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">min</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div>


<p>Safe minimum value.</p>
<h4>Function min()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">min</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vs</span><span class="p">);</span>
</code></pre></div>


<p>Safe minimum value.</p>
<h4>Function min()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">min</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">vs</span><span class="p">);</span>
</code></pre></div>


<p>Safe minimum value.</p>
<h4>Function max()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div>


<p>Safe maximum value.</p>
<h4>Function max()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">max</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div>


<p>Safe maximum value.</p>
<h4>Function max()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vs</span><span class="p">);</span>
</code></pre></div>


<p>Safe maximum value.</p>
<h4>Function max()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">max</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">vs</span><span class="p">);</span>
</code></pre></div>


<p>Safe maximum value.</p>
<h4>Function clamp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">clamp</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min_</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_</span><span class="p">);</span>
</code></pre></div>


<p>Clamp a value between a minimum and a maximum.</p>
<h4>Function clamp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">clamp</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min_</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_</span><span class="p">);</span>
</code></pre></div>


<p>Clamp a value between a minimum and a maximum.</p>
<h4>Function lerp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">lerp</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">,</span> <span class="kt">float</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div>


<p>Linear interpolation.</p>
<h4>Function bilerp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">bilerp</span><span class="p">(</span><span class="kt">float</span> <span class="n">aa</span><span class="p">,</span> <span class="kt">float</span> <span class="n">ba</span><span class="p">,</span> <span class="kt">float</span> <span class="n">ab</span><span class="p">,</span> <span class="kt">float</span> <span class="n">bb</span><span class="p">,</span> <span class="kt">float</span> <span class="n">s</span><span class="p">,</span> <span class="kt">float</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div>


<p>bilinear interpolation</p>
<h4>Function pow2()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pow2</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div>


<p>Integer power of two</p>
<h4>Function fastfloor()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fastfloor</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div>


<p>Fast floor</p>
<h4>Function float_to_byte()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">byte</span> <span class="nf">float_to_byte</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div>


<p>Safe float to byte conversion</p>
<h4>Function byte_to_float()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">byte_to_float</span><span class="p">(</span><span class="n">byte</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div>


<p>Safe byte to float conversion</p>
<h4>Struct vec2f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">vec2f</span> <span class="p">{</span>
    <span class="n">vec2f</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">vec2f</span><span class="p">(</span><span class="kt">float</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="n">vec2f</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">);</span> 
    <span class="kt">float</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">float</span><span class="o">*</span> <span class="nf">data</span><span class="p">();</span> 
    <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Vector of 2 float elements.</p>
<ul>
<li>Members:<ul>
<li>vec2f():      default constructor</li>
<li>vec2f():      element constructor</li>
<li>vec2f():      element constructor</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>data():      data access</li>
<li>data():      data access</li>
<li>x:      element data</li>
<li>y:      element data</li>
</ul>
</li>
</ul>
<h4>Struct vec3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">vec3f</span> <span class="p">{</span>
    <span class="n">vec3f</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">vec3f</span><span class="p">(</span><span class="kt">float</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="n">vec3f</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">z</span><span class="p">);</span> 
    <span class="kt">float</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">float</span><span class="o">*</span> <span class="nf">data</span><span class="p">();</span> 
    <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Vector of 3 float elements.</p>
<ul>
<li>Members:<ul>
<li>vec3f():      default constructor</li>
<li>vec3f():      element constructor</li>
<li>vec3f():      element constructor</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>data():      data access</li>
<li>data():      data access</li>
<li>x:      element data</li>
<li>y:      element data</li>
<li>z:      element data</li>
</ul>
</li>
</ul>
<h4>Struct vec4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">vec4f</span> <span class="p">{</span>
    <span class="n">vec4f</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">vec4f</span><span class="p">(</span><span class="kt">float</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="n">vec4f</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">z</span><span class="p">,</span> <span class="kt">float</span> <span class="n">w</span><span class="p">);</span> 
    <span class="n">vec4f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">xyz</span><span class="p">,</span> <span class="kt">float</span> <span class="n">w</span><span class="p">);</span> 
    <span class="kt">float</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">float</span><span class="o">*</span> <span class="nf">data</span><span class="p">();</span> 
    <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">xyz</span><span class="p">();</span> 
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">xyz</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">z</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Vector of 4 float elements.</p>
<ul>
<li>Members:<ul>
<li>vec4f():      default constructor</li>
<li>vec4f():      element constructor</li>
<li>vec4f():      element constructor</li>
<li>vec4f():      constructor from smaller vector</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>data():      data access</li>
<li>data():      data access</li>
<li>xyz():      access xyz components</li>
<li>xyz():      access xyz components</li>
<li>x:      element data</li>
<li>y:      element data</li>
<li>z:      element data</li>
<li>w:      element data</li>
</ul>
</li>
</ul>
<h4>Struct vec2i</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">vec2i</span> <span class="p">{</span>
    <span class="n">vec2i</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">vec2i</span><span class="p">(</span><span class="kt">int</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="n">vec2i</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span> 
    <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span><span class="o">*</span> <span class="nf">data</span><span class="p">();</span> 
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Vector of 2 int elements.</p>
<ul>
<li>Members:<ul>
<li>vec2i():      default constructor</li>
<li>vec2i():      element constructor</li>
<li>vec2i():      element constructor</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>data():      data access</li>
<li>data():      data access</li>
<li>x:      element data</li>
<li>y:      element data</li>
</ul>
</li>
</ul>
<h4>Struct vec3i</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">vec3i</span> <span class="p">{</span>
    <span class="n">vec3i</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">vec3i</span><span class="p">(</span><span class="kt">int</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="n">vec3i</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">);</span> 
    <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span><span class="o">*</span> <span class="nf">data</span><span class="p">();</span> 
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Vector of 3 int elements.</p>
<ul>
<li>Members:<ul>
<li>vec3i():      default constructor</li>
<li>vec3i():      element constructor</li>
<li>vec3i():      element constructor</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>data():      data access</li>
<li>data():      data access</li>
<li>x:      element data</li>
<li>y:      element data</li>
<li>z:      element data</li>
</ul>
</li>
</ul>
<h4>Struct vec4i</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">vec4i</span> <span class="p">{</span>
    <span class="n">vec4i</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">vec4i</span><span class="p">(</span><span class="kt">int</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="n">vec4i</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">);</span> 
    <span class="n">vec4i</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">xyz</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">);</span> 
    <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span><span class="o">*</span> <span class="nf">data</span><span class="p">();</span> 
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">xyz</span><span class="p">();</span> 
    <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">xyz</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Vector of 4 int elements.</p>
<ul>
<li>Members:<ul>
<li>vec4i():      default constructor</li>
<li>vec4i():      element constructor</li>
<li>vec4i():      element constructor</li>
<li>vec4i():      constructor from smaller vector</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>data():      data access</li>
<li>data():      data access</li>
<li>xyz():      access xyz components</li>
<li>xyz():      access xyz components</li>
<li>x:      element data</li>
<li>y:      element data</li>
<li>z:      element data</li>
<li>w:      element data</li>
</ul>
</li>
</ul>
<h4>Struct vec3b</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">vec3b</span> <span class="p">{</span>
    <span class="n">vec3b</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">vec3b</span><span class="p">(</span><span class="kt">int</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="n">vec3b</span><span class="p">(</span><span class="n">byte</span> <span class="n">x</span><span class="p">,</span> <span class="n">byte</span> <span class="n">y</span><span class="p">,</span> <span class="n">byte</span> <span class="n">z</span><span class="p">);</span> 
    <span class="n">byte</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">byte</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">byte</span><span class="o">*</span> <span class="nf">data</span><span class="p">();</span> 
    <span class="k">const</span> <span class="n">byte</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">byte</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">byte</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">byte</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Vector of 3 byte elements.</p>
<ul>
<li>Members:<ul>
<li>vec3b():      default constructor</li>
<li>vec3b():      element constructor</li>
<li>vec3b():      element constructor</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>data():      data access</li>
<li>data():      data access</li>
<li>x:      element data</li>
<li>y:      element data</li>
<li>z:      element data</li>
</ul>
</li>
</ul>
<h4>Struct vec4b</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">vec4b</span> <span class="p">{</span>
    <span class="n">vec4b</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">vec4b</span><span class="p">(</span><span class="n">byte</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="n">vec4b</span><span class="p">(</span><span class="n">byte</span> <span class="n">x</span><span class="p">,</span> <span class="n">byte</span> <span class="n">y</span><span class="p">,</span> <span class="n">byte</span> <span class="n">z</span><span class="p">,</span> <span class="n">byte</span> <span class="n">w</span><span class="p">);</span> 
    <span class="n">vec4b</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3b</span><span class="o">&amp;</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">byte</span> <span class="n">w</span><span class="p">);</span> 
    <span class="n">byte</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">byte</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">byte</span><span class="o">*</span> <span class="nf">data</span><span class="p">();</span> 
    <span class="k">const</span> <span class="n">byte</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec3b</span><span class="o">&amp;</span> <span class="n">xyz</span><span class="p">();</span> 
    <span class="k">const</span> <span class="n">vec3b</span><span class="o">&amp;</span> <span class="n">xyz</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">byte</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">byte</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">byte</span> <span class="n">z</span><span class="p">;</span>
    <span class="n">byte</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Vector of 4 byte elements.</p>
<ul>
<li>Members:<ul>
<li>vec4b():      default constructor</li>
<li>vec4b():      element constructor</li>
<li>vec4b():      element constructor</li>
<li>vec4b():      constructor from smaller vector</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>data():      data access</li>
<li>data():      data access</li>
<li>xyz():      access xyz components</li>
<li>xyz():      access xyz components</li>
<li>x:      element data</li>
<li>y:      element data</li>
<li>z:      element data</li>
<li>w:      element data</li>
</ul>
</li>
</ul>
<h4>Constant zero2f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">zero2f</span> <span class="o">=</span> <span class="n">vec2f</span><span class="p">();</span>
</code></pre></div>


<p>2-dimensional float zero vector</p>
<h4>Constant zero3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">zero3f</span> <span class="o">=</span> <span class="n">vec3f</span><span class="p">();</span>
</code></pre></div>


<p>3-dimensional float zero vector</p>
<h4>Constant zero4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">zero4f</span> <span class="o">=</span> <span class="n">vec4f</span><span class="p">();</span>
</code></pre></div>


<p>4-dimensional float zero vector</p>
<h4>Constant zero2i</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">zero2i</span> <span class="o">=</span> <span class="n">vec2i</span><span class="p">();</span>
</code></pre></div>


<p>2-dimensional int zero vector</p>
<h4>Constant zero3i</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">zero3i</span> <span class="o">=</span> <span class="n">vec3i</span><span class="p">();</span>
</code></pre></div>


<p>3-dimensional int zero vector</p>
<h4>Constant zero4i</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">zero4i</span> <span class="o">=</span> <span class="n">vec4i</span><span class="p">();</span>
</code></pre></div>


<p>4-dimensional int zero vector</p>
<h4>Constant zero4b</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">zero4b</span> <span class="o">=</span> <span class="n">vec4b</span><span class="p">();</span>
</code></pre></div>


<p>4-dimensional byte zero vector</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">begin</span><span class="p">(</span><span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>iteration support</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">begin</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>iteration support</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">end</span><span class="p">(</span><span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>iteration support</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">end</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>iteration support</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">begin</span><span class="p">(</span><span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>iteration support</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">begin</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>iteration support</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">end</span><span class="p">(</span><span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>iteration support</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">end</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>iteration support</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">begin</span><span class="p">(</span><span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>iteration support</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">begin</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>iteration support</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">end</span><span class="p">(</span><span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>iteration support</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">end</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>iteration support</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator ==</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator !=</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator ==</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator !=</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator ==</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator !=</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator ==</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator !=</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator ==</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator !=</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator ==</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator !=</p>
<h4>Function operator &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator &lt; (lexicographic order - useful for map)</p>
<h4>Function operator &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator &lt; (lexicographic order - useful for map)</p>
<h4>Function operator &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator &lt; (lexicographic order - useful for map)</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator *</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator *</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator *</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator /</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator /</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator /</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator *</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator *</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator *</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator /</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator /</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator /</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator *</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator *</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator *</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator /</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator /</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator /</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +=</p>
<h4>Function operator-=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -=</p>
<h4>Function operator*=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator *=</p>
<h4>Function operator*=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator *=</p>
<h4>Function operator/=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">/=</span><span class="p">(</span><span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator /=</p>
<h4>Function operator/=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">/=</span><span class="p">(</span><span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator /=</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +=</p>
<h4>Function operator-=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -=</p>
<h4>Function operator*=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator *=</p>
<h4>Function operator*=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator *=</p>
<h4>Function operator/=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">/=</span><span class="p">(</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator /=</p>
<h4>Function operator/=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">/=</span><span class="p">(</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator /=</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +=</p>
<h4>Function operator-=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -=</p>
<h4>Function operator*=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator *=</p>
<h4>Function operator*=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator *=</p>
<h4>Function operator/=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">/=</span><span class="p">(</span><span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator /=</p>
<h4>Function operator/=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">/=</span><span class="p">(</span><span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator /=</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2i</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2i</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2i</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2i</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3i</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3i</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3i</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3i</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4i</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4i</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4i</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +</p>
<h4>Function operator-()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4i</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +=</p>
<h4>Function operator-=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -=</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +=</p>
<h4>Function operator-=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -=</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator +=</p>
<h4>Function operator-=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator -=</p>
<h4>Function dot()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">dot</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector dot product</p>
<h4>Function dot()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">dot</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector dot product</p>
<h4>Function dot()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">dot</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector dot product</p>
<h4>Function cross()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">cross</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector cross product</p>
<h4>Function cross()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">cross</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector cross product</p>
<h4>Function length()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">length</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector length</p>
<h4>Function length()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">length</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector length</p>
<h4>Function length()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">length</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector length</p>
<h4>Function normalize()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="nf">normalize</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector normalization</p>
<h4>Function normalize()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">normalize</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector normalization</p>
<h4>Function normalize()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="nf">normalize</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>vector normalization</p>
<h4>Function uangle()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">uangle</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>angle between normalized vectors</p>
<h4>Function uangle()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">uangle</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>angle between normalized vectors</p>
<h4>Function angle()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">angle</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>angle between vectors</p>
<h4>Function lerp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="nf">lerp</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="kt">float</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div>


<p>vector linear interpolation</p>
<h4>Function lerp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">lerp</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="kt">float</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div>


<p>vector linear interpolation</p>
<h4>Function lerp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="nf">lerp</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="kt">float</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div>


<p>vector linear interpolation</p>
<h4>Function bilerp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">bilerp</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">aa</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ba</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ab</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">bb</span><span class="p">,</span> <span class="kt">float</span> <span class="n">s</span><span class="p">,</span> <span class="kt">float</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div>


<p>vector bilinear interpolation</p>
<h4>Function nlerp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">nlerp</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="kt">float</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div>


<p>vector normalized linear interpolation</p>
<h4>Function slerp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">slerp</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="kt">float</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div>


<p>vector spherical linear interpolation (vectors have to be normalized)</p>
<h4>Function nlerp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="nf">nlerp</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="kt">float</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div>


<p>vector normalized linear interpolation</p>
<h4>Function slerp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="nf">slerp</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="kt">float</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div>


<p>vector spherical linear interpolation (vectors have to be normalized)</p>
<h4>Function orthogonal()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">orthogonal</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>orthogonal vector</p>
<h4>Function orthonormalize()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">orthonormalize</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>orthonormalize two vectors</p>
<h4>Function clamp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="nf">clamp</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span><span class="p">);</span>
</code></pre></div>


<p>vector component-wise clamp</p>
<h4>Function clamp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">clamp</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span><span class="p">);</span>
</code></pre></div>


<p>vector component-wise clamp</p>
<h4>Function clamp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="nf">clamp</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">min</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span><span class="p">);</span>
</code></pre></div>


<p>vector component-wise clamp</p>
<h4>Function clamplen()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="nf">clamplen</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span><span class="p">);</span>
</code></pre></div>


<p>clamp the length of a vector</p>
<h4>Function clamplen()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">clamplen</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span><span class="p">);</span>
</code></pre></div>


<p>clamp the length of a vector</p>
<h4>Function clamplen()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="nf">clamplen</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span><span class="p">);</span>
</code></pre></div>


<p>clamp the length of a vector</p>
<h4>Function min_element()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">min_element</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>min vector element</p>
<h4>Function min_element()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">min_element</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>min vector element</p>
<h4>Function min_element()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">min_element</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>min vector element</p>
<h4>Function _max_element()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">_max_element</span><span class="p">(</span><span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>index of the max vector element</p>
<h4>Function max_element()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">max_element</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>index of the min vector element</p>
<h4>Function max_element()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">max_element</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>index of the min vector element</p>
<h4>Function max_element()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">max_element</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>index of the min vector element</p>
<h4>Function float_to_byte()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3b</span> <span class="nf">float_to_byte</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element-wise conversion</p>
<h4>Function byte_to_float()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">byte_to_float</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3b</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element-wise conversion</p>
<h4>Function float_to_byte()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4b</span> <span class="nf">float_to_byte</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element-wise conversion</p>
<h4>Function byte_to_float()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="nf">byte_to_float</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Element-wise conversion</p>
<h4>Function operator &lt; &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream write</p>
<h4>Function operator &lt; &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream write</p>
<h4>Function operator &lt; &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream write</p>
<h4>Function operator &lt; &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream write</p>
<h4>Function operator &lt; &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream write</p>
<h4>Function operator &lt; &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream write</p>
<h4>Function operator > >()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream read</p>
<h4>Function operator > >()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream read</p>
<h4>Function operator > >()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream read</p>
<h4>Function operator > >()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream read</p>
<h4>Function operator > >()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream read</p>
<h4>Function operator > >()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream read</p>
<h4>Struct hash &lt;ygl::vec2i ></h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">ygl</span><span class="o">::</span><span class="n">vec2i</span><span class="o">&gt;</span> <span class="p">{</span>
</code></pre></div>


<p>Hash functor for vector for use with unordered_map</p>
<h4>Struct hash &lt;ygl::vec3i ></h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">ygl</span><span class="o">::</span><span class="n">vec3i</span><span class="o">&gt;</span> <span class="p">{</span>
</code></pre></div>


<p>Hash functor for vector for use with unordered_map</p>
<h4>Struct hash &lt;ygl::vec4i ></h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">ygl</span><span class="o">::</span><span class="n">vec4i</span><span class="o">&gt;</span> <span class="p">{</span>
</code></pre></div>


<p>Hash functor for vector for use with unordered_map</p>
<h4>Struct mat2f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">mat2f</span> <span class="p">{</span>
    <span class="n">mat2f</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">mat2f</span><span class="p">(</span><span class="kt">float</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="n">mat2f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">);</span> 
    <span class="n">vec2f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec2f</span><span class="o">*</span> <span class="nf">data</span><span class="p">();</span> 
    <span class="k">const</span> <span class="n">vec2f</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec2f</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">vec2f</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Matrix of 2x2 elements stored in column major format.
Colums access via operator[].</p>
<ul>
<li>Members:<ul>
<li>mat2f():      default constructor</li>
<li>mat2f():      diagonal constructor</li>
<li>mat2f():      list constructor</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>data():      data access</li>
<li>data():      data access</li>
<li>x:      element data</li>
<li>y:      element data</li>
</ul>
</li>
</ul>
<h4>Struct mat3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">mat3f</span> <span class="p">{</span>
    <span class="n">mat3f</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">mat3f</span><span class="p">(</span><span class="kt">float</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="n">mat3f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">z</span><span class="p">);</span> 
    <span class="n">vec3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec3f</span><span class="o">*</span> <span class="nf">data</span><span class="p">();</span> 
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec3f</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Matrix of 3x3 elements stored in column major format.
Colums access via operator[].</p>
<ul>
<li>Members:<ul>
<li>mat3f():      default constructor</li>
<li>mat3f():      diagonal constructor</li>
<li>mat3f():      list constructor</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>data():      data access</li>
<li>data():      data access</li>
<li>x:      element data</li>
<li>y:      element data</li>
<li>z:      element data</li>
</ul>
</li>
</ul>
<h4>Struct mat4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">mat4f</span> <span class="p">{</span>
    <span class="n">mat4f</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">mat4f</span><span class="p">(</span><span class="kt">float</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="n">mat4f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">z</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span> 
    <span class="n">vec4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec4f</span><span class="o">*</span> <span class="nf">data</span><span class="p">();</span> 
    <span class="k">const</span> <span class="n">vec4f</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec4f</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">vec4f</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">vec4f</span> <span class="n">z</span><span class="p">;</span>
    <span class="n">vec4f</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Matrix of 4x4 elements stored in column major format.
Colums access via operator[].</p>
<ul>
<li>Members:<ul>
<li>mat4f():      default constructor</li>
<li>mat4f():      diagonal constructor</li>
<li>mat4f():      list constructor</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>data():      data access</li>
<li>data():      data access</li>
<li>x:      element data</li>
<li>y:      element data</li>
<li>z:      element data</li>
<li>w:      element data</li>
</ul>
</li>
</ul>
<h4>Constant identity_mat2f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">identity_mat2f</span> <span class="o">=</span> <span class="n">mat2f</span><span class="p">();</span>
</code></pre></div>


<p>2-dimensional float identity matrix</p>
<h4>Constant identity_mat3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">identity_mat3f</span> <span class="o">=</span> <span class="n">mat3f</span><span class="p">();</span>
</code></pre></div>


<p>3-dimensional float identity matrix</p>
<h4>Constant identity_mat4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">identity_mat4f</span> <span class="o">=</span> <span class="n">mat4f</span><span class="p">();</span>
</code></pre></div>


<p>4-dimensional float identity matrix</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix operator ==</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix operator !=</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix operator ==</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix operator !=</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix operator ==</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix operator !=</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat2f</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix operator +</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat3f</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix operator +</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix operator +</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat2f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix scalar multiply</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat2f</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix scalar division</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix-vector right multiply</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix-vector left multiply</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat2f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix-matrix multiply</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat3f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix scalar multiply</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat3f</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix scalar division</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix scalar multiply</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix scalar division</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix-vector right multiply</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix-vector left multiply</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat3f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix-matrix multiply</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix-vector right multiply</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix-vector left multiply</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix-matrix multiply</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix sum assignment</p>
<h4>Function operator*=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix-matrix multiply assignment</p>
<h4>Function operator*=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix scaling assignment</p>
<h4>Function operator/=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">/=</span><span class="p">(</span><span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix scaling assignment</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix sum assignment</p>
<h4>Function operator*=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix-matrix multiply assignment</p>
<h4>Function operator*=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix scaling assignment</p>
<h4>Function operator/=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">/=</span><span class="p">(</span><span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix scaling assignment</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix sum assignment</p>
<h4>Function operator*=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix-matrix multiply assignment</p>
<h4>Function operator*=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix scaling assignment</p>
<h4>Function operator/=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">/=</span><span class="p">(</span><span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>matrix scaling assignment</p>
<h4>Function mat_diagonal()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="nf">mat_diagonal</span><span class="p">(</span><span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>matrix diagonal</p>
<h4>Function mat_diagonal()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">mat_diagonal</span><span class="p">(</span><span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>matrix diagonal</p>
<h4>Function mat_diagonal()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="nf">mat_diagonal</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>matrix diagonal</p>
<h4>Function transpose()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat2f</span> <span class="nf">transpose</span><span class="p">(</span><span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>matrix transpose</p>
<h4>Function transpose()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat3f</span> <span class="nf">transpose</span><span class="p">(</span><span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>matrix transpose</p>
<h4>Function transpose()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">transpose</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>matrix transpose</p>
<h4>Function adjugate()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat2f</span> <span class="nf">adjugate</span><span class="p">(</span><span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>matrix adjugate</p>
<h4>Function adjugate()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat3f</span> <span class="nf">adjugate</span><span class="p">(</span><span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>matrix adjugate</p>
<h4>Function adjugate()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">adjugate</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>matrix adjugate</p>
<h4>Function determinant()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">determinant</span><span class="p">(</span><span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>matrix determinant</p>
<h4>Function determinant()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">determinant</span><span class="p">(</span><span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>matrix determinant</p>
<h4>Function determinant()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">determinant</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>matrix determinant</p>
<h4>Function inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat2f</span> <span class="nf">inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>matrix inverse (uses adjugate and determinant)</p>
<h4>Function inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat3f</span> <span class="nf">inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>matrix inverse (uses adjugate and determinant)</p>
<h4>Function inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>matrix inverse (uses adjugate and determinant)</p>
<h4>Function operator &lt; &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream write</p>
<h4>Function operator > >()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">mat2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream read</p>
<h4>Function operator &lt; &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream write</p>
<h4>Function operator > >()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream read</p>
<h4>Function operator &lt; &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream write</p>
<h4>Function operator > >()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream read</p>
<h4>Struct frame3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">frame3f</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">frame3f</span><span class="p">();</span> 
    <span class="n">frame3f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">z</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">);</span> 
    <span class="n">frame3f</span><span class="p">(</span><span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">);</span> 
    <span class="n">frame3f</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span> 
    <span class="n">vec3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec3f</span><span class="o">*</span> <span class="nf">data</span><span class="p">();</span> 
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">();</span> 
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">rot</span><span class="p">();</span> 
    <span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">rot</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec3f</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">z</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Rigid transforms stored as a column-major affine matrix.
In memory, this representation is equivalent to storing an 3x3 rotation
followed by a 3x1 translation. Viewed this way, the representation allows
also to retrive the axis of the coordinate frame as the first 3 columns and
the translation as the 4th column. Colums access via operator[].
Access rotation and position with pos() and rot().</p>
<ul>
<li>Members:<ul>
<li>N:      size</li>
<li>frame3f():      default constructor</li>
<li>frame3f():      element constructor</li>
<li>frame3f():      element constructor</li>
<li>frame3f():      conversion from matrix (assumes the matrix is a frame, so dangerous!)</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>data():      data access</li>
<li>data():      data access</li>
<li>pos():      access position</li>
<li>pos():      access position</li>
<li>rot():      access rotation</li>
<li>rot():      access rotation</li>
<li>x:      element data</li>
<li>y:      element data</li>
<li>z:      element data</li>
<li>o:      element data</li>
</ul>
</li>
</ul>
<h4>Constant identity_frame3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">identity_frame3f</span> <span class="o">=</span>
    <span class="n">frame3f</span><span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span> <span class="p">};</span>
</code></pre></div>


<p>indentity frame</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span><span class="o">*</span> <span class="nf">begin</span><span class="p">(</span><span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>iteration support</p>
<h4>Function begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="nf">begin</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>iteration support</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span><span class="o">*</span> <span class="nf">end</span><span class="p">(</span><span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>iteration support</p>
<h4>Function end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="nf">end</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>iteration support</p>
<h4>Function to_mat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">to_mat4f</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>frame to matrix conversion</p>
<h4>Function to_frame3f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">frame3f</span> <span class="nf">to_frame3f</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>matrix to frame conversion</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator ==</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator !=</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">frame3f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>frame composition (equivalent to affine matrix multiply)</p>
<h4>Function inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">frame3f</span> <span class="nf">inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>frame inverse (equivalent to rigid affine inverse)</p>
<h4>Function operator &lt; &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream write</p>
<h4>Function operator > >()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream read</p>
<h4>Struct quat4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">quat4f</span> <span class="p">{</span>
    <span class="n">quat4f</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">quat4f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span> 
    <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">vec4f</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">float</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">float</span><span class="o">*</span> <span class="nf">data</span><span class="p">();</span> 
    <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">z</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Quaternions implemented as a vec<T,4>. Data access via operator[].
Quaterions are xi + yj + zk + w.</p>
<ul>
<li>Members:<ul>
<li>quat4f():      default constructor</li>
<li>quat4f():      conversion from vec</li>
<li>operator vec4f():      conversion to vec</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>data():      data access</li>
<li>data():      data access</li>
<li>x:      data</li>
<li>y:      data</li>
<li>z:      data</li>
<li>w:      data</li>
</ul>
</li>
</ul>
<h4>Constant identity_quat4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">identity_quat4f</span> <span class="o">=</span> <span class="n">quat4f</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
</code></pre></div>


<p>float identity quaterion</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator ==</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>vector operator !=</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">quat4f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>quaterion multiply</p>
<h4>Function operator*()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">quat4f</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>quaterion multiply</p>
<h4>Function operator/()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">quat4f</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>quaterion division</p>
<h4>Function conjugate()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">quat4f</span> <span class="nf">conjugate</span><span class="p">(</span><span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>quaterion conjugate</p>
<h4>Function inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">quat4f</span> <span class="nf">inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>quaterion inverse</p>
<h4>Function normalize()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">quat4f</span> <span class="nf">normalize</span><span class="p">(</span><span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>quaterion inverse</p>
<h4>Function nlerp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">quat4f</span> <span class="nf">nlerp</span><span class="p">(</span><span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="kt">float</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div>


<p>quaterion normalized linear interpolation</p>
<h4>Function slerp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">quat4f</span> <span class="nf">slerp</span><span class="p">(</span><span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="kt">float</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div>


<p>quaterion spherical linear interpolation</p>
<h4>Function operator &lt; &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream write</p>
<h4>Function operator > >()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream read</p>
<h4>Struct bbox1f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">bbox1f</span> <span class="p">{</span>
    <span class="n">bbox1f</span><span class="p">();</span> 
    <span class="n">bbox1f</span><span class="p">(</span><span class="kt">float</span> <span class="n">m</span><span class="p">,</span> <span class="kt">float</span> <span class="n">M</span><span class="p">);</span> 
    <span class="kt">float</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">float</span> <span class="n">min</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Axis aligned bounding box represented as a min/max vector pair.</p>
<ul>
<li>Members:<ul>
<li>bbox1f():      initializes an invalid bbox</li>
<li>bbox1f():      list constructor</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>min:      element data</li>
<li>max:      element data</li>
</ul>
</li>
</ul>
<h4>Struct bbox2f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">bbox2f</span> <span class="p">{</span>
    <span class="n">bbox2f</span><span class="p">();</span> 
    <span class="n">bbox2f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">M</span><span class="p">);</span> 
    <span class="n">vec2f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec2f</span> <span class="n">min</span><span class="p">;</span>
    <span class="n">vec2f</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Axis aligned bounding box represented as a min/max vector pair.</p>
<ul>
<li>Members:<ul>
<li>bbox2f():      initializes an invalid bbox</li>
<li>bbox2f():      list constructor</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>min:      element data</li>
<li>max:      element data</li>
</ul>
</li>
</ul>
<h4>Struct bbox3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">bbox3f</span> <span class="p">{</span>
    <span class="n">bbox3f</span><span class="p">();</span> 
    <span class="n">bbox3f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">M</span><span class="p">);</span> 
    <span class="n">vec3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec3f</span> <span class="n">min</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Axis aligned bounding box represented as a min/max vector pair.</p>
<ul>
<li>Members:<ul>
<li>bbox3f():      initializes an invalid bbox</li>
<li>bbox3f():      list constructor</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>min:      element data</li>
<li>max:      element data</li>
</ul>
</li>
</ul>
<h4>Struct bbox4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">bbox4f</span> <span class="p">{</span>
    <span class="n">bbox4f</span><span class="p">();</span> 
    <span class="n">bbox4f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">M</span><span class="p">);</span> 
    <span class="n">vec4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec4f</span> <span class="n">min</span><span class="p">;</span>
    <span class="n">vec4f</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Axis aligned bounding box represented as a min/max vector pair.</p>
<ul>
<li>Members:<ul>
<li>bbox4f():      initializes an invalid bbox</li>
<li>bbox4f():      list constructor</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>min:      element data</li>
<li>max:      element data</li>
</ul>
</li>
</ul>
<h4>Constant invalid_bbox1f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">invalid_bbox1f</span> <span class="o">=</span> <span class="n">bbox1f</span><span class="p">();</span>
</code></pre></div>


<p>1-dimensional float empty bbox</p>
<h4>Constant invalid_bbox2f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">invalid_bbox2f</span> <span class="o">=</span> <span class="n">bbox2f</span><span class="p">();</span>
</code></pre></div>


<p>2-dimensional float empty bbox</p>
<h4>Constant invalid_bbox3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">invalid_bbox3f</span> <span class="o">=</span> <span class="n">bbox3f</span><span class="p">();</span>
</code></pre></div>


<p>3-dimensional float empty bbox</p>
<h4>Constant invalid_bbox4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">invalid_bbox4f</span> <span class="o">=</span> <span class="n">bbox4f</span><span class="p">();</span>
</code></pre></div>


<p>4-dimensional float empty bbox</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox1f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox1f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>bbox operator ==</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox1f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox1f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>bbox operator !=</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>bbox operator ==</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>bbox operator !=</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>bbox operator ==</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>bbox operator !=</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>bbox operator ==</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>bbox operator !=</p>
<h4>Function bbox_center()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">bbox_center</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox1f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>computes the center of a bbox</p>
<h4>Function bbox_diagonal()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">bbox_diagonal</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox1f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>computes the diagonal of a bbox</p>
<h4>Function bbox_center()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="nf">bbox_center</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>computes the center of a bbox</p>
<h4>Function bbox_diagonal()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="nf">bbox_diagonal</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>computes the diagonal of a bbox</p>
<h4>Function bbox_center()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">bbox_center</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>computes the center of a bbox</p>
<h4>Function bbox_diagonal()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">bbox_diagonal</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>computes the diagonal of a bbox</p>
<h4>Function bbox_center()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="nf">bbox_center</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>computes the center of a bbox</p>
<h4>Function bbox_diagonal()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="nf">bbox_diagonal</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>computes the diagonal of a bbox</p>
<h4>Function expand()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox1f</span> <span class="nf">expand</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox1f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>expands a bounding box with a point</p>
<h4>Function expand()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox2f</span> <span class="nf">expand</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>expands a bounding box with a point</p>
<h4>Function expand()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox3f</span> <span class="nf">expand</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>expands a bounding box with a point</p>
<h4>Function expand()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox4f</span> <span class="nf">expand</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>expands a bounding box with a point</p>
<h4>Function expand()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox1f</span> <span class="nf">expand</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox1f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox1f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>expands a bounding box with a bounding box</p>
<h4>Function expand()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox2f</span> <span class="nf">expand</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>expands a bounding box with a bounding box</p>
<h4>Function expand()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox3f</span> <span class="nf">expand</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>expands a bounding box with a bounding box</p>
<h4>Function expand()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox4f</span> <span class="nf">expand</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>expands a bounding box with a bounding box</p>
<h4>Function contains()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>check if a bounding box contains a point</p>
<h4>Function contains()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>check if a bounding box contains a bounding box</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox1f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">bbox1f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>assign to expand()</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox1f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">bbox1f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox1f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>assign to expand()</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox2f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">bbox2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>assign to expand()</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox2f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">bbox2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>assign to expand()</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>assign to expand()</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>assign to expand()</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">bbox4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>assign to expand()</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">bbox4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox4f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>assign to expand()</p>
<h4>Function make_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox1f</span> <span class="nf">make_bbox</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>initialize a bonding box from a list of points</p>
<h4>Function make_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox2f</span> <span class="nf">make_bbox</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">*</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>initialize a bonding box from a list of points</p>
<h4>Function make_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox3f</span> <span class="nf">make_bbox</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>initialize a bonding box from a list of points</p>
<h4>Function make_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox4f</span> <span class="nf">make_bbox</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">*</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>initialize a bonding box from a list of points</p>
<h4>Function make_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox3f</span> <span class="nf">make_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>initialize a bonding box from a list of points</p>
<h4>Function operator &lt; &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox1f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream write</p>
<h4>Function operator > >()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">bbox1f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream read</p>
<h4>Function operator &lt; &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream write</p>
<h4>Function operator > >()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">bbox2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream read</p>
<h4>Function operator &lt; &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream write</p>
<h4>Function operator > >()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream read</p>
<h4>Function operator &lt; &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream write</p>
<h4>Function operator > >()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">bbox4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream read</p>
<h4>Function point_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox3f</span> <span class="nf">point_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div>


<p>Point bounds</p>
<h4>Function line_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox3f</span> <span class="nf">line_bbox</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div>


<p>Line bounds</p>
<h4>Function triangle_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox3f</span> <span class="nf">triangle_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">);</span>
</code></pre></div>


<p>Triangle bounds</p>
<h4>Function quad_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox3f</span> <span class="nf">quad_bbox</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">);</span>
</code></pre></div>


<p>Quad bounds</p>
<h4>Function tetrahedron_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox3f</span> <span class="nf">tetrahedron_bbox</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">);</span>
</code></pre></div>


<p>Tetrahedron bounds</p>
<h4>Struct ray3f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">ray3f</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">float</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">o</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">d</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">tmin</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">tmax</span><span class="p">;</span>
    <span class="n">ray3f</span><span class="p">();</span> 
    <span class="n">ray3f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tmax</span> <span class="o">=</span> <span class="n">flt_max</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div>


<p>Rays with origin, direction and min/max t value.</p>
<ul>
<li>Members:<ul>
<li>N:      size</li>
<li>T:      type</li>
<li>o:      origin</li>
<li>d:      direction</li>
<li>tmin:      minimum distance</li>
<li>tmax:      maximum distance</li>
<li>ray3f():      default constructor</li>
<li>ray3f():      initializes a ray from its elements</li>
</ul>
</li>
</ul>
<h4>Function operator &lt; &lt;()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream write</p>
<h4>Function operator > >()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>stream read</p>
<h4>Function transform_point()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">transform_point</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>transforms a point by a matrix</p>
<h4>Function transform_vector()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">transform_vector</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>transforms a vector by a matrix</p>
<h4>Function transform_direction()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">transform_direction</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>transforms a direction by a matrix</p>
<h4>Function transform_point()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">transform_point</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>transforms a point by a frame (rigid affine transform)</p>
<h4>Function transform_vector()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">transform_vector</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>transforms a vector by a frame (rigid affine transform)</p>
<h4>Function transform_direction()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">transform_direction</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>transforms a direction by a frame (rigid affine transform)</p>
<h4>Function transform_frame()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">frame3f</span> <span class="nf">transform_frame</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>transforms a frame by a frame (rigid affine transform)</p>
<h4>Function transform_point_inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">transform_point_inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>inverse transforms a point by a frame (rigid affine transform)</p>
<h4>Function transform_vector_inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">transform_vector_inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>inverse transforms a vector by a frame (rigid affine transform)</p>
<h4>Function transform_direction_inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">transform_direction_inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>inverse transforms a direction by a frame (rigid affine transform)</p>
<h4>Function transform_ray()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ray3f</span> <span class="nf">transform_ray</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>transforms a ray by a matrix (direction is not normalized after)</p>
<h4>Function transform_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox3f</span> <span class="nf">transform_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>transforms a bbox by a matrix</p>
<h4>Function transform_ray()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ray3f</span> <span class="nf">transform_ray</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>transforms a ray by a frame (rigid affine transform)</p>
<h4>Function transform_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox3f</span> <span class="nf">transform_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>transforms a bbox by a frame (rigid affine transform)</p>
<h4>Function transform_ray_inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">ray3f</span> <span class="nf">transform_ray_inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>inverse transforms a ray by a frame (rigid affine transform)</p>
<h4>Function transform_bbox_inverse()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bbox3f</span> <span class="nf">transform_bbox_inverse</span><span class="p">(</span><span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>inverse transforms a bbox by a frame (rigid affine transform)</p>
<h4>Function rotation_mat3f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat3f</span> <span class="nf">rotation_mat3f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">axis</span><span class="p">,</span> <span class="kt">float</span> <span class="n">angle</span><span class="p">);</span>
</code></pre></div>


<p>rotation matrix from axis-angle</p>
<h4>Function translation_frame3f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">frame3f</span> <span class="nf">translation_frame3f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>translation frame</p>
<h4>Function translation_mat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">translation_mat4f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>translation matrix</p>
<h4>Function scaling_frame3f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">frame3f</span> <span class="nf">scaling_frame3f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>scaling frame (this is not rigid and here for symmatry of API)</p>
<h4>Function scaling_mat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">scaling_mat4f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>scaling matrix</p>
<h4>Function rotation_frame3f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">frame3f</span> <span class="nf">rotation_frame3f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">axis</span><span class="p">,</span> <span class="kt">float</span> <span class="n">angle</span><span class="p">);</span>
</code></pre></div>


<p>rotation frame</p>
<h4>Function rotation_mat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">rotation_mat4f</span><span class="p">(</span><span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">rot</span><span class="p">);</span>
</code></pre></div>


<p>rotation matrix</p>
<h4>Function rotation_mat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">rotation_mat4f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">axis</span><span class="p">,</span> <span class="kt">float</span> <span class="n">angle</span><span class="p">);</span>
</code></pre></div>


<p>rotation matrix</p>
<h4>Function rotation_axisangle4()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="nf">rotation_axisangle4</span><span class="p">(</span><span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>quaternion axis-angle conversion</p>
<h4>Function rotation_quat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">quat4f</span> <span class="nf">rotation_quat4f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">axis_angle</span><span class="p">);</span>
</code></pre></div>


<p>axis-angle to quaternion</p>
<h4>Function rotation_mat3f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat3f</span> <span class="nf">rotation_mat3f</span><span class="p">(</span><span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>quaterion to matrix conversion</p>
<h4>Function rotation_mat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">rotation_mat4f</span><span class="p">(</span><span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>rotation matrix</p>
<h4>Function rotation_quat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">quat4f</span> <span class="nf">rotation_quat4f</span><span class="p">(</span><span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">m_</span><span class="p">);</span>
</code></pre></div>


<p>matrix to quaternion</p>
<h4>Function lookat_frame3f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">frame3f</span> <span class="nf">lookat_frame3f</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">eye</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">center</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">up</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">inv_xz</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>OpenGL lookat frame</p>
<h4>Function lookat_mat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">lookat_mat4f</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">eye</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">center</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">up</span><span class="p">);</span>
</code></pre></div>


<p>OpenGL lookat matrix</p>
<h4>Function frustum_mat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">frustum_mat4f</span><span class="p">(</span>
    <span class="kt">float</span> <span class="n">l</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">,</span> <span class="kt">float</span> <span class="n">t</span><span class="p">,</span> <span class="kt">float</span> <span class="n">n</span><span class="p">,</span> <span class="kt">float</span> <span class="n">f</span><span class="p">);</span>
</code></pre></div>


<p>OpenGL frustum matrix</p>
<h4>Function ortho_mat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">ortho_mat4f</span><span class="p">(</span><span class="kt">float</span> <span class="n">l</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">,</span> <span class="kt">float</span> <span class="n">t</span><span class="p">,</span> <span class="kt">float</span> <span class="n">n</span><span class="p">,</span> <span class="kt">float</span> <span class="n">f</span><span class="p">);</span>
</code></pre></div>


<p>OpenGL orthographic matrix</p>
<h4>Function ortho2d_mat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">ortho2d_mat4f</span><span class="p">(</span><span class="kt">float</span> <span class="n">left</span><span class="p">,</span> <span class="kt">float</span> <span class="n">right</span><span class="p">,</span> <span class="kt">float</span> <span class="n">bottom</span><span class="p">,</span> <span class="kt">float</span> <span class="n">top</span><span class="p">);</span>
</code></pre></div>


<p>OpenGL orthographic 2D matrix</p>
<h4>Function ortho_mat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">ortho_mat4f</span><span class="p">(</span><span class="kt">float</span> <span class="n">xmag</span><span class="p">,</span> <span class="kt">float</span> <span class="n">ymag</span><span class="p">,</span> <span class="kt">float</span> <span class="n">near</span><span class="p">,</span> <span class="kt">float</span> <span class="n">far</span><span class="p">);</span>
</code></pre></div>


<p>OpenGL/GLTF orthographic matrix</p>
<h4>Function perspective_mat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">perspective_mat4f</span><span class="p">(</span>
    <span class="kt">float</span> <span class="n">fovy</span><span class="p">,</span> <span class="kt">float</span> <span class="n">aspect</span><span class="p">,</span> <span class="kt">float</span> <span class="n">near</span><span class="p">,</span> <span class="kt">float</span> <span class="n">far</span><span class="p">);</span>
</code></pre></div>


<p>OpenGL/GLTF perspective matrix</p>
<h4>Function perspective_mat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">perspective_mat4f</span><span class="p">(</span><span class="kt">float</span> <span class="n">fovy</span><span class="p">,</span> <span class="kt">float</span> <span class="n">aspect</span><span class="p">,</span> <span class="kt">float</span> <span class="n">near</span><span class="p">);</span>
</code></pre></div>


<p>OpenGL/GLTF infinite perspective matrix</p>
<h4>Function decompose_mat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">decompose_mat4f</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">translation</span><span class="p">,</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">scale</span><span class="p">);</span>
</code></pre></div>


<p>Decompose an affine matrix into translation, rotation, scale.
Assumes there is no shear and the matrix is affine.</p>
<h4>Function to_quat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">quat4f</span> <span class="nf">to_quat4f</span><span class="p">(</span><span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>Convert a rotation matrix to a quaternion</p>
<h4>Function decompose_mat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">decompose_mat4f</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">translation</span><span class="p">,</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">scale</span><span class="p">);</span>
</code></pre></div>


<p>Decompose an affine matrix into translation, rotation, scale.
Assumes there is no shear and the matrix is affine.</p>
<h4>Function compose_mat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">compose_mat4f</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">translation</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat3f</span><span class="o">&amp;</span> <span class="n">rotation</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">scale</span><span class="p">);</span>
</code></pre></div>


<p>Decompose an affine matrix into translation, rotation, scale.
Assumes there is no shear and the matrix is affine.</p>
<h4>Function compose_mat4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">compose_mat4f</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">translation</span><span class="p">,</span> <span class="k">const</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">rotation</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">scale</span><span class="p">);</span>
</code></pre></div>


<p>Decompose an affine matrix into translation, rotation, scale.
Assumes there is no shear and the matrix is affine.</p>
<h4>Function camera_turntable()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">camera_turntable</span><span class="p">(</span><span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">to</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">up</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">rotate</span><span class="p">,</span> <span class="kt">float</span> <span class="n">dolly</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pan</span><span class="p">);</span>
</code></pre></div>


<p>Turntable for UI navigation from a from/to/up parametrization of the
camera.</p>
<h4>Function camera_turntable()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">camera_turntable</span><span class="p">(</span><span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">frame</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">focus</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">rotate</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">dolly</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">pan</span><span class="p">);</span>
</code></pre></div>


<p>Turntable for UI navigation for a frame/distance parametrization of the
camera.</p>
<h4>Function camera_fps()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">camera_fps</span><span class="p">(</span>
    <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">frame</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">transl</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">rotate</span><span class="p">);</span>
</code></pre></div>


<p>FPS camera for UI navigation for a frame parametrization.
https://gamedev.stackexchange.com/questions/30644/how-to-keep-my-quaternion-using-fps-camera-from-tilting-and-messing-up</p>
<h4>Struct rng_pcg32</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">rng_pcg32</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">state</span> <span class="o">=</span> <span class="mh">0x853c49e6748fea9bULL</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">inc</span> <span class="o">=</span> <span class="mh">0xda3e39cb94b95bdbULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>PCG random numbers. A family of random number generators that supports
multiple sequences. In our code, we allocate one sequence for each sample.
PCG32 from http://www.pcg-random.org/</p>
<ul>
<li>Members:<ul>
<li>state:      RNG state.</li>
<li>inc:      RNG sequence. Must be odd.</li>
</ul>
</li>
</ul>
<h4>Function advance_rng()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">advance_rng</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">);</span>
</code></pre></div>


<p>Next random number</p>
<h4>Function advance_rng()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">advance_rng</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">delta</span><span class="p">);</span>
</code></pre></div>


<p>Multi-step advance function (jump-ahead, jump-back).</p>
<h4>Function advance_rng()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">advance_rng</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">delta</span><span class="p">);</span>
</code></pre></div>


<p>Multi-step advance function (jump-ahead, jump-back).</p>
<h4>Function seed_rng()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">seed_rng</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">state</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">seq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Seeds a random number generator with a state state from the sequence seq.</p>
<h4>Function init_rng()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">rng_pcg32</span> <span class="nf">init_rng</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">state</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">seq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Init a random number generator with a state state from the sequence seq.</p>
<h4>Function next_rand1i()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">next_rand1i</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">n</span><span class="p">);</span>
</code></pre></div>


<p>Next random uint in [0,n) range with proper weighting</p>
<h4>Function next_rand1f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">next_rand1f</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">);</span>
</code></pre></div>


<p>Next random float in [0,1).</p>
<h4>Function next_rand1f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">next_rand1f</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Next random float in [a,b).</p>
<h4>Function next_rand2f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="nf">next_rand2f</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">);</span>
</code></pre></div>


<p>Next random float2 in [0,1)x[0,1).</p>
<h4>Function next_rand2f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="nf">next_rand2f</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Next random float in [a.x,b.x)x[a.y,b.y).</p>
<h4>Function next_rand3f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">next_rand3f</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">);</span>
</code></pre></div>


<p>Next random float3 in [0,1)x[0,1)x[0,1).</p>
<h4>Function next_rand2f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">next_rand2f</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Next random float in [a.x,b.x)x[a.y,b.y)x[a.z,b.z).</p>
<h4>Function next_rand1d()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">double</span> <span class="nf">next_rand1d</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">);</span>
</code></pre></div>


<p>Next random double in [0, 1). Only 32 mantissa bits are filled, but still
better than float that uses 23.</p>
<h4>Function rng_distance()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int64_t</span> <span class="nf">rng_distance</span><span class="p">(</span><span class="k">const</span> <span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Distance between random number generators</p>
<h4>Function rng_shuffle()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">rng_shuffle</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">end</span><span class="p">);</span>
</code></pre></div>


<p>Random shuffle of a sequence.</p>
<h4>Function rng_shuffle()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">rng_shuffle</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">vals</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Random shuffle of a sequence.</p>
<h4>Function rng_shuffle()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">rng_shuffle</span><span class="p">(</span><span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">);</span>
</code></pre></div>


<p>Random shuffle of a sequence.</p>
<h4>Function operator==()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Equality operator</p>
<h4>Function operator!=()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">rng_pcg32</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Inequality operator</p>
<h4>Function sample_hemisphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">sample_hemisphere</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>sample hemispherical direction with uniform distribution</p>
<h4>Function sample_hemisphere_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">sample_hemisphere_pdf</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div>


<p>pdf for hemispherical direction with uniform distribution</p>
<h4>Function sample_sphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">sample_sphere</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>spherical direction with uniform distribution</p>
<h4>Function sample_sphere_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">sample_sphere_pdf</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div>


<p>pdf for spherical direction with uniform distribution</p>
<h4>Function sample_hemisphere_cosine()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">sample_hemisphere_cosine</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>hemispherical direction with cosine distribution</p>
<h4>Function sample_hemisphere_cosine_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">sample_hemisphere_cosine_pdf</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div>


<p>pdf for hemispherical direction with cosine distribution</p>
<h4>Function sample_hemisphere_cospower()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">sample_hemisphere_cospower</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">,</span> <span class="kt">float</span> <span class="n">n</span><span class="p">);</span>
</code></pre></div>


<p>hemispherical direction with cosine power distribution</p>
<h4>Function sample_hemisphere_cospower_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">sample_hemisphere_cospower_pdf</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">,</span> <span class="kt">float</span> <span class="n">n</span><span class="p">);</span>
</code></pre></div>


<p>pdf for hemispherical direction with cosine power distribution</p>
<h4>Function sample_disk()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">sample_disk</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>uniform disk</p>
<h4>Function sample_disk_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">sample_disk_pdf</span><span class="p">();</span>
</code></pre></div>


<p>pdf for uniform disk</p>
<h4>Function sample_cylinder()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">sample_cylinder</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>uniform cylinder</p>
<h4>Function sample_cylinder_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">sample_cylinder_pdf</span><span class="p">();</span>
</code></pre></div>


<p>pdf for uniform cylinder</p>
<h4>Function sample_triangle()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="nf">sample_triangle</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>uniform triangle</p>
<h4>Function sample_triangle()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">sample_triangle</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">);</span>
</code></pre></div>


<p>uniform triangle</p>
<h4>Function sample_triangle_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">sample_triangle_pdf</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">);</span>
</code></pre></div>


<p>pdf for uniform triangle (triangle area)</p>
<h4>Function sample_index()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sample_index</span><span class="p">(</span><span class="kt">float</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
</code></pre></div>


<p>index with uniform distribution</p>
<h4>Function sample_index_pdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">sample_index_pdf</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
</code></pre></div>


<p>pdf for index with uniform distribution</p>
<h4>Function hash_permute()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">hash_permute</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">);</span>
</code></pre></div>


<p>Computes the i-th term of a permutation of l values keyed by p.
From Correlated Multi-Jittered Sampling by Kensler @ Pixar</p>
<h4>Function hash_randfloat()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">hash_randfloat</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">);</span>
</code></pre></div>


<p>Computes a float value by hashing i with a key p.
From Correlated Multi-Jittered Sampling by Kensler @ Pixar</p>
<h4>Function hash_uint32()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">hash_uint32</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>32 bit integer hash. Public domain code.</p>
<h4>Function hash_uint64()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">hash_uint64</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>64 bit integer hash. Public domain code.</p>
<h4>Function hash_uint64_32()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">hash_uint64_32</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div>


<p>64-to-32 bit integer hash. Public domain code.</p>
<h4>Function hash_combine()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">hash_combine</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">a</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Combines two 64 bit hashes as in boost::hash_combine</p>
<h4>Function perlin_noise()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">float</span> <span class="nf">perlin_noise</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">zero3i</span><span class="p">);</span>
</code></pre></div>


<p>Compute the revised Pelin noise function. Wrap provides a wrapping noise
but must be power of two (wraps at 256 anyway). For octave based noise,
good values are obtained with octaves=6 (numerber of noise calls),
lacunarity=~2.0 (spacing between successive octaves: 2.0 for warpping
output), gain=0.5 (relative weighting applied to each successive octave),
offset=1.0 (used to invert the ridges).</p>
<h4>Function perlin_ridge_noise()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">float</span> <span class="nf">perlin_ridge_noise</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="kt">float</span> <span class="n">lacunarity</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">gain</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="kt">float</span> <span class="n">offset</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">octaves</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">zero3i</span><span class="p">);</span>
</code></pre></div>


<p>Ridge noise function</p>
<h4>Function perlin_fbm_noise()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">float</span> <span class="nf">perlin_fbm_noise</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="kt">float</span> <span class="n">lacunarity</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">gain</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">octaves</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">zero3i</span><span class="p">);</span>
</code></pre></div>


<p>Fractal brownian motion noise - see perlin_noise() for params.</p>
<h4>Function perlin_turbulence_noise()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">float</span> <span class="nf">perlin_turbulence_noise</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="kt">float</span> <span class="n">lacunarity</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">gain</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">octaves</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">zero3i</span><span class="p">);</span>
</code></pre></div>


<p>Fractal turbulence noise - see perlin_noise() for params.</p>
<h4>Function range()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">range_generator</span> <span class="nf">range</span><span class="p">(</span><span class="kt">int</span> <span class="n">max</span><span class="p">);</span>
</code></pre></div>


<p>Python-like range</p>
<h4>Function range()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">range_generator</span> <span class="nf">range</span><span class="p">(</span><span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">,</span> <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Python-like range</p>
<h4>Function enumerate()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">enumerate_generator</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">enumerate</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Python-like range</p>
<h4>Function enumerate()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">enumerate_generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">enumerate</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Python-like range</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Append an element to a vector</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Append an element to a vector</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ET</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">ET</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Append an element to a vector</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ET</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">ET</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Append an element to a vector</p>
<h4>Function operator+()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Append a vector to a vector</p>
<h4>Function operator+=()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Append a vector to a vector</p>
<h4>Function get_key()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">K</span> <span class="n">get_key</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;&amp;</span> <span class="n">kvs</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>Get a key</p>
<h4>Function get_value()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">V</span> <span class="n">get_value</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;&amp;</span> <span class="n">kvs</span><span class="p">,</span> <span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
</code></pre></div>


<p>Get a value</p>
<h4>Function find_idx()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="n">find_idx</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Find a value in an array</p>
<h4>Function contains()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Checks if a containers contains a value</p>
<h4>Function contains()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Checks if a containers contains a value</p>
<h4>Function contains()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">K</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">vv</span><span class="p">);</span>
</code></pre></div>


<p>Checks if a containers contains a value</p>
<h4>Function line_tangent()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">line_tangent</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">);</span>
</code></pre></div>


<p>line tangent</p>
<h4>Function line_length()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">line_length</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">);</span>
</code></pre></div>


<p>line length</p>
<h4>Function triangle_normal()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">triangle_normal</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">);</span>
</code></pre></div>


<p>triangle normal</p>
<h4>Function triangle_area()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">triangle_area</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">);</span>
</code></pre></div>


<p>triangle area</p>
<h4>Function quad_area()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">quad_area</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">);</span>
</code></pre></div>


<p>quad area</p>
<h4>Function tetrahedron_volume()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">tetrahedron_volume</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">);</span>
</code></pre></div>


<p>tetrahedron volume</p>
<h4>Function eval_barycentric_point()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">eval_barycentric_point</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="kt">float</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div>


<p>line barycentric interpolation</p>
<h4>Function eval_barycentric_line()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">eval_barycentric_line</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div>


<p>line barycentric interpolation</p>
<h4>Function eval_barycentric_triangle()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">eval_barycentric_triangle</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div>


<p>triangle barycentric interpolation</p>
<h4>Function eval_barycentric_tetra()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">eval_barycentric_tetra</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div>


<p>tetrahedron barycentric interpolation</p>
<h4>Function eval_barycentric_quad()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">eval_barycentric_quad</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div>


<p>quad interpolation based on the two-triangle representation</p>
<h4>Function eval_bernstein()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">eval_bernstein</span><span class="p">(</span><span class="n">T</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degree</span><span class="p">);</span>
</code></pre></div>


<p>bernstein polynomials (for Bezier)</p>
<h4>Function eval_bernstein_derivative()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">eval_bernstein_derivative</span><span class="p">(</span><span class="n">T</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degree</span><span class="p">);</span>
</code></pre></div>


<p>bernstein polynomials (for Bezier)</p>
<h4>Function eval_bezier_cubic()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">eval_bezier_cubic</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">,</span> <span class="n">T1</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div>


<p>eval bezier</p>
<h4>Function eval_bezier_cubic()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">eval_bezier_cubic</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">T1</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div>


<p>eval bezier</p>
<h4>Function eval_bezier_cubic_derivative()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">eval_bezier_cubic_derivative</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">,</span> <span class="n">T1</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div>


<p>eval bezier derivative</p>
<h4>Function eval_bezier_cubic_derivative()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">eval_bezier_cubic_derivative</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">T1</span> <span class="n">t</span><span class="p">);</span>
</code></pre></div>


<p>eval bezier derivative</p>
<h4>Function compute_normals()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">compute_normals</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">weighted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Compute per-vertex normals/tangents for lines, triangles and quads with
positions pos. Weighted indicated whether the normals/tangents are
weighted by line length.</p>
<h4>Function compute_tangent_frames()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;</span> <span class="n">compute_tangent_frames</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">weighted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Compute per-vertex tangent frame for triangle meshes.
Tangent space is defined by a four component vector.
The first three components are the tangent with respect to the U texcoord.
The fourth component is the sign of the tangent wrt the V texcoord.
Tangent frame is useful in normal mapping.</p>
<h4>Function compute_skinning()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">compute_skinning</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">weights</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">joints</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">mat4f</span><span class="o">&gt;&amp;</span> <span class="n">xforms</span><span class="p">,</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">skinned_pos</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">skinned_norm</span><span class="p">);</span>
</code></pre></div>


<p>Apply skinning</p>
<h4>Function compute_skinning()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">compute_skinning</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">weights</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">joints</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">frame3f</span><span class="o">&gt;&amp;</span> <span class="n">xforms</span><span class="p">,</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">skinned_pos</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">skinned_norm</span><span class="p">);</span>
</code></pre></div>


<p>Apply skinning</p>
<h4>Function compute_matrix_skinning()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">compute_matrix_skinning</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">weights</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">joints</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">mat4f</span><span class="o">&gt;&amp;</span> <span class="n">xforms</span><span class="p">,</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">skinned_pos</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">skinned_norm</span><span class="p">);</span>
</code></pre></div>


<p>Apply skinning as specified in Khronos glTF</p>
<h4>Function get_edges()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;</span> <span class="n">get_edges</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">);</span>
</code></pre></div>


<p>Create an array of edges.</p>
<h4>Function get_boundary_edges()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;</span> <span class="n">get_boundary_edges</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">);</span>
</code></pre></div>


<p>Create an array of boundary edges. Lines are always considered boundaries.</p>
<h4>Function get_verts()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">get_verts</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">);</span>
</code></pre></div>


<p>Get a list of all unique vertices.</p>
<h4>Function get_boundary_verts()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">get_boundary_verts</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">);</span>
</code></pre></div>


<p>Create an array of boundary vertices. Lines are always considered
boundaries.</p>
<h4>Function convert_quads_to_triangles()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span> <span class="n">convert_quads_to_triangles</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">);</span>
</code></pre></div>


<p>Convert quads to triangles</p>
<h4>Function convert_quads_to_triangles()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span> <span class="n">convert_quads_to_triangles</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row_length</span><span class="p">);</span>
</code></pre></div>


<p>Convert quads to triangles with a diamond-like topology.
Quads have to be consecutive one row after another.</p>
<h4>Function convert_face_varying()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&gt;</span>
<span class="n">convert_face_varying</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads_pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads_norm</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads_texcoord</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">);</span>
</code></pre></div>


<p>Convert face varying data to single primitives. Returns the quads indices
and filled vectors for pos, norm and texcoord.</p>
<h4>Function subdivide_elems()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&gt;</span>
<span class="n">subdivide_elems</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nverts</span><span class="p">);</span>
</code></pre></div>


<p>Tesselate lines, triangles and quads by spolitting edges.
Returns the tesselated elements and dictionaries for vertex calculations.</p>
<h4>Function subdivide_vert()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">subdivide_vert</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vert</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">edges</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">faces</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">normalized</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Subdivide vertex properties given the maps</p>
<h4>Function subdivide_catmullclark()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">subdivide_catmullclark</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vert</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">crease_tlines</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">crease_tpoints</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">normalized</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Performs the smoothing step of Catmull-Clark. Start with a tesselate quad
mesh obtained with subdivide_elems() and subdivide_vert(). To handle open
meshes with boundary, get the boundary from make_boundary_edge() and pass it
as crease_lines. To fix the boundary entirely, just get the boundary
vertices and pass it as creases.</p>
<h4>Function make_uvquads()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&gt;</span> <span class="n">make_uvquads</span><span class="p">(</span><span class="kt">int</span> <span class="n">usteps</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vsteps</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">uwrap</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">vwrap</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">vpole0</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">vpole1</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Generate a rectangular grid of usteps x vsteps uv values for parametric
surface generation.</p>
<h4>Function make_uvlines()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&gt;</span> <span class="n">make_uvlines</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">usteps</span><span class="p">);</span>
</code></pre></div>


<p>Generate parametric num lines of usteps segments.</p>
<h4>Function make_uvpoints()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&gt;</span> <span class="n">make_uvpoints</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Generate a parametric point set. Mostly here for completeness.</p>
<h4>Function merge_elems()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&gt;</span> <span class="n">merge_elems</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">nverts</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines2</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles2</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads2</span><span class="p">);</span>
</code></pre></div>


<p>Merge elements between shapes. The elements are merged by increasing the
array size of the second array by the number of vertices of the first.
Vertex data can then be concatenated successfully.</p>
<h4>Function facet_elems()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span>
<span class="n">facet_elems</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">);</span>
</code></pre></div>


<p>Unshare shape data by duplicating all vertex data for each element,
giving a faceted look. Note that faceted tangents are not computed.</p>
<h4>Function facet_vert()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">facet_vert</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vert</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vmap</span><span class="p">);</span>
</code></pre></div>


<p>Unshare vertices for faceting</p>
<h4>Function sample_points()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sample_points</span><span class="p">(</span><span class="kt">int</span> <span class="n">npoints</span><span class="p">,</span> <span class="kt">float</span> <span class="n">re</span><span class="p">);</span>
</code></pre></div>


<p>Pick a point</p>
<h4>Function sample_points_cdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">sample_points_cdf</span><span class="p">(</span><span class="kt">int</span> <span class="n">npoints</span><span class="p">);</span>
</code></pre></div>


<p>Compute a distribution for sampling points uniformly</p>
<h4>Function sample_points()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sample_points</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">cdf</span><span class="p">,</span> <span class="kt">float</span> <span class="n">re</span><span class="p">);</span>
</code></pre></div>


<p>Pick a point</p>
<h4>Function sample_lines_cdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">sample_lines_cdf</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">);</span>
</code></pre></div>


<p>Compute a distribution for sampling lines uniformly</p>
<h4>Function sample_lines()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&gt;</span> <span class="n">sample_lines</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">cdf</span><span class="p">,</span> <span class="kt">float</span> <span class="n">re</span><span class="p">,</span> <span class="kt">float</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>Pick a point on lines</p>
<h4>Function sample_triangles_cdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">sample_triangles_cdf</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">);</span>
</code></pre></div>


<p>Compute a distribution for sampling triangle meshes uniformly</p>
<h4>Function sample_triangles()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">sample_triangles</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">cdf</span><span class="p">,</span> <span class="kt">float</span> <span class="n">re</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>Pick a point on a triangle mesh</p>
<h4>Function sample_quads_cdf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">sample_quads_cdf</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">);</span>
</code></pre></div>


<p>Compute a distribution for sampling quad meshes uniformly</p>
<h4>Function sample_quads()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">&gt;</span> <span class="n">sample_quads</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">cdf</span><span class="p">,</span> <span class="kt">float</span> <span class="n">re</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">ruv</span><span class="p">);</span>
</code></pre></div>


<p>Pick a point on a quad mesh</p>
<h4>Function sample_triangles_points()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&gt;</span>
<span class="n">sample_triangles_points</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">norm</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="kt">int</span> <span class="n">npoints</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div>


<p>Samples a set of points over a triangle mesh uniformly. The rng function
takes the point index and returns vec3f numbers uniform directibuted in
[0,1]^3. unorm and texcoord are optional.</p>
<h4>Function make_sphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&gt;</span> <span class="n">make_sphere</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">);</span>
</code></pre></div>


<p>Make a sphere. Returns quads, pos.</p>
<h4>Function make_geodesicsphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&gt;</span> <span class="n">make_geodesicsphere</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">);</span>
</code></pre></div>


<p>Make a geodesic sphere. Returns quads, pos.</p>
<h4>Function make_cube()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&gt;</span> <span class="n">make_cube</span><span class="p">();</span>
</code></pre></div>


<p>Make a cube with unique vertices. This is watertight but has no
texture coordinates or normals. Returns quads, pos.</p>
<h4>Function make_uvsphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&gt;</span> <span class="n">make_uvsphere</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flipped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Make a sphere. This is not watertight. Returns quads, pos, norm, texcoord.</p>
<h4>Function make_uvhemisphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&gt;</span>
<span class="n">make_uvhemisphere</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flipped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Make a sphere. This is not watertight. Returns quads, pos, norm, texcoord.</p>
<h4>Function make_uvquad()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&gt;</span> <span class="n">make_uvquad</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">level</span><span class="p">);</span>
</code></pre></div>


<p>Make a quad. Returns quads, pos, norm, texcoord.</p>
<h4>Function make_fvsphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&gt;</span>
<span class="n">make_fvsphere</span><span class="p">();</span>
</code></pre></div>


<p>Make a facevarying sphere with unique vertices but different texture
coordinates. Returns (quads, pos), (quads, norm), (quads, texcoord).</p>
<h4>Function make_fvcube()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&gt;</span>
<span class="n">make_fvcube</span><span class="p">();</span>
</code></pre></div>


<p>Make a facevarying cube with unique vertices but different texture
coordinates. Returns (quads, pos), (quads, norm), (quads, texcoord).</p>
<h4>Function make_suzanne()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&gt;</span> <span class="n">make_suzanne</span><span class="p">();</span>
</code></pre></div>


<p>Make a suzanne monkey model for testing. Note that some quads are
degenerate. Returns quads, pos.</p>
<h4>Function make_uvcube()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&gt;</span> <span class="n">make_uvcube</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">level</span><span class="p">);</span>
</code></pre></div>


<p>Make a cube with uv. This is not watertight. Returns quads, pos, norm,
texcoord.</p>
<h4>Function make_uvspherecube()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&gt;</span>
<span class="n">make_uvspherecube</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">);</span>
</code></pre></div>


<p>Make a sphere from a cube. This is not watertight. Returns quads, pos, norm,
texcoord.</p>
<h4>Function make_uvspherizedcube()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&gt;</span>
<span class="n">make_uvspherizedcube</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Make a cube than stretch it towards a sphere. This is not watertight.
Returns quads, pos, norm, texcoord.</p>
<h4>Function make_uvflipcapsphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&gt;</span>
<span class="n">make_uvflipcapsphere</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">float</span> <span class="n">z</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flipped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Make a flipped sphere. This is not watertight. Returns quads, pos, norm,
texcoord.</p>
<h4>Function make_uvcutsphere()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&gt;</span>
<span class="n">make_uvcutsphere</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">float</span> <span class="n">z</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flipped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Make a cutout sphere. This is not watertight. Returns quads, pos, norm,
texcoord.</p>
<h4>Function make_hair()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&gt;</span>
<span class="n">make_hair</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">rad</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">striangles</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">squads</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">spos</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">snorm</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">stexcoord</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">noise</span> <span class="o">=</span> <span class="n">zero2f</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">clump</span> <span class="o">=</span> <span class="n">zero2f</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">rotation</span> <span class="o">=</span> <span class="n">zero2f</span><span class="p">,</span>
    <span class="kt">uint32_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div>


<p>Make a hair ball around a shape. Returns lines, pos, norm, texcoord, radius.</p>
<h4>Struct image4f</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">image4f</span> <span class="p">{</span>
    <span class="n">image4f</span><span class="p">();</span> 
    <span class="n">image4f</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">zero4f</span><span class="p">);</span> 
    <span class="n">image4f</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">*</span> <span class="n">v</span><span class="p">);</span> 
    <span class="kt">int</span> <span class="nf">width</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="nf">height</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec2i</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">zero4f</span><span class="p">);</span> 
    <span class="kt">void</span> <span class="nf">assign</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span> 
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span> 
    <span class="n">vec4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">ij</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">ij</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">ij</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">ij</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec4f</span><span class="o">*</span> <span class="nf">data</span><span class="p">();</span> 
    <span class="k">const</span> <span class="n">vec4f</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>HDR image</p>
<ul>
<li>Members:<ul>
<li>image4f():      empty image constructor</li>
<li>image4f():      image constructor</li>
<li>image4f():      image constructor</li>
<li>width():      width</li>
<li>height():      height</li>
<li>size():      size</li>
<li>empty():      check for empty</li>
<li>operator bool():      check for empty</li>
<li>resize():      reallocate memory</li>
<li>assign():      reallocate memory</li>
<li>set():      set values</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>at():      element access</li>
<li>at():      element access</li>
<li>at():      element access</li>
<li>at():      element access</li>
<li>data():      data access</li>
<li>data():      data access</li>
</ul>
</li>
</ul>
<h4>Struct image4b</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">image4b</span> <span class="p">{</span>
    <span class="n">image4b</span><span class="p">();</span> 
    <span class="n">image4b</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">zero4b</span><span class="p">);</span> 
    <span class="n">image4b</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4b</span><span class="o">*</span> <span class="n">v</span><span class="p">);</span> 
    <span class="kt">int</span> <span class="nf">width</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="nf">height</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec2i</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">zero4b</span><span class="p">);</span> 
    <span class="kt">void</span> <span class="nf">assign</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span> 
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span> 
    <span class="n">vec4b</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">ij</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">ij</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">ij</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">ij</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">);</span> 
    <span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec4b</span><span class="o">*</span> <span class="nf">data</span><span class="p">();</span> 
    <span class="k">const</span> <span class="n">vec4b</span><span class="o">*</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>LDR image</p>
<ul>
<li>Members:<ul>
<li>image4b():      empty image constructor</li>
<li>image4b():      image constructor</li>
<li>image4b():      image constructor</li>
<li>width():      width</li>
<li>height():      height</li>
<li>size():      size</li>
<li>empty():      check for empty</li>
<li>operator bool():      check for empty</li>
<li>resize():      reallocate memory</li>
<li>assign():      reallocate memory</li>
<li>set():      set values</li>
<li>operator<a href=""></a>:      element access</li>
<li>operator<a href=""></a>:      element access</li>
<li>at():      element access</li>
<li>at():      element access</li>
<li>at():      element access</li>
<li>at():      element access</li>
<li>data():      data access</li>
<li>data():      data access</li>
</ul>
</li>
</ul>
<h4>Function srgb_to_linear()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">srgb_to_linear</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3b</span><span class="o">&amp;</span> <span class="n">srgb</span><span class="p">);</span>
</code></pre></div>


<p>Approximate conversion from srgb.</p>
<h4>Function srgb_to_linear()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="nf">srgb_to_linear</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">srgb</span><span class="p">);</span>
</code></pre></div>


<p>Approximate conversion from srgb.</p>
<h4>Function linear_to_srgb()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3b</span> <span class="nf">linear_to_srgb</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">lin</span><span class="p">);</span>
</code></pre></div>


<p>Approximate conversion to srgb.</p>
<h4>Function linear_to_srgb()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4b</span> <span class="nf">linear_to_srgb</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">lin</span><span class="p">);</span>
</code></pre></div>


<p>Approximate conversion to srgb.</p>
<h4>Function xyz_to_xyY()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">xyz_to_xyY</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">xyz</span><span class="p">);</span>
</code></pre></div>


<p>Convert between CIE XYZ and xyY</p>
<h4>Function xyY_to_xyz()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">xyY_to_xyz</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">xyY</span><span class="p">);</span>
</code></pre></div>


<p>Convert between CIE XYZ and xyY</p>
<h4>Function xyz_to_rgb()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">xyz_to_rgb</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">xyz</span><span class="p">);</span>
</code></pre></div>


<p>Convert between CIE XYZ and RGB</p>
<h4>Function rgb_to_xyz()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">rgb_to_xyz</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">rgb</span><span class="p">);</span>
</code></pre></div>


<p>Convert between CIE XYZ and RGB</p>
<h4>Function tonemap_filmic()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">float</span> <span class="nf">tonemap_filmic</span><span class="p">(</span><span class="kt">float</span> <span class="n">hdr</span><span class="p">);</span>
</code></pre></div>


<p>Tone map with a fitted filmic curve.</p>
<p>Implementation from
https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/</p>
<h4>Function tonemap_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">image4b</span> <span class="nf">tonemap_image</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">hdr</span><span class="p">,</span> <span class="kt">float</span> <span class="n">exposure</span><span class="p">,</span> <span class="kt">float</span> <span class="n">gamma</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">filmic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Tone mapping HDR to LDR images.</p>
<h4>Function image_over()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">image_over</span><span class="p">(</span>
    <span class="n">vec4f</span><span class="o">*</span> <span class="n">img</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nlayers</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">**</span> <span class="n">layers</span><span class="p">);</span>
</code></pre></div>


<p>Image over operator</p>
<h4>Function image_over()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">image_over</span><span class="p">(</span>
    <span class="n">vec4b</span><span class="o">*</span> <span class="n">img</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nlayers</span><span class="p">,</span> <span class="n">vec4b</span><span class="o">**</span> <span class="n">layers</span><span class="p">);</span>
</code></pre></div>


<p>Image over operator</p>
<h4>Function hsv_to_rgb()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4b</span> <span class="nf">hsv_to_rgb</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">hsv</span><span class="p">);</span>
</code></pre></div>


<p>Convert HSV to RGB</p>
<p>Implementatkion from
http://stackoverflow.com/questions/3018313/algorithm-to-convert-rgb-to-hsv-and-hsv-to-rgb-in-range-0-255-for-both</p>
<h4>Function make_grid_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">image4b</span> <span class="n">make_grid_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tile</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">c0</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Make a grid image</p>
<h4>Function make_checker_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">image4b</span> <span class="n">make_checker_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tile</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">c0</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Make a checkerboard image</p>
<h4>Function make_bumpdimple_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">image4b</span> <span class="nf">make_bumpdimple_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tile</span> <span class="o">=</span> <span class="mi">64</span><span class="p">);</span>
</code></pre></div>


<p>Make an image with bumps and dimples.</p>
<h4>Function make_ramp_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">image4b</span> <span class="nf">make_ramp_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">c0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">srgb</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Make a uv colored grid</p>
<h4>Function make_gammaramp_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">image4b</span> <span class="nf">make_gammaramp_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">);</span>
</code></pre></div>


<p>Make a gamma ramp image</p>
<h4>Function make_gammaramp_imagef()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">image4f</span> <span class="nf">make_gammaramp_imagef</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">);</span>
</code></pre></div>


<p>Make a gamma ramp image</p>
<h4>Function make_uv_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">image4b</span> <span class="nf">make_uv_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">);</span>
</code></pre></div>


<p>Make an image color with red/green in the [0,1] range. Helpful to visualize
uv texture coordinate application.</p>
<h4>Function make_uvgrid_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">image4b</span> <span class="nf">make_uvgrid_image</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tile</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">colored</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Make a uv colored grid</p>
<h4>Function make_recuvgrid_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">image4b</span> <span class="nf">make_recuvgrid_image</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tile</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">colored</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Make a uv recusive colored grid</p>
<h4>Function bump_to_normal_map()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">image4b</span> <span class="nf">bump_to_normal_map</span><span class="p">(</span><span class="k">const</span> <span class="n">image4b</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Comvert a bump map to a normal map.</p>
<h4>Function make_sunsky_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4f</span> <span class="nf">make_sunsky_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">res</span><span class="p">,</span> <span class="kt">float</span> <span class="n">thetaSun</span><span class="p">,</span> <span class="kt">float</span> <span class="n">turbidity</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">has_sun</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">has_ground</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Make a sunsky HDR model with sun at theta elevation in [0,pi/2], turbidity
in [1.7,10] with or without sun.</p>
<h4>Function make_noise_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">make_noise_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">resx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resy</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">wrap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Compute the revised Pelin noise function. Wrap provides a wrapping noise
but must be power of two (wraps at 256 anyway). For octave based noise,
good values are obtained with octaves=6 (numerber of noise calls),
lacunarity=~2.0 (spacing between successive octaves: 2.0 for warpping
output), gain=0.5 (relative weighting applied to each successive octave),
offset=1.0 (used to invert the ridges).
Make a noise image. Wrap works only if both resx and resy are powers of two.</p>
<h4>Function make_fbm_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">make_fbm_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">resx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resy</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">lacunarity</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">gain</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">octaves</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">wrap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Make a noise image. Wrap works only if both resx and resy are powers of two.</p>
<h4>Function make_ridge_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">make_ridge_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">resx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resy</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">lacunarity</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">gain</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="kt">float</span> <span class="n">offset</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">octaves</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">wrap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Make a noise image. Wrap works only if both resx and resy are powers of two.</p>
<h4>Function make_turbulence_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">make_turbulence_image</span><span class="p">(</span><span class="kt">int</span> <span class="n">resx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resy</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">lacunarity</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">gain</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">octaves</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">wrap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Make a noise image. Wrap works only if both resx and resy are powers of two.</p>
<h4>Function is_hdr_filename()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">is_hdr_filename</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Check if an image is HDR based on filename</p>
<h4>Function load_image4b()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4b</span> <span class="nf">load_image4b</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Loads an ldr image.</p>
<h4>Function load_image4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">image4f</span> <span class="nf">load_image4f</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Loads an hdr image.</p>
<h4>Function save_image4b()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">save_image4b</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">image4b</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">);</span>
</code></pre></div>


<p>Saves an ldr image.</p>
<h4>Function save_image4f()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">save_image4f</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">);</span>
</code></pre></div>


<p>Saves an hdr image.</p>
<h4>Function load_imagef()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">load_imagef</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ncomp</span><span class="p">);</span>
</code></pre></div>


<p>Loads an image</p>
<h4>Function load_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">byte</span><span class="o">&gt;</span> <span class="n">load_image</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ncomp</span><span class="p">);</span>
</code></pre></div>


<p>Loads an image</p>
<h4>Function load_imagef_from_memory()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">load_imagef_from_memory</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">byte</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ncomp</span><span class="p">);</span>
</code></pre></div>


<p>Loads an image from memory.</p>
<h4>Function load_image_from_memory()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">byte</span><span class="o">&gt;</span> <span class="n">load_image_from_memory</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">byte</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ncomp</span><span class="p">);</span>
</code></pre></div>


<p>Loads an image from memory.</p>
<h4>Function save_imagef()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">save_imagef</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">hdr</span><span class="p">);</span>
</code></pre></div>


<p>Saves an image</p>
<h4>Function save_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">save_image</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span> <span class="k">const</span> <span class="n">byte</span><span class="o">*</span> <span class="n">ldr</span><span class="p">);</span>
</code></pre></div>


<p>Saves an image</p>
<h4>Function save_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">save_image</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">hdr</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">exposure</span><span class="p">,</span> <span class="kt">float</span> <span class="n">gamma</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">filmic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Save an HDR or LDR image with tonemapping based on filename</p>
<h4>Enum resize_filter</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">resize_filter</span> <span class="p">{</span>
    <span class="n">def</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">box</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">triangle</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">cubic_spline</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">catmull_rom</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">mitchell</span> <span class="o">=</span> <span class="mi">5</span>

<span class="p">}</span>
</code></pre></div>


<p>Filter for resizing</p>
<ul>
<li>Values:<ul>
<li>def:      default</li>
<li>box:      box filter</li>
<li>triangle:      triangle filter</li>
<li>cubic_spline:      cubic spline</li>
<li>catmull_rom:      Catmull-Rom interpolating sline</li>
<li>mitchell:      Mitchel-Netrevalli filter with B=1/3, C=1/3</li>
</ul>
</li>
</ul>
<h4>Enum resize_edge</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">resize_edge</span> <span class="p">{</span>
    <span class="n">def</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">clamp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">reflect</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">wrap</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="mi">4</span>

<span class="p">}</span>
</code></pre></div>


<p>Edge mode for resizing</p>
<ul>
<li>Values:<ul>
<li>def:      default</li>
<li>clamp:      clamp</li>
<li>reflect:      reflect</li>
<li>wrap:      wrap</li>
<li>zero:      zero</li>
</ul>
</li>
</ul>
<h4>Function resize_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">resize_image</span><span class="p">(</span><span class="k">const</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">res_img</span><span class="p">,</span>
    <span class="n">resize_filter</span> <span class="n">filter</span> <span class="o">=</span> <span class="n">resize_filter</span><span class="o">::</span><span class="n">def</span><span class="p">,</span>
    <span class="n">resize_edge</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">resize_edge</span><span class="o">::</span><span class="n">def</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">premultiplied_alpha</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Resize image.</p>
<h4>Function resize_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">resize_image</span><span class="p">(</span><span class="k">const</span> <span class="n">image4b</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="n">image4b</span><span class="o">&amp;</span> <span class="n">res_img</span><span class="p">,</span>
    <span class="n">resize_filter</span> <span class="n">filter</span> <span class="o">=</span> <span class="n">resize_filter</span><span class="o">::</span><span class="n">def</span><span class="p">,</span>
    <span class="n">resize_edge</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">resize_edge</span><span class="o">::</span><span class="n">def</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">premultiplied_alpha</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Resize image.</p>
<h4>Function intersect_point()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_point</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a ray with a point (approximate)</p>
<p>Parameters:
- ray: ray origin and direction, parameter min, max range
- p: point position
- r: point radius</p>
<p>Out Parameters:
- ray_t: ray parameter at the intersection point
- euv: primitive uv ( {0,0} for points )</p>
<p>Returns:
- whether the intersection occurred</p>
<p>Iplementation Notes:
- out Parameters and only writtent o if an intersection occurs
- algorithm finds the closest point on the ray segment to the point and
   test their distance with the point radius
- based on http://geomalgorithms.com/a02-lines.html.</p>
<h4>Function intersect_line()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_line</span><span class="p">(</span><span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">r0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r1</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a ray with a line</p>
<p>Parameters:
- ray: ray origin and direction, parameter min, max range
- v0, v1: line segment points
- r0, r1: line segment radia</p>
<p>Out Parameters:
- ray_t: ray parameter at the intersection point
- euv: euv.x is the line parameter at the intersection ( euv.y is zero )</p>
<p>Returns:
- whether the intersection occurred</p>
<p>Notes:
- out Parameters and only writtent o if an intersection occurs
- algorithm find the closest points on line and ray segment and test
  their distance with the line radius at that location
- based on http://geomalgorithms.com/a05-intersect-1.html
- based on http://geomalgorithms.com/a07-distance.html#
    dist3D_Segment_to_Segment</p>
<h4>Function intersect_triangle()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_triangle</span><span class="p">(</span><span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a ray with a triangle</p>
<p>Parameters:
- ray: ray origin and direction, parameter min, max range
- v0, v1, v2: triangle vertices</p>
<p>Out Parameters:
- ray_t: ray parameter at the intersection point
- euv: baricentric coordinates of the intersection</p>
<p>Returns:
- whether the intersection occurred</p>
<p>Notes:
- out Parameters and only writtent o if an intersection occurs
- algorithm based on Muller-Trombone intersection test</p>
<h4>Function intersect_quad()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_quad</span><span class="p">(</span><span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a ray with a quad represented as two triangles (0,1,3) and
(2,3,1), with the uv coordinates of the second triangle corrected by u =
1-u' and v = 1-v' to produce a quad parametrization where u and v go from 0
to 1. This is equivalent to Intel's Embree. The external user does not have
to be concerned about the parametrization and can just use the euv as
specified.</p>
<p>Parameters:
- ray: ray origin and direction, parameter min, max range
- v0, v1, v2, v3: quad vertices</p>
<p>Out Parameters:
- ray_t: ray parameter at the intersection point
- euv: baricentric coordinates of the intersection</p>
<p>Returns:
- whether the intersection occurred</p>
<h4>Function intersect_tetrahedron()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_tetrahedron</span><span class="p">(</span><span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray_</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span>
    <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a ray with a tetrahedron. Note that we consider only
intersection wiht the tetrahedra surface and discount intersction with
the interior.</p>
<p>Parameters:
- ray: ray to intersect with
- v0, v1, v2: triangle vertices</p>
<p>Out Parameters:
- ray_t: ray parameter at the intersection point
- euv: baricentric coordinates of the intersection</p>
<p>Returns:
- whether the intersection occurred</p>
<p>TODO: check order
TODO: uv</p>
<h4>Function intersect_check_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_check_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">bbox</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a ray with a axis-aligned bounding box</p>
<p>Parameters:
- ray: ray to intersect with
- bbox: bounding box min/max bounds</p>
<p>Returns:
- whether the intersection occurred</p>
<h4>Function _safemin()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">_safemin</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Min/max used in BVH traversal. Copied here since the traversal code
relies on the specific behaviour wrt NaNs.</p>
<h4>Function _safemax()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">_safemax</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>


<p>Min/max used in BVH traversal. Copied here since the traversal code
relies on the specific behaviour wrt NaNs.</p>
<h4>Function intersect_check_bbox()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_check_bbox</span><span class="p">(</span><span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ray_dinv</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">ray_dsign</span><span class="p">,</span> <span class="k">const</span> <span class="n">bbox3f</span><span class="o">&amp;</span> <span class="n">bbox_</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a ray with a axis-aligned bounding box</p>
<p>Parameters:
- ray_o, ray_d: ray origin and direction
- ray_tmin, ray_tmax: ray parameter min, max range
- ray_dinv: ray inverse direction
- ray_dsign: ray direction sign
- bbox_min, bbox_max: bounding box min/max bounds</p>
<p>Returns:
- whether the intersection occurred</p>
<p>Implementation Notes:
- based on "Robust BVH Ray Traversal" by T. Ize published at
http://jcgt.org/published/0002/02/02/paper.pdf</p>
<h4>Struct bvh_node</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">bvh_node</span> <span class="p">{</span>
    <span class="n">bbox3f</span> <span class="n">bbox</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">count</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">isleaf</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">axis</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>BVH tree node containing its bounds, indices to the BVH arrays of either
sorted primitives or internal nodes, whether its a leaf or an internal node,
and the split axis. Leaf and internal nodes are identical, except that
indices refer to primitives for leaf nodes or other nodes for internal
nodes. See bvh_tree for more details.</p>
<p>This is an internal data structure.</p>
<ul>
<li>Members:<ul>
<li>bbox:      bounding box</li>
<li>start:      index to the first sorted primitive/node</li>
<li>count:      number of primitives/nodes</li>
<li>isleaf:      whether it is a leaf</li>
<li>axis:      slit axis</li>
</ul>
</li>
</ul>
<h4>Struct bvh_tree</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">bvh_tree</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">bvh_node</span><span class="o">&gt;</span> <span class="n">nodes</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sorted_prim</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>BVH tree, stored as a node array. The tree structure is encoded using array
indices instead of pointers, both for speed but also to simplify code.
BVH nodes indices refer to either the node array, for internal nodes,
or a primitive array, for leaf nodes. BVH trees may contain only one type
of geometric primitive, like points, lines, triangle or shape other BVHs.
To handle multiple primitive types and transformed primitices, build
a two-level hierarchy with the outer BVH, the scene BVH, containing inner
BVHs, shape BVHs, each of which of a uniform primitive type.</p>
<p>This is an internal data structure.</p>
<ul>
<li>Members:<ul>
<li>nodes:      sorted array of internal nodes</li>
<li>sorted_prim:      sorted elements</li>
</ul>
</li>
</ul>
<h4>Function build_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="nf">build_bvh</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">nprims</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">equalsize</span><span class="p">,</span> <span class="k">const</span> <span class="n">function</span><span class="o">&lt;</span><span class="n">bbox3f</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&amp;</span> <span class="n">elem_bbox</span><span class="p">);</span>
</code></pre></div>


<p>Build a BVH from a set of primitives.</p>
<h4>Function build_triangles_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="nf">build_triangles_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">equal_size</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Build a triangles BVH.</p>
<h4>Function build_quads_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="nf">build_quads_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">equal_size</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Build a quads BVH.</p>
<h4>Function build_lines_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="nf">build_lines_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">equal_size</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Build a lines BVH.</p>
<h4>Function build_points_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="nf">build_points_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">points</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">equal_size</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Build a points BVH.</p>
<h4>Function build_points_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="nf">build_points_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">equal_size</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Build a points BVH.</p>
<h4>Function refit_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">refit_bvh</span><span class="p">(</span>
    <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">,</span> <span class="k">const</span> <span class="n">function</span><span class="o">&lt;</span><span class="n">bbox3f</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&amp;</span> <span class="n">elem_bbox</span><span class="p">);</span>
</code></pre></div>


<p>Recursively recomputes the node bounds for a shape bvh</p>
<h4>Function refit_triangles_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">refit_triangles_bvh</span><span class="p">(</span>
    <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">*</span> <span class="n">triangles</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">);</span>
</code></pre></div>


<p>Refit triangles bvh</p>
<h4>Function refit_triangles_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">refit_triangles_bvh</span><span class="p">(</span>
    <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">);</span>
</code></pre></div>


<p>Refit triangles bvh</p>
<h4>Function refit_quads_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">refit_quads_bvh</span><span class="p">(</span>
    <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">*</span> <span class="n">quads</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">);</span>
</code></pre></div>


<p>Refit quads bvh</p>
<h4>Function refit_quads_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">refit_quads_bvh</span><span class="p">(</span>
    <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">);</span>
</code></pre></div>


<p>Refit quads bvh</p>
<h4>Function refit_lines_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">refit_lines_bvh</span><span class="p">(</span>
    <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">*</span> <span class="n">lines</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Refit lines bvh</p>
<h4>Function refit_lines_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">refit_lines_bvh</span><span class="p">(</span><span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Refit lines bvh</p>
<h4>Function refit_points_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">refit_points_bvh</span><span class="p">(</span>
    <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">points</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Refit points bvh</p>
<h4>Function refit_points_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">refit_points_bvh</span><span class="p">(</span><span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">points</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Refit points bvh</p>
<h4>Function refit_points_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">refit_points_bvh</span><span class="p">(</span>
    <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Refit points bvh</p>
<h4>Function refit_points_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">refit_points_bvh</span><span class="p">(</span>
    <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">);</span>
</code></pre></div>


<p>Refit lines bvh</p>
<h4>Function intersect_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray_</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;&amp;</span> <span class="n">intersect_elem</span><span class="p">);</span>
</code></pre></div>


<p>Intersect ray with a bvh.</p>
<h4>Function overlap_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">overlap_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_dist</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">float</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;&amp;</span> <span class="n">overlap_elem</span><span class="p">);</span>
</code></pre></div>


<p>Finds the closest element with a bvh.</p>
<h4>Function intersect_triangles_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_triangles_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">*</span> <span class="n">triangles</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span>
    <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a triangle BVH</p>
<h4>Function intersect_triangles_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_triangles_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a triangle BVH</p>
<h4>Function intersect_quads_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_quads_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">*</span> <span class="n">quads</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span>
    <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a quad BVH</p>
<h4>Function intersect_quads_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_quads_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a quad BVH</p>
<h4>Function intersect_lines_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_lines_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">*</span> <span class="n">lines</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">radius</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span>
    <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a line BVH</p>
<h4>Function intersect_lines_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_lines_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a line BVH</p>
<h4>Function intersect_points_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_points_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">points</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">radius</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span>
    <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a point BVH</p>
<h4>Function intersect_points_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_points_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">points</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a point BVH</p>
<h4>Function intersect_points_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_points_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">radius</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a point BVH</p>
<h4>Function intersect_points_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_points_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span>
    <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a point BVH</p>
<h4>Function overlap_triangles_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">overlap_triangles_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">*</span> <span class="n">triangles</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">radius</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_dist</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a triangle BVH</p>
<h4>Function overlap_triangles_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">overlap_triangles_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">triangles</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_dist</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a triangle BVH</p>
<h4>Function overlap_quads_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">overlap_quads_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">*</span> <span class="n">quads</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">radius</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_dist</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a quad BVH</p>
<h4>Function overlap_quads_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">overlap_quads_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">quads</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">max_dist</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a quad BVH</p>
<h4>Function overlap_lines_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">overlap_lines_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">*</span> <span class="n">lines</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">radius</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_dist</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a line BVH</p>
<h4>Function overlap_lines_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">overlap_lines_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">lines</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">max_dist</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a line BVH</p>
<h4>Function overlap_points_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">overlap_points_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">points</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">radius</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_dist</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a point BVH</p>
<h4>Function overlap_points_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">overlap_points_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">points</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">max_dist</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a point BVH</p>
<h4>Function overlap_points_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">overlap_points_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">radius</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_dist</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span>
    <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a point BVH</p>
<h4>Function overlap_points_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">overlap_points_bvh</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">radius</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_dist</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">);</span>
</code></pre></div>


<p>Intersect a point BVH</p>
<h4>Function overlap_bvh_elems()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">OverlapElem</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">overlap_bvh_elems</span><span class="p">(</span><span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh1</span><span class="p">,</span> <span class="k">const</span> <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh2</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">skip_duplicates</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">skip_self</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">overlaps</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">OverlapElem</span><span class="o">&amp;</span> <span class="n">overlap_elems</span><span class="p">);</span>
</code></pre></div>


<p>Finds the overlap between BVH leaf nodes.</p>
<h4>Struct texture</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">texture</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">path</span><span class="p">;</span>
    <span class="n">image4b</span> <span class="n">ldr</span><span class="p">;</span>
    <span class="n">image4f</span> <span class="n">hdr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="nf">width</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="nf">height</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>Scene Texture</p>
<ul>
<li>Members:<ul>
<li>name:      name</li>
<li>path:      path</li>
<li>ldr:      if loaded, ldr image</li>
<li>hdr:      if loaded, hdr image</li>
<li>width():      get texture width</li>
<li>height():      get texture height</li>
</ul>
</li>
</ul>
<h4>Struct texture_info</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">texture_info</span> <span class="p">{</span>
    <span class="n">texture</span><span class="o">*</span> <span class="n">txt</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">wrap_s</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">wrap_t</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">linear</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">mipmap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>Scene Texture Additional Information</p>
<ul>
<li>Members:<ul>
<li>txt:      texture pointer</li>
<li>wrap_s:      wrap s coordinate</li>
<li>wrap_t:      wrap t coordinate</li>
<li>linear:      linear interpolation</li>
<li>mipmap:      mipmaping</li>
<li>scale:      texture strength (occlusion and normal)</li>
<li>operator bool():      check whether the texture if present</li>
</ul>
</li>
</ul>
<h4>Enum material_type</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">material_type</span> <span class="p">{</span>
    <span class="n">specular_roughness</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">metallic_roughness</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">specular_glossiness</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Material type</p>
<ul>
<li>Values:<ul>
<li>specular_roughness:      Microfacet material type (OBJ)</li>
<li>metallic_roughness:      Base and metallic material (metallic-roughness in glTF)</li>
<li>specular_glossiness:      Diffuse and specular material (specular-glossness in glTF)</li>
</ul>
</li>
</ul>
<h4>Struct material</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">material</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">double_sided</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">material_type</span> <span class="n">mtype</span> <span class="o">=</span> <span class="n">material_type</span><span class="o">::</span><span class="n">specular_roughness</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">ke</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">kd</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">ks</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">kr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">kt</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">rs</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">op</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">texture_info</span> <span class="n">ke_txt</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">texture_info</span> <span class="n">kd_txt</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">texture_info</span> <span class="n">ks_txt</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">texture_info</span> <span class="n">kr_txt</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">texture_info</span> <span class="n">kt_txt</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">texture_info</span> <span class="n">rs_txt</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">texture_info</span> <span class="n">bump_txt</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">texture_info</span> <span class="n">disp_txt</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">texture_info</span> <span class="n">norm_txt</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">texture_info</span> <span class="n">occ_txt</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Scene Material</p>
<ul>
<li>Members:<ul>
<li>name:      material name</li>
<li>double_sided:      double-sided rendering</li>
<li>mtype:      material type</li>
<li>ke:      emission color</li>
<li>kd:      diffuse color / base color</li>
<li>ks:      specular color / metallic factor</li>
<li>kr:      clear coat reflection</li>
<li>kt:      transmission color</li>
<li>rs:      roughness</li>
<li>op:      opacity</li>
<li>ke_txt:      emission texture</li>
<li>kd_txt:      diffuse texture</li>
<li>ks_txt:      specular texture</li>
<li>kr_txt:      reflection texture</li>
<li>kt_txt:      transmission texture</li>
<li>rs_txt:      roughness texture</li>
<li>bump_txt:      bump map texture (heighfield)</li>
<li>disp_txt:      displacement map texture (heighfield)</li>
<li>norm_txt:      normal texture</li>
<li>occ_txt:      occlusion texture</li>
</ul>
</li>
</ul>
<h4>Struct shape</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">shape</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">material</span><span class="o">*</span> <span class="n">mat</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;</span> <span class="n">lines</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span> <span class="n">triangles</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span> <span class="n">quads</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span> <span class="n">quads_pos</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span> <span class="n">quads_norm</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span> <span class="n">quads_texcoord</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">norm</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span> <span class="n">texcoord</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span> <span class="n">texcoord1</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;</span> <span class="n">color</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">radius</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;</span> <span class="n">tangsp</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">elem_cdf</span><span class="p">;</span>
    <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">bbox3f</span> <span class="n">bbox</span> <span class="o">=</span> <span class="n">invalid_bbox3f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Shape data represented as an indexed array.
May contain only one of the points/lines/triangles/quads.</p>
<ul>
<li>Members:<ul>
<li>name:      shape name</li>
<li>path:      path (used for saving in glTF)</li>
<li>mat:      shape material</li>
<li>points:      points</li>
<li>lines:      lines</li>
<li>triangles:      triangles</li>
<li>quads:      quads</li>
<li>quads_pos:      face-varying indices for position</li>
<li>quads_norm:      face-varying indices for normal</li>
<li>quads_texcoord:      face-varying indices for texcoord</li>
<li>pos:      per-vertex position (3 float)</li>
<li>norm:      per-vertex normals (3 float)</li>
<li>texcoord:      per-vertex texcoord (2 float)</li>
<li>texcoord1:      per-vertex second texcoord (2 float)</li>
<li>color:      per-vertex color (4 float)</li>
<li>radius:      per-vertex radius (1 float)</li>
<li>tangsp:      per-vertex tangent space (4 float)</li>
<li>elem_cdf:      element CDF for sampling</li>
<li>bvh:      BVH</li>
<li>bbox:      bounding box (needs to be updated explicitly)</li>
</ul>
</li>
</ul>
<h4>Struct instance</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">instance</span> <span class="p">{</span>
    <span class="n">frame3f</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">bbox3f</span> <span class="n">bbox</span> <span class="o">=</span> <span class="n">invalid_bbox3f</span><span class="p">;</span>
    <span class="n">mat4f</span> <span class="nf">xform</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>Shape instance.</p>
<ul>
<li>Members:<ul>
<li>frame:      transform frame</li>
<li>shp:      shape instance</li>
<li>bbox:      bounding box (needs to be updated explicitly)</li>
<li>xform():      instance transform as matrix</li>
</ul>
</li>
</ul>
<h4>Struct camera</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">camera</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">frame3f</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">ortho</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">yfov</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">aspect</span> <span class="o">=</span> <span class="mf">16.0f</span> <span class="o">/</span> <span class="mf">9.0f</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">focus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">aperture</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">near</span> <span class="o">=</span> <span class="mf">0.01f</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">far</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Scene Camera</p>
<ul>
<li>Members:<ul>
<li>name:      name</li>
<li>frame:      transform frame</li>
<li>ortho:      ortho cam</li>
<li>yfov:      vertical field of view</li>
<li>aspect:      aspect ratio</li>
<li>focus:      focus distance</li>
<li>aperture:      lens aperture</li>
<li>near:      near plane distance</li>
<li>far:      far plane distance</li>
</ul>
</li>
</ul>
<h4>Struct environment</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">environment</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">frame3f</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">ke</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">texture_info</span> <span class="n">ke_txt</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Envinonment map</p>
<ul>
<li>Members:<ul>
<li>name:      name</li>
<li>frame:      transform frame</li>
<li>ke:      emission coefficient</li>
<li>ke_txt:      emission texture</li>
</ul>
</li>
</ul>
<h4>Struct light</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">light</span> <span class="p">{</span>
    <span class="n">instance</span><span class="o">*</span> <span class="n">ist</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">environment</span><span class="o">*</span> <span class="n">env</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Light, either an instance or an environment.
This is only used internally to avoid looping over all objects every time.</p>
<ul>
<li>Members:<ul>
<li>ist:      instance</li>
<li>env:      environment</li>
</ul>
</li>
</ul>
<h4>Struct scene</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">scene</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">shape</span><span class="o">*&gt;</span> <span class="n">shapes</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">instance</span><span class="o">*&gt;</span> <span class="n">instances</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">material</span><span class="o">*&gt;</span> <span class="n">materials</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">texture</span><span class="o">*&gt;</span> <span class="n">textures</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">camera</span><span class="o">*&gt;</span> <span class="n">cameras</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">environment</span><span class="o">*&gt;</span> <span class="n">environments</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">light</span><span class="o">*&gt;</span> <span class="n">lights</span><span class="p">;</span>
    <span class="n">bvh_tree</span><span class="o">*</span> <span class="n">bvh</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">bbox3f</span> <span class="n">bbox</span> <span class="o">=</span> <span class="n">invalid_bbox3f</span><span class="p">;</span>
    <span class="o">~</span><span class="n">scene</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Scene</p>
<ul>
<li>Members:<ul>
<li>shapes:      shape array</li>
<li>instances:      instance array</li>
<li>materials:      material array</li>
<li>textures:      texture array</li>
<li>cameras:      camera array</li>
<li>environments:      environment array</li>
<li>lights:      light array</li>
<li>bvh:      BVH</li>
<li>bbox:      bounding box (needs to be updated explicitly)</li>
<li>~scene():      cleanup</li>
</ul>
</li>
</ul>
<h4>Function eval_barycentric()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">eval_barycentric</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vals</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Shape value interpolated using barycentric coordinates</p>
<h4>Function eval_pos()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">eval_pos</span><span class="p">(</span><span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Shape position interpolated using barycentric coordinates</p>
<h4>Function eval_norm()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">eval_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Shape normal interpolated using barycentric coordinates</p>
<h4>Function eval_texcoord()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec2f</span> <span class="nf">eval_texcoord</span><span class="p">(</span><span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Shape texcoord interpolated using barycentric coordinates</p>
<h4>Function eval_color()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="nf">eval_color</span><span class="p">(</span><span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Shape texcoord interpolated using barycentric coordinates</p>
<h4>Function eval_tangsp()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="nf">eval_tangsp</span><span class="p">(</span><span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Shape tangent space interpolated using barycentric coordinates</p>
<h4>Function eval_pos()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">eval_pos</span><span class="p">(</span><span class="k">const</span> <span class="n">instance</span><span class="o">*</span> <span class="n">ist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Instance position interpolated using barycentric coordinates</p>
<h4>Function eval_norm()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec3f</span> <span class="nf">eval_norm</span><span class="p">(</span><span class="k">const</span> <span class="n">instance</span><span class="o">*</span> <span class="n">ist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Instance normal interpolated using barycentric coordinates</p>
<h4>Function eval_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vec4f</span> <span class="n">eval_texture</span><span class="p">(</span><span class="k">const</span> <span class="n">texture_info</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">texcoord</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">srgb</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Evaluate a texture</p>
<h4>Function subdivide_shape()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">subdivide_shape</span><span class="p">(</span><span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">subdiv</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Subdivides shape elements. Apply subdivision surface rules if subdivide
is true.</p>
<h4>Function facet_shape()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">facet_shape</span><span class="p">(</span><span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">);</span>
</code></pre></div>


<p>Facet a shape. Supports only non-face0varying shapes</p>
<h4>Function tesselate_shape()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tesselate_shape</span><span class="p">(</span><span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">);</span>
</code></pre></div>


<p>Tesselate a shape into basic primitives</p>
<h4>Function tesselate_shapes()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tesselate_shapes</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Tesselate scene shapes and update pointers</p>
<h4>Struct load_options</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">load_options</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">load_textures</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">obj_flip_texcoord</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">obj_facet_non_smooth</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">obj_flip_tr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">preserve_quads</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">preserve_facevarying</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Loading options</p>
<ul>
<li>Members:<ul>
<li>load_textures:      Whether to load textures</li>
<li>skip_missing:      Skip missing files without giving and error</li>
<li>obj_flip_texcoord:      Whether to flip the v coordinate in OBJ</li>
<li>obj_facet_non_smooth:      Duplicate vertices if smoothing off in OBJ</li>
<li>obj_flip_tr:      Whether to flip tr in OBJ</li>
<li>preserve_quads:      whether to preserve quads</li>
<li>preserve_facevarying:      whether to preserve face-varying faces</li>
</ul>
</li>
</ul>
<h4>Function load_scene()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">scene</span><span class="o">*</span> <span class="n">load_scene</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">load_options</span><span class="o">&amp;</span> <span class="n">opts</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Loads a scene. For now OBJ or glTF are supported.
Throws an exception if an error occurs.</p>
<h4>Struct save_options</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">save_options</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">save_textures</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">obj_flip_texcoord</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">obj_flip_tr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">gltf_separate_buffers</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Save options</p>
<ul>
<li>Members:<ul>
<li>save_textures:      Whether to save textures</li>
<li>skip_missing:      Skip missing files without giving and error</li>
<li>obj_flip_texcoord:      Whether to flip the v coordinate in OBJ</li>
<li>obj_flip_tr:      Whether to flip tr in OBJ</li>
<li>gltf_separate_buffers:      Whether to use separate buffers in gltf</li>
</ul>
</li>
</ul>
<h4>Function save_scene()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">save_scene</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">save_options</span><span class="o">&amp;</span> <span class="n">opts</span><span class="p">);</span>
</code></pre></div>


<p>Saves a scene. For now OBJ and glTF are supported.
Throws an exception if an error occurs.</p>
<h4>Struct add_elements_options</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">add_elements_options</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">smooth_normals</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">pointline_radius</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">tangent_space</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">texture_data</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">shape_instances</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">default_camera</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">default_environment</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">default_names</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">default_paths</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">add_elements_options</span> <span class="nf">none</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Add elements options</p>
<ul>
<li>Members:<ul>
<li>smooth_normals:      Add missing normal</li>
<li>pointline_radius:      Add missing radius for points and lines (&lt;=0 for no adding)</li>
<li>tangent_space:      Add missing trangent space</li>
<li>texture_data:      texture data</li>
<li>shape_instances:      Add instances</li>
<li>default_camera:      Add default camera</li>
<li>default_environment:      Add an empty default environment</li>
<li>default_names:      Add default names</li>
<li>default_paths:      Add default paths</li>
<li>none():      initialize to no element</li>
</ul>
</li>
</ul>
<h4>Function add_elements()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="n">add_elements</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">add_elements_options</span><span class="o">&amp;</span> <span class="n">opts</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Add elements</p>
<h4>Function merge_into()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">merge_into</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">merge_into</span><span class="p">,</span> <span class="n">scene</span><span class="o">*</span> <span class="n">merge_from</span><span class="p">);</span>
</code></pre></div>


<p>Merge scene into one another. Note that the objects are <em>moved</em> from
merge_from to merged_into, so merge_from will be empty after this function.</p>
<h4>Function update_bounds()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_bounds</span><span class="p">(</span><span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">);</span>
</code></pre></div>


<p>Computes a shape bounding box (quick computation that ignores radius)</p>
<h4>Function update_bounds()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_bounds</span><span class="p">(</span><span class="n">instance</span><span class="o">*</span> <span class="n">ist</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">do_shape</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Updates the instance bounding box</p>
<h4>Function update_bounds()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_bounds</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">do_shapes</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Updates the scene and scene's instances bounding boxes</p>
<h4>Function flatten_instances()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">flatten_instances</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Flatten scene instances into separate meshes.</p>
<h4>Function update_lights()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_lights</span><span class="p">(</span>
    <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">include_env</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sampling_cdf</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Initialize the lights</p>
<h4>Function print_info()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">print_info</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">);</span>
</code></pre></div>


<p>Print scene information (call update bounds bes before)</p>
<h4>Function build_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">build_bvh</span><span class="p">(</span><span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">equalsize</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Build a shape BVH</p>
<h4>Function build_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">build_bvh</span><span class="p">(</span>
    <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">equalsize</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">do_shapes</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Build a scene BVH</p>
<h4>Function refit_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">refit_bvh</span><span class="p">(</span><span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">);</span>
</code></pre></div>


<p>Refits a scene BVH</p>
<h4>Function refit_bvh()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">refit_bvh</span><span class="p">(</span><span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">do_shapes</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Refits a scene BVH</p>
<h4>Function intersect_ray()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_ray</span><span class="p">(</span><span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span>
    <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect the shape with a ray. Find any interstion if early_exit,
otherwise find first intersection.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene to intersect</li>
<li>ray: ray to be intersected</li>
<li>early_exit: whether to stop at the first found hit</li>
<li>ray_t: ray distance at intersection</li>
<li>eid: shape element index</li>
<li>euv: element barycentric coordinates</li>
</ul>
</li>
<li>Returns:<ul>
<li>whether it intersected</li>
</ul>
</li>
</ul>
<h4>Function intersect_ray()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_ray</span><span class="p">(</span><span class="k">const</span> <span class="n">instance</span><span class="o">*</span> <span class="n">ist</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect the instance with a ray. Find any interstion if early_exit,
otherwise find first intersection.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene to intersect</li>
<li>ray: ray to be intersected</li>
<li>early_exit: whether to stop at the first found hit</li>
<li>ray_t: ray distance at intersection</li>
<li>eid: shape element index</li>
<li>euv: element barycentric coordinates</li>
</ul>
</li>
<li>Returns:<ul>
<li>whether it intersected</li>
</ul>
</li>
</ul>
<h4>Function intersect_ray()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">intersect_ray</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span>
    <span class="kt">float</span><span class="o">&amp;</span> <span class="n">ray_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">iid</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Intersect the scene with a ray. Find any interstion if early_exit,
otherwise find first intersection.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene to intersect</li>
<li>ray: ray to be intersected</li>
<li>early_exit: whether to stop at the first found hit</li>
<li>ray_t: ray distance at intersection</li>
<li>iid: instance index</li>
<li>eid: shape element index</li>
<li>euv: element barycentric coordinates</li>
</ul>
</li>
<li>Returns:<ul>
<li>whether it intersected</li>
</ul>
</li>
</ul>
<h4>Struct intersection_point</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">intersection_point</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">iid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">eid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">vec4f</span> <span class="n">euv</span> <span class="o">=</span> <span class="n">zero4f</span><span class="p">;</span>
    <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>Surface point.</p>
<ul>
<li>Members:<ul>
<li>dist:      distance of the hit along the ray or from the point</li>
<li>iid:      instance index</li>
<li>eid:      shape element index</li>
<li>euv:      shape barycentric coordinates</li>
<li>operator bool():      check if intersection is valid</li>
</ul>
</li>
</ul>
<h4>Function intersect_ray()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">intersection_point</span> <span class="nf">intersect_ray</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">ray3f</span><span class="o">&amp;</span> <span class="n">ray</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">);</span>
</code></pre></div>


<p>Intersect the scene with a ray. Find any interstion if early_exit,
otherwise find first intersection.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene to intersect</li>
<li>ray: ray to be intersected</li>
<li>early_exit: whether to stop at the first found hit</li>
</ul>
</li>
<li>Returns:<ul>
<li>intersection record</li>
</ul>
</li>
</ul>
<h4>Function overlap_point()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">overlap_point</span><span class="p">(</span><span class="k">const</span> <span class="n">shape</span><span class="o">*</span> <span class="n">shp</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_dist</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Finds the closest element that overlaps a point within a given distance.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene to intersect</li>
<li>pos: point position</li>
<li>max_dist: maximu valid distance</li>
<li>early_exit: whether to stop at the first found hit</li>
<li>dist: distance at intersection</li>
<li>eid: shape element index</li>
<li>euv: element barycentric coordinates</li>
</ul>
</li>
<li>Returns:<ul>
<li>whether it intersected</li>
</ul>
</li>
</ul>
<h4>Function overlap_point()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">overlap_point</span><span class="p">(</span><span class="k">const</span> <span class="n">instance</span><span class="o">*</span> <span class="n">ist</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_dist</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Finds the closest element that overlaps a point within a given distance.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene to intersect</li>
<li>pos: point position</li>
<li>max_dist: maximu valid distance</li>
<li>early_exit: whether to stop at the first found hit</li>
<li>dist: distance at intersection</li>
<li>eid: shape element index</li>
<li>euv: element barycentric coordinates</li>
</ul>
</li>
<li>Returns:<ul>
<li>whether it intersected</li>
</ul>
</li>
</ul>
<h4>Function overlap_point()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">overlap_point</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max_dist</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">early_exit</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">iid</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">eid</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">euv</span><span class="p">);</span>
</code></pre></div>


<p>Finds the closest element that overlaps a point within a given distance.</p>
<ul>
<li>Parameters:<ul>
<li>scn: scene to intersect</li>
<li>pos: point position</li>
<li>max_dist: maximu valid distance</li>
<li>early_exit: whether to stop at the first found hit</li>
<li>dist: distance at intersection</li>
<li>iid: instance index</li>
<li>eid: shape element index</li>
<li>euv: element barycentric coordinates</li>
</ul>
</li>
<li>Returns:<ul>
<li>whether it intersected</li>
</ul>
</li>
</ul>
<h4>Function overlap_instance_bounds()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">overlap_instance_bounds</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn1</span><span class="p">,</span> <span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn2</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">skip_duplicates</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">skip_self</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">overlaps</span><span class="p">);</span>
</code></pre></div>


<p>Find the list of overlaps between instance bounds.</p>
<h4>Function make_cornell_box_scene()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">scene</span><span class="o">*</span> <span class="nf">make_cornell_box_scene</span><span class="p">();</span>
</code></pre></div>


<p>Makes the Cornell Box scene</p>
<h4>Enum test_scene_type</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">test_scene_type</span> <span class="p">{</span>
</code></pre></div>


<p>Test scene enumeration.</p>
<h4>Function test_scene_names()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">test_scene_type</span><span class="o">&gt;&gt;&amp;</span> <span class="n">test_scene_names</span><span class="p">();</span>
</code></pre></div>


<p>Names for enumeration</p>
<h4>Function make_test_scene()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">scene</span><span class="o">*</span> <span class="nf">make_test_scene</span><span class="p">(</span><span class="n">test_scene_type</span> <span class="n">stype</span><span class="p">);</span>
</code></pre></div>


<p>Makes a test scene</p>
<h4>Enum trace_shader_type</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">trace_shader_type</span> <span class="p">{</span>
    <span class="n">pathtrace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">eyelight</span><span class="p">,</span>
    <span class="n">direct</span><span class="p">,</span>
    <span class="n">pathtrace_nomis</span><span class="p">,</span>
    <span class="n">debug_normal</span><span class="p">,</span>
    <span class="n">debug_albedo</span><span class="p">,</span>
    <span class="n">debug_texcoord</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Type of rendering algorithm (shader)</p>
<ul>
<li>Values:<ul>
<li>pathtrace:      pathtrace</li>
<li>eyelight:      eye hight for quick previews</li>
<li>direct:      direct illumination</li>
<li>pathtrace_nomis:      pathtrace without MIS (usedful ony for debugging)</li>
<li>debug_normal:      debug normal</li>
<li>debug_albedo:      debug albedo</li>
<li>debug_texcoord:      debug texcoord</li>
</ul>
</li>
</ul>
<h4>Function trace_shader_names()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">trace_shader_type</span><span class="o">&gt;&gt;&amp;</span> <span class="n">trace_shader_names</span><span class="p">();</span>
</code></pre></div>


<p>Names for enumeration</p>
<h4>Enum trace_rng_type</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">trace_rng_type</span> <span class="p">{</span>
    <span class="n">uniform</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">stratified</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Random number generator type</p>
<ul>
<li>Values:<ul>
<li>uniform:      uniform random numbers</li>
<li>stratified:      stratified random numbers</li>
</ul>
</li>
</ul>
<h4>Function trace_rng_names()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">trace_rng_type</span><span class="o">&gt;&gt;&amp;</span> <span class="n">trace_rng_names</span><span class="p">();</span>
</code></pre></div>


<p>Names for enumeration</p>
<h4>Enum trace_filter_type</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">trace_filter_type</span> <span class="p">{</span>
    <span class="n">box</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">triangle</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">cubic</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">catmull_rom</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">mitchell</span> <span class="o">=</span> <span class="mi">5</span>

<span class="p">}</span>
</code></pre></div>


<p>Filter type</p>
<ul>
<li>Values:<ul>
<li>box:      box filter</li>
<li>triangle:      hat filter</li>
<li>cubic:      cubic spline</li>
<li>catmull_rom:      Catmull-Rom spline</li>
<li>mitchell:      Mitchell-Netrevalli</li>
</ul>
</li>
</ul>
<h4>Function trace_filter_names()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">trace_filter_type</span><span class="o">&gt;&gt;&amp;</span> <span class="n">trace_filter_names</span><span class="p">();</span>
</code></pre></div>


<p>Names for enumeration</p>
<h4>Struct trace_params</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">trace_params</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">camera_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">360</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">360</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nsamples</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
    <span class="n">trace_shader_type</span> <span class="n">stype</span> <span class="o">=</span> <span class="n">trace_shader_type</span><span class="o">::</span><span class="n">pathtrace</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">shadow_notransmission</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">trace_rng_type</span> <span class="n">rtype</span> <span class="o">=</span> <span class="n">trace_rng_type</span><span class="o">::</span><span class="n">stratified</span><span class="p">;</span>
    <span class="n">trace_filter_type</span> <span class="n">ftype</span> <span class="o">=</span> <span class="n">trace_filter_type</span><span class="o">::</span><span class="n">box</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">ambient</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">bool</span> <span class="n">envmap_invisible</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">min_depth</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">max_depth</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">pixel_clamp</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">ray_eps</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="n">f</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">parallel</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Rendering params</p>
<ul>
<li>Members:<ul>
<li>camera_id:      camera id</li>
<li>width:      image width</li>
<li>height:      image height</li>
<li>nsamples:      number of samples</li>
<li>stype:      sampler type</li>
<li>shadow_notransmission:      wheter to test transmission in shadows</li>
<li>rtype:      random number generation type</li>
<li>ftype:      filter type</li>
<li>ambient:      ambient lighting</li>
<li>envmap_invisible:      view environment map</li>
<li>min_depth:      minimum ray depth</li>
<li>max_depth:      maximum ray depth</li>
<li>pixel_clamp:      final pixel clamping</li>
<li>ray_eps:      ray intersection epsilon</li>
<li>parallel:      parallel execution</li>
<li>seed:      seed for the random number generators</li>
<li>block_size:      block size for parallel batches (probably leave it as is)</li>
</ul>
</li>
</ul>
<h4>Function trace_blocks()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="p">,</span> <span class="n">vec2i</span><span class="o">&gt;&gt;</span> <span class="n">trace_blocks</span><span class="p">(</span><span class="k">const</span> <span class="n">trace_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Make image blocks</p>
<h4>Function trace_rngs()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">rng_pcg32</span><span class="o">&gt;</span> <span class="n">trace_rngs</span><span class="p">(</span><span class="k">const</span> <span class="n">trace_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Make a 2D array of random number generators for parallelization</p>
<h4>Function trace_block()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">trace_block</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">block_min</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">block_max</span><span class="p">,</span> <span class="kt">int</span> <span class="n">samples_min</span><span class="p">,</span> <span class="kt">int</span> <span class="n">samples_max</span><span class="p">,</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">rng_pcg32</span><span class="o">&gt;&amp;</span> <span class="n">rngs</span><span class="p">,</span> <span class="k">const</span> <span class="n">trace_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Renders a block of samples</p>
<p>Notes: It is safe to call the function in parallel on different blocks.
But two threads should not access the same pixels at the same time. If
the same block is rendered with different samples, samples have to be
sequential.</p>
<ul>
<li>Parameters:<ul>
<li>scn: trace scene</li>
<li>img: pixel data in RGBA format (width/height in params)</li>
<li>block: range of pixels to render</li>
<li>samples_min, samples_max: range of samples to render</li>
<li>params: trace params</li>
</ul>
</li>
</ul>
<h4>Function trace_samples()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">trace_samples</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="kt">int</span> <span class="n">samples_min</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">samples_max</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">rng_pcg32</span><span class="o">&gt;&amp;</span> <span class="n">rngs</span><span class="p">,</span> <span class="k">const</span> <span class="n">trace_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Trace the next samples in [samples_min, samples_max) range.
Samples have to be traced consecutively.</p>
<h4>Function trace_block_filtered()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">trace_block_filtered</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">acc</span><span class="p">,</span>
    <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">block_min</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">block_max</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">samples_min</span><span class="p">,</span> <span class="kt">int</span> <span class="n">samples_max</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">rng_pcg32</span><span class="o">&gt;&amp;</span> <span class="n">rngs</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&amp;</span> <span class="n">image_mutex</span><span class="p">,</span> <span class="k">const</span> <span class="n">trace_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Renders a filtered block of samples</p>
<p>Notes: It is safe to call the function in parallel on different blocks.
But two threads should not access the same pixels at the same time. If
the same block is rendered with different samples, samples have to be
sequential.</p>
<ul>
<li>Parameters:<ul>
<li>scn: trace scene</li>
<li>img: pixel data in RGBA format (width/height in params)</li>
<li>acc: accumulation buffer in RGBA format (width/height in params)</li>
<li>weight: weight buffer in float format (width/height in params)</li>
<li>block: range of pixels to render</li>
<li>samples_min, samples_max: range of samples to render</li>
<li>image_mutex: mutex for locking</li>
<li>params: trace params</li>
</ul>
</li>
</ul>
<h4>Function trace_filtered_samples()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">trace_filtered_samples</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">acc</span><span class="p">,</span>
    <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int</span> <span class="n">samples_min</span><span class="p">,</span> <span class="kt">int</span> <span class="n">samples_max</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">rng_pcg32</span><span class="o">&gt;&amp;</span> <span class="n">rngs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">trace_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Trace the next samples in [samples_min, samples_max) range.
Samples have to be traced consecutively.</p>
<h4>Function trace_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">image4f</span> <span class="nf">trace_image</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="k">const</span> <span class="n">trace_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Trace the whole image</p>
<h4>Function trace_async_start()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">trace_async_start</span><span class="p">(</span><span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">rng_pcg32</span><span class="o">&gt;&amp;</span> <span class="n">rngs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">trace_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">,</span> <span class="n">thread_pool</span><span class="o">*</span> <span class="n">pool</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&amp;</span> <span class="n">callback</span><span class="p">);</span>
</code></pre></div>


<p>Starts an anyncrhounous renderer with a maximum of 256 samples.</p>
<h4>Function trace_async_stop()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">trace_async_stop</span><span class="p">(</span><span class="n">thread_pool</span><span class="o">*</span> <span class="n">pool</span><span class="p">);</span>
</code></pre></div>


<p>Stop the asynchronous renderer.</p>
<h4>Struct obj_vertex</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_vertex</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">texcoord</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">norm</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">color</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">radius</span><span class="p">;</span>
    <span class="n">obj_vertex</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">texcoord</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">norm</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">color</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">radius</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div>


<p>Face vertex</p>
<ul>
<li>Members:<ul>
<li>pos:      position</li>
<li>texcoord:      texcoord</li>
<li>norm:      normal</li>
<li>color:      color [extension]</li>
<li>radius:      radius [extension]</li>
<li>obj_vertex():      Constructor (copies members initializing missing ones to -1)</li>
</ul>
</li>
</ul>
<h4>Enum obj_element_type : uint16_t</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="nl">obj_element_type</span> <span class="p">:</span> <span class="kt">uint16_t</span> <span class="p">{</span>
    <span class="n">point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">line</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">face</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">tetra</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>element type</p>
<ul>
<li>Values:<ul>
<li>point:      lists of points</li>
<li>line:      polylines</li>
<li>face:      polygon faces</li>
<li>tetra:      tetrahedrons</li>
</ul>
</li>
</ul>
<h4>Struct obj_element</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_element</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">start</span><span class="p">;</span>
    <span class="n">obj_element_type</span> <span class="n">type</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Element vertex indices</p>
<ul>
<li>Members:<ul>
<li>start:      starting vertex index</li>
<li>type:      element type</li>
<li>size:      number of vertices</li>
</ul>
</li>
</ul>
<h4>Struct obj_group</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_group</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">matname</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">groupname</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">smoothing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_vertex</span><span class="o">&gt;</span> <span class="n">verts</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_element</span><span class="o">&gt;</span> <span class="n">elems</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Element group</p>
<ul>
<li>Members:<ul>
<li>matname:      material name</li>
<li>groupname:      group name</li>
<li>smoothing:      smoothing</li>
<li>verts:      element vertices</li>
<li>elems:      element faces</li>
</ul>
</li>
</ul>
<h4>Struct obj_object</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_object</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_group</span><span class="o">&gt;</span> <span class="n">groups</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Obj object</p>
<ul>
<li>Members:<ul>
<li>name:      object name</li>
<li>groups:      element groups</li>
</ul>
</li>
</ul>
<h4>Struct obj_texture_info</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_texture_info</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">clamp</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">unknown_props</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Texture information for OBJ</p>
<ul>
<li>Members:<ul>
<li>path:      the texture path</li>
<li>clamp:      whether to clamp tp th edge</li>
<li>scale:      the scale for bump and displacement</li>
<li>unknown_props:      the rest of the unknown properties</li>
</ul>
</li>
</ul>
<h4>Struct obj_texture</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_texture</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">path</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">datab</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">dataf</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>OBJ texture. Texture data is loaded only if desired.</p>
<ul>
<li>Members:<ul>
<li>path:      texture path</li>
<li>width:      Width</li>
<li>height:      Height</li>
<li>ncomp:      Number of Channels</li>
<li>datab:      Buffer data for 8-bit images</li>
<li>dataf:      Buffer data for float images</li>
</ul>
</li>
</ul>
<h4>Struct obj_material</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_material</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">illum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">ke</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">ka</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">kd</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">ks</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">kr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">kt</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">ns</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">ior</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">op</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">ke_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">ka_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">kd_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">ks_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">kr_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">kt_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">ns_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">op_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">ior_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">bump_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">disp_txt</span><span class="p">;</span>
    <span class="n">obj_texture_info</span> <span class="n">norm_txt</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">unknown_props</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>OBJ material</p>
<ul>
<li>Members:<ul>
<li>name:      material name</li>
<li>illum:      MTL illum mode</li>
<li>ke:      emission color</li>
<li>ka:      ambient color</li>
<li>kd:      diffuse color</li>
<li>ks:      specular color</li>
<li>kr:      reflection color</li>
<li>kt:      transmision color</li>
<li>ns:      phong exponent for ks</li>
<li>ior:      index of refraction</li>
<li>op:      opacity</li>
<li>ke_txt:      emission texture</li>
<li>ka_txt:      ambient texture</li>
<li>kd_txt:      diffuse texture</li>
<li>ks_txt:      specular texture</li>
<li>kr_txt:      reflection texture</li>
<li>kt_txt:      transmission texture</li>
<li>ns_txt:      specular exponent texture</li>
<li>op_txt:      opacity texture</li>
<li>ior_txt:      index of refraction</li>
<li>bump_txt:      bump map texture (heighfield)</li>
<li>disp_txt:      displacement map texture (heighfield)</li>
<li>norm_txt:      normal map texture</li>
<li>unknown_props:      unknown string props</li>
</ul>
</li>
</ul>
<h4>Struct obj_camera</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_camera</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">frame3f</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">ortho</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">yfov</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">atan</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">aspect</span> <span class="o">=</span> <span class="mf">16.0f</span> <span class="o">/</span> <span class="mf">9.0f</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">aperture</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">focus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Camera [extension]</p>
<ul>
<li>Members:<ul>
<li>name:      camera name</li>
<li>frame:      transform frame (affine matrix)</li>
<li>ortho:      orthografic camera</li>
<li>yfov:      vertical field of view</li>
<li>aspect:      aspect ratio</li>
<li>aperture:      lens aperture</li>
<li>focus:      focus distance</li>
</ul>
</li>
</ul>
<h4>Struct obj_environment</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_environment</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">frame3f</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">matname</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Environment [extension]</p>
<ul>
<li>Members:<ul>
<li>name:      environment name</li>
<li>frame:      transform frame (affine matrix)</li>
<li>matname:      material name</li>
</ul>
</li>
</ul>
<h4>Struct obj_instance</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_instance</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">frame3f</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">identity_frame3f</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">objname</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Instance [extension]</p>
<ul>
<li>Members:<ul>
<li>name:      instance name</li>
<li>frame:      transform frame (affine matrix)</li>
<li>objname:      object name</li>
</ul>
</li>
</ul>
<h4>Struct obj_scene</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_scene</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">norm</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span> <span class="n">texcoord</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;</span> <span class="n">color</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">radius</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_object</span><span class="o">*&gt;</span> <span class="n">objects</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_material</span><span class="o">*&gt;</span> <span class="n">materials</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_texture</span><span class="o">*&gt;</span> <span class="n">textures</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_camera</span><span class="o">*&gt;</span> <span class="n">cameras</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_environment</span><span class="o">*&gt;</span> <span class="n">environments</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_instance</span><span class="o">*&gt;</span> <span class="n">instances</span><span class="p">;</span>
    <span class="o">~</span><span class="n">obj_scene</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>OBJ asset</p>
<ul>
<li>Members:<ul>
<li>pos:      vertex positions</li>
<li>norm:      vertex normals</li>
<li>texcoord:      vertex texcoord</li>
<li>color:      vertex color [extension]</li>
<li>radius:      vertex radius [extension]</li>
<li>objects:      objects</li>
<li>materials:      materials</li>
<li>textures:      textures</li>
<li>cameras:      cameras [extension]</li>
<li>environments:      env maps [extension]</li>
<li>instances:      instances [extension]</li>
<li>~obj_scene():      cleanup</li>
</ul>
</li>
</ul>
<h4>Function load_obj()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">obj_scene</span><span class="o">*</span> <span class="nf">load_obj</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">load_textures</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flip_texcoord</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flip_tr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Load OBJ</p>
<ul>
<li>Parameters:<ul>
<li>filename: filename</li>
<li>load_texture: whether to load textures</li>
<li>skip_missing: whether to skip missing files</li>
<li>flip_texcoord: whether to flip the v coordinate</li>
<li>flip_tr: whether to flip the Tr value</li>
</ul>
</li>
<li>Return:<ul>
<li>obj (nullptr on error)</li>
</ul>
</li>
</ul>
<h4>Function save_obj()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">save_obj</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">obj_scene</span><span class="o">*</span> <span class="n">model</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">save_textures</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">flip_texcoord</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flip_tr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Save OBJ</p>
<ul>
<li>Parameters:<ul>
<li>filename: filename</li>
<li>model: obj data to save</li>
<li>save_textures: whether to save textures</li>
<li>skip_missing: whether to skip missing files</li>
<li>flip_texcoord: whether to flip the v coordinate</li>
<li>flip_tr: whether to flip the Tr value</li>
</ul>
</li>
<li>Returns:<ul>
<li>whether an error occurred</li>
</ul>
</li>
</ul>
<h4>Struct obj_shape</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_shape</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">matname</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;</span> <span class="n">lines</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;</span> <span class="n">triangles</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;</span> <span class="n">tetras</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;</span> <span class="n">norm</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;</span> <span class="n">texcoord</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;</span> <span class="n">color</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">radius</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Shape. May contain only one of the points/lines/triangles.</p>
<ul>
<li>Members:<ul>
<li>name:      name of the group that enclosed it</li>
<li>matname:      name of the material</li>
<li>points:      points</li>
<li>lines:      lines</li>
<li>triangles:      triangles</li>
<li>tetras:      tetrahedrons</li>
<li>pos:      per-vertex position (3 float)</li>
<li>norm:      per-vertex normals (3 float)</li>
<li>texcoord:      per-vertex texcoord (2 float)</li>
<li>color:      [extension] per-vertex color (4 float)</li>
<li>radius:      [extension] per-vertex radius (1 float)</li>
</ul>
</li>
</ul>
<h4>Struct obj_mesh</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">obj_mesh</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">obj_shape</span><span class="o">&gt;</span> <span class="n">shapes</span><span class="p">;</span>
    <span class="o">~</span><span class="n">obj_mesh</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Mesh</p>
<ul>
<li>Members:<ul>
<li>shapes:      primitives</li>
<li>~obj_mesh():      cleanup</li>
</ul>
</li>
</ul>
<h4>Function get_mesh()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">obj_mesh</span><span class="o">*</span> <span class="nf">get_mesh</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">obj_scene</span><span class="o">*</span> <span class="n">model</span><span class="p">,</span> <span class="k">const</span> <span class="n">obj_object</span><span class="o">&amp;</span> <span class="n">oobj</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">facet_non_smooth</span><span class="p">);</span>
</code></pre></div>


<p>Gets a mesh from an OBJ object.</p>
<h4>Typedef buffer_data</h4>
<div class="codehilite"><pre><code><span></span><span class="k">using</span> <span class="n">buffer_data</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>


<p>Generic buffer data.</p>
<h4>Struct image_data</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">image_data</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">datab</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">dataf</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Generic image data.</p>
<ul>
<li>Members:<ul>
<li>width:      Width</li>
<li>height:      Height</li>
<li>ncomp:      Number of Channels</li>
<li>datab:      Buffer data for 8-bit images</li>
<li>dataf:      Buffer data for float images</li>
</ul>
</li>
</ul>
<h4>Struct glTFid</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">glTFid</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="p">();</span> 
    <span class="k">explicit</span> <span class="nf">glTFid</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">);</span> 
    <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">bool</span> <span class="nf">is_valid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>glTFid</p>
<ul>
<li>Members:<ul>
<li>glTFid():      defaoult constructor to an invalid id</li>
<li>glTFid():      explicit conversion from integer</li>
<li>operator int():      explicit convcersion to integer</li>
<li>is_valid():      check if it is valid</li>
<li>operator bool():      check if it is valid</li>
</ul>
</li>
</ul>
<h4>Struct glTFProperty</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">nlohmann</span><span class="o">::</span><span class="n">json</span><span class="o">&gt;</span> <span class="n">extensions</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">nlohmann</span><span class="o">::</span><span class="n">json</span> <span class="n">extras</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Generic glTF object</p>
<ul>
<li>Members:<ul>
<li>extensions:      Extensions.</li>
<li>extras:      Extra data.</li>
</ul>
</li>
</ul>
<h4>Struct glTFChildOfRootProperty</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFChildOfRootProperty</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Generic glTF named object</p>
<ul>
<li>Members:<ul>
<li>name:      The user-defined name of this object.</li>
</ul>
</li>
</ul>
<h4>Enum class glTFAccessorSparseIndicesComponentType</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFAccessorSparseIndicesComponentType</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFAccessorSparseIndices::componentType</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFAccessorSparseIndices</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAccessorSparseIndices</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">&gt;</span> <span class="n">bufferView</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">byteOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">glTFAccessorSparseIndicesComponentType</span> <span class="n">componentType</span> <span class="o">=</span>
        <span class="n">glTFAccessorSparseIndicesComponentType</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Indices of those attributes that deviate from their initialization value.</p>
<ul>
<li>Members:<ul>
<li>bufferView:      The index of the bufferView with sparse indices. Referenced bufferView
 can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target. [required]</li>
<li>byteOffset:      The offset relative to the start of the bufferView in bytes. Must be
 aligned.</li>
<li>componentType:      The indices data type. [required]</li>
</ul>
</li>
</ul>
<h4>Struct glTFAccessorSparseValues</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAccessorSparseValues</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">&gt;</span> <span class="n">bufferView</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">byteOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Array of size <code>accessor.sparse.count</code> times number of components storing the
displaced accessor attributes pointed by <code>accessor.sparse.indices</code>.</p>
<ul>
<li>Members:<ul>
<li>bufferView:      The index of the bufferView with sparse values. Referenced bufferView
 can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target. [required]</li>
<li>byteOffset:      The offset relative to the start of the bufferView in bytes. Must be
 aligned.</li>
</ul>
</li>
</ul>
<h4>Struct glTFAccessorSparse</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAccessorSparse</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">glTFAccessorSparseIndices</span><span class="o">*</span> <span class="n">indices</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFAccessorSparseValues</span><span class="o">*</span> <span class="n">values</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFAccessorSparse</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Sparse storage of attributes that deviate from their initialization value.</p>
<ul>
<li>Members:<ul>
<li>count:      Number of entries stored in the sparse array. [required]</li>
<li>indices:      Index array of size <code>count</code> that points to those accessor attributes
 that deviate from their initialization value. Indices must strictly
 increase. [required]</li>
<li>values:      Array of size <code>count</code> times number of components, storing the displaced
 accessor attributes pointed by <code>indices</code>. Substituted values must have
 the same <code>componentType</code> and number of components as the base accessor.
 [required]</li>
<li>~glTFAccessorSparse():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Enum class glTFAccessorComponentType</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFAccessorComponentType</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFAccessor::componentType</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Enum class glTFAccessorType</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFAccessorType</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFAccessor::type</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFAccessor</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAccessor</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">&gt;</span> <span class="n">bufferView</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">byteOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">glTFAccessorComponentType</span> <span class="n">componentType</span> <span class="o">=</span> <span class="n">glTFAccessorComponentType</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">normalized</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">glTFAccessorType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">glTFAccessorType</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">max</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">min</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAccessorSparse</span><span class="o">*</span> <span class="n">sparse</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFAccessor</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>A typed view into a bufferView.  A bufferView contains raw binary data.  An
accessor provides a typed view into a bufferView or a subset of a bufferView
similar to how WebGL's <code>vertexAttribPointer()</code> defines an attribute in a
buffer.</p>
<ul>
<li>Members:<ul>
<li>bufferView:      The index of the bufferView.</li>
<li>byteOffset:      The offset relative to the start of the bufferView in bytes.</li>
<li>componentType:      The datatype of components in the attribute. [required]</li>
<li>normalized:      Specifies whether integer data values should be normalized.</li>
<li>count:      The number of attributes referenced by this accessor. [required]</li>
<li>type:      Specifies if the attribute is a scalar, vector, or matrix. [required]</li>
<li>max:      Maximum value of each component in this attribute.</li>
<li>min:      Minimum value of each component in this attribute.</li>
<li>sparse:      Sparse storage of attributes that deviate from their initialization
 value.</li>
<li>~glTFAccessor():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Enum class glTFAnimationChannelTargetPath</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFAnimationChannelTargetPath</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFAnimationChannelTarget::path</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFAnimationChannelTarget</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAnimationChannelTarget</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAnimationChannelTargetPath</span> <span class="n">path</span> <span class="o">=</span>
        <span class="n">glTFAnimationChannelTargetPath</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>The index of the node and TRS property that an animation channel targets.</p>
<ul>
<li>Members:<ul>
<li>node:      The index of the node to target. [required]</li>
<li>path:      The name of the node's TRS property to modify, or the "weights" of the
 Morph Targets it instantiates. [required]</li>
</ul>
</li>
</ul>
<h4>Struct glTFAnimationChannel</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAnimationChannel</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAnimationSampler</span><span class="o">&gt;</span> <span class="n">sampler</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAnimationChannelTarget</span><span class="o">*</span> <span class="n">target</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFAnimationChannel</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>Targets an animation's sampler at a node's property.</p>
<ul>
<li>Members:<ul>
<li>sampler:      The index of a sampler in this animation used to compute the value for
 the target. [required]</li>
<li>target:      The index of the node and TRS property to target. [required]</li>
<li>~glTFAnimationChannel():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Enum class glTFAnimationSamplerInterpolation</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFAnimationSamplerInterpolation</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFAnimationSampler::interpolation</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFAnimationSampler</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAnimationSampler</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;</span> <span class="n">input</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAnimationSamplerInterpolation</span> <span class="n">interpolation</span> <span class="o">=</span>
        <span class="n">glTFAnimationSamplerInterpolation</span><span class="o">::</span><span class="n">Linear</span><span class="p">;</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Combines input and output accessors with an interpolation algorithm to
define a keyframe graph (but not its target).</p>
<ul>
<li>Members:<ul>
<li>input:      The index of an accessor containing keyframe input values, e.g., time.
 [required]</li>
<li>interpolation:      Interpolation algorithm.</li>
<li>output:      The index of an accessor, containing keyframe output values. [required]</li>
</ul>
</li>
</ul>
<h4>Struct glTFAnimation</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAnimation</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFAnimationChannel</span><span class="o">*&gt;</span> <span class="n">channels</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFAnimationSampler</span><span class="o">*&gt;</span> <span class="n">samplers</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAnimationChannel</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAnimationChannel</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFAnimationSampler</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAnimationSampler</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="o">~</span><span class="n">glTFAnimation</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>A keyframe animation.</p>
<ul>
<li>Members:<ul>
<li>channels:      An array of channels, each of which targets an animation's sampler at a
 node's property. Different channels of the same animation can't have
 equal targets. [required]</li>
<li>samplers:      An array of samplers that combines input and output accessors with an
 interpolation algorithm to define a keyframe graph (but not its target).
 [required]</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>~glTFAnimation():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Struct glTFAsset</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFAsset</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">copyright</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">generator</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">version</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">minVersion</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Metadata about the glTF asset.</p>
<ul>
<li>Members:<ul>
<li>copyright:      A copyright message suitable for display to credit the content creator.</li>
<li>generator:      Tool that generated this glTF model.  Useful for debugging.</li>
<li>version:      The glTF version that this asset targets. [required]</li>
<li>minVersion:      The minimum glTF version that this asset targets.</li>
</ul>
</li>
</ul>
<h4>Struct glTFBuffer</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFBuffer</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">uri</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">byteLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">buffer_data</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>A buffer points to binary geometry, animation, or skins.</p>
<ul>
<li>Members:<ul>
<li>uri:      The uri of the buffer.</li>
<li>byteLength:      The length of the buffer in bytes. [required]</li>
<li>data:      Stores buffer content after loading. [required]</li>
</ul>
</li>
</ul>
<h4>Enum class glTFBufferViewTarget</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFBufferViewTarget</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFBufferView::target</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFBufferView</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFBufferView</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBuffer</span><span class="o">&gt;</span> <span class="n">buffer</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">byteOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">byteLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">byteStride</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">glTFBufferViewTarget</span> <span class="n">target</span> <span class="o">=</span> <span class="n">glTFBufferViewTarget</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>A view into a buffer generally representing a subset of the buffer.</p>
<ul>
<li>Members:<ul>
<li>buffer:      The index of the buffer. [required]</li>
<li>byteOffset:      The offset into the buffer in bytes.</li>
<li>byteLength:      The length of the bufferView in bytes. [required]</li>
<li>byteStride:      The stride, in bytes.</li>
<li>target:      The target that the GPU buffer should be bound to.</li>
</ul>
</li>
</ul>
<h4>Struct glTFCameraOrthographic</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFCameraOrthographic</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">xmag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">ymag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">zfar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">znear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>An orthographic camera containing properties to create an orthographic
projection matrix.</p>
<ul>
<li>Members:<ul>
<li>xmag:      The floating-point horizontal magnification of the view. [required]</li>
<li>ymag:      The floating-point vertical magnification of the view. [required]</li>
<li>zfar:      The floating-point distance to the far clipping plane. <code>zfar</code> must be
 greater than <code>znear</code>. [required]</li>
<li>znear:      The floating-point distance to the near clipping plane. [required]</li>
</ul>
</li>
</ul>
<h4>Struct glTFCameraPerspective</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFCameraPerspective</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">aspectRatio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">yfov</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">zfar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">znear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>A perspective camera containing properties to create a perspective
projection matrix.</p>
<ul>
<li>Members:<ul>
<li>aspectRatio:      The floating-point aspect ratio of the field of view.</li>
<li>yfov:      The floating-point vertical field of view in radians. [required]</li>
<li>zfar:      The floating-point distance to the far clipping plane.</li>
<li>znear:      The floating-point distance to the near clipping plane. [required]</li>
</ul>
</li>
</ul>
<h4>Enum class glTFCameraType</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFCameraType</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFCamera::type</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFCamera</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFCamera</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFCameraOrthographic</span><span class="o">*</span> <span class="n">orthographic</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFCameraPerspective</span><span class="o">*</span> <span class="n">perspective</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFCameraType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">glTFCameraType</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFCamera</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>A camera's projection.  A node can reference a camera to apply a transform
to place the camera in the scene.</p>
<ul>
<li>Members:<ul>
<li>orthographic:      An orthographic camera containing properties to create an orthographic
 projection matrix.</li>
<li>perspective:      A perspective camera containing properties to create a perspective
 projection matrix.</li>
<li>type:      Specifies if the camera uses a perspective or orthographic projection.
 [required]</li>
<li>~glTFCamera():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Enum class glTFImageMimeType</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFImageMimeType</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFImage::mimeType</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFImage</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFImage</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">uri</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="n">glTFImageMimeType</span> <span class="n">mimeType</span> <span class="o">=</span> <span class="n">glTFImageMimeType</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">&gt;</span> <span class="n">bufferView</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">image_data</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Image data used to create a texture. Image can be referenced by URI or
<code>bufferView</code> index. <code>mimeType</code> is required in the latter case.</p>
<ul>
<li>Members:<ul>
<li>uri:      The uri of the image.</li>
<li>mimeType:      The image's MIME type.</li>
<li>bufferView:      The index of the bufferView that contains the image. Use this instead of
 the image's uri property.</li>
<li>data:      Stores image content after loading.</li>
</ul>
</li>
</ul>
<h4>Struct glTFTextureInfo</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFTextureInfo</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFTexture</span><span class="o">&gt;</span> <span class="n">index</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">texCoord</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Reference to a texture.</p>
<ul>
<li>Members:<ul>
<li>index:      The index of the texture. [required]</li>
<li>texCoord:      The set index of texture's TEXCOORD attribute used for texture
 coordinate mapping.</li>
</ul>
</li>
</ul>
<h4>Struct glTFTexture</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFTexture</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFSampler</span><span class="o">&gt;</span> <span class="n">sampler</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFImage</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>A texture and its sampler.</p>
<ul>
<li>Members:<ul>
<li>sampler:      The index of the sampler used by this texture. When undefined, a sampler
 with repeat wrapping and auto filtering should be used.</li>
<li>source:      The index of the image used by this texture.</li>
</ul>
</li>
</ul>
<h4>Struct glTFMaterialNormalTextureInfo</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMaterialNormalTextureInfo</span> <span class="p">:</span> <span class="n">glTFTextureInfo</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Normal texture information.</p>
<ul>
<li>Members:<ul>
<li>scale:      The scalar multiplier applied to each normal vector of the normal
 texture.</li>
</ul>
</li>
</ul>
<h4>Struct glTFMaterialOcclusionTextureInfo</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMaterialOcclusionTextureInfo</span> <span class="p">:</span> <span class="n">glTFTextureInfo</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">strength</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Occlusion texture information.</p>
<ul>
<li>Members:<ul>
<li>strength:      A scalar multiplier controlling the amount of occlusion applied.</li>
</ul>
</li>
</ul>
<h4>Struct glTFMaterialPbrMetallicRoughness</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMaterialPbrMetallicRoughness</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">vec4f</span> <span class="n">baseColorFactor</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">glTFTextureInfo</span><span class="o">*</span> <span class="n">baseColorTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">metallicFactor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">roughnessFactor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">glTFTextureInfo</span><span class="o">*</span> <span class="n">metallicRoughnessTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFMaterialPbrMetallicRoughness</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>A set of parameter values that are used to define the metallic-roughness
material model from Physically-Based Rendering (PBR) methodology.</p>
<ul>
<li>Members:<ul>
<li>baseColorFactor:      The material's base color factor.</li>
<li>baseColorTexture:      The base color texture.</li>
<li>metallicFactor:      The metalness of the material.</li>
<li>roughnessFactor:      The roughness of the material.</li>
<li>metallicRoughnessTexture:      The metallic-roughness texture.</li>
<li>~glTFMaterialPbrMetallicRoughness():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Struct glTFMaterialPbrSpecularGlossiness</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMaterialPbrSpecularGlossiness</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">vec4f</span> <span class="n">diffuseFactor</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">glTFTextureInfo</span><span class="o">*</span> <span class="n">diffuseTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">specularFactor</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">glossinessFactor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">glTFTextureInfo</span><span class="o">*</span> <span class="n">specularGlossinessTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFMaterialPbrSpecularGlossiness</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>glTF extension that defines the specular-glossiness material model from
Physically-Based Rendering (PBR) methodology.</p>
<ul>
<li>Members:<ul>
<li>diffuseFactor:      The reflected diffuse factor of the material.</li>
<li>diffuseTexture:      The diffuse texture.</li>
<li>specularFactor:      The specular RGB color of the material.</li>
<li>glossinessFactor:      The glossiness or smoothness of the material.</li>
<li>specularGlossinessTexture:      The specular-glossiness texture.</li>
<li>~glTFMaterialPbrSpecularGlossiness():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Enum class glTFMaterialAlphaMode</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFMaterialAlphaMode</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFMaterial::alphaMode</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFMaterial</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMaterial</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFMaterialPbrMetallicRoughness</span><span class="o">*</span> <span class="n">pbrMetallicRoughness</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFMaterialPbrSpecularGlossiness</span><span class="o">*</span> <span class="n">pbrSpecularGlossiness</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFMaterialNormalTextureInfo</span><span class="o">*</span> <span class="n">normalTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFMaterialOcclusionTextureInfo</span><span class="o">*</span> <span class="n">occlusionTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">glTFTextureInfo</span><span class="o">*</span> <span class="n">emissiveTexture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">vec3f</span> <span class="n">emissiveFactor</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">glTFMaterialAlphaMode</span> <span class="n">alphaMode</span> <span class="o">=</span> <span class="n">glTFMaterialAlphaMode</span><span class="o">::</span><span class="n">Opaque</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">alphaCutoff</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">doubleSided</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="o">~</span><span class="n">glTFMaterial</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>The material appearance of a primitive.</p>
<ul>
<li>Members:<ul>
<li>pbrMetallicRoughness:      A set of parameter values that are used to define the metallic-roughness
 material model from Physically-Based Rendering (PBR) methodology. When
 not specified, all the default values of <code>pbrMetallicRoughness</code> apply.</li>
<li>pbrSpecularGlossiness:      A set of parameter values that are used to define the
 specular-glossiness material model from Physically-Based Rendering (PBR)
 methodology. When not specified, all the default values of
 <code>pbrMetallicRoughness</code> apply.</li>
<li>normalTexture:      The normal map texture.</li>
<li>occlusionTexture:      The occlusion map texture.</li>
<li>emissiveTexture:      The emissive map texture.</li>
<li>emissiveFactor:      The emissive color of the material.</li>
<li>alphaMode:      The alpha rendering mode of the material.</li>
<li>alphaCutoff:      The alpha cutoff value of the material.</li>
<li>doubleSided:      Specifies whether the material is double sided.</li>
<li>~glTFMaterial():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Enum class glTFMeshPrimitiveMode</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFMeshPrimitiveMode</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFMeshPrimitive::mode</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFMeshPrimitive</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMeshPrimitive</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;&gt;</span> <span class="n">attributes</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;</span> <span class="n">indices</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFMaterial</span><span class="o">&gt;</span> <span class="n">material</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFMeshPrimitiveMode</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">glTFMeshPrimitiveMode</span><span class="o">::</span><span class="n">Triangles</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;&gt;&gt;</span> <span class="n">targets</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Geometry to be rendered with the given material.</p>
<ul>
<li>Members:<ul>
<li>attributes:      A dictionary object, where each key corresponds to mesh attribute
 semantic and each value is the index of the accessor containing
 attribute's data. [required]</li>
<li>indices:      The index of the accessor that contains the indices.</li>
<li>material:      The index of the material to apply to this primitive when rendering.</li>
<li>mode:      The type of primitives to render.</li>
<li>targets:      An array of Morph Targets, each  Morph Target is a dictionary mapping
 attributes (only <code>POSITION</code>, <code>NORMAL</code>, and <code>TANGENT</code> supported) to their
 deviations in the Morph Target.</li>
</ul>
</li>
</ul>
<h4>Struct glTFMesh</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFMesh</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFMeshPrimitive</span><span class="o">*&gt;</span> <span class="n">primitives</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">weights</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="o">~</span><span class="n">glTFMesh</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>A set of primitives to be rendered.  A node can contain one mesh.  A node's
transform places the mesh in the scene.</p>
<ul>
<li>Members:<ul>
<li>primitives:      An array of primitives, each defining geometry to be rendered with a
 material. [required]</li>
<li>weights:      Array of weights to be applied to the Morph Targets.</li>
<li>~glTFMesh():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Struct glTFNode</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFNode</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFCamera</span><span class="o">&gt;</span> <span class="n">camera</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;&gt;</span> <span class="n">children</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFSkin</span><span class="o">&gt;</span> <span class="n">skin</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">mat4f</span> <span class="n">matrix</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span> <span class="p">};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFMesh</span><span class="o">&gt;</span> <span class="n">mesh</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">quat4f</span> <span class="n">rotation</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">scale</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">translation</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">weights</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>A node in the node hierarchy.  When the node contains <code>skin</code>, all
<code>mesh.primitives</code> must contain <code>JOINTS_0</code> and <code>WEIGHTS_0</code> attributes.  A
node can have either a <code>matrix</code> or any combination of
<code>translation</code>/<code>rotation</code>/<code>scale</code> (TRS) properties. TRS properties are
converted to matrices and postmultiplied in the <code>T * R * S</code> order to compose
the transformation matrix; first the scale is applied to the vertices, then
the rotation, and then the translation. If none are provided, the transform
is the identity. When a node is targeted for animation (referenced by an
animation.channel.target), only TRS properties may be present; <code>matrix</code> will
not be present.</p>
<ul>
<li>Members:<ul>
<li>camera:      The index of the camera referenced by this node.</li>
<li>children:      The indices of this node's children.</li>
<li>skin:      The index of the skin referenced by this node.</li>
<li>matrix:      A floating-point 4x4 transformation matrix stored in column-major order.</li>
<li>mesh:      The index of the mesh in this node.</li>
<li>rotation:      The node's unit quaternion rotation in the order (x, y, z, w), where w
 is the scalar.</li>
<li>scale:      The node's non-uniform scale.</li>
<li>translation:      The node's translation.</li>
<li>weights:      The weights of the instantiated Morph Target. Number of elements must
 match number of Morph Targets of used mesh.</li>
</ul>
</li>
</ul>
<h4>Enum class glTFSamplerMagFilter</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFSamplerMagFilter</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFSampler::magFilter</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Enum class glTFSamplerMinFilter</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFSamplerMinFilter</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Values for glTFSampler::minFilter</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Enum class glTFSamplerWrapS</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFSamplerWrapS</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>glTFSampler::wrapS</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Enum class glTFSamplerWrapT</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">glTFSamplerWrapT</span> <span class="p">{</span>
    <span class="n">NotSet</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>glTFSampler::wrapT</p>
<ul>
<li>Values:<ul>
<li>NotSet:      Not set</li>
</ul>
</li>
</ul>
<h4>Struct glTFSampler</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFSampler</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFSamplerMagFilter</span> <span class="n">magFilter</span> <span class="o">=</span> <span class="n">glTFSamplerMagFilter</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="n">glTFSamplerMinFilter</span> <span class="n">minFilter</span> <span class="o">=</span> <span class="n">glTFSamplerMinFilter</span><span class="o">::</span><span class="n">NotSet</span><span class="p">;</span>
    <span class="n">glTFSamplerWrapS</span> <span class="n">wrapS</span> <span class="o">=</span> <span class="n">glTFSamplerWrapS</span><span class="o">::</span><span class="n">Repeat</span><span class="p">;</span>
    <span class="n">glTFSamplerWrapT</span> <span class="n">wrapT</span> <span class="o">=</span> <span class="n">glTFSamplerWrapT</span><span class="o">::</span><span class="n">Repeat</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Texture sampler properties for filtering and wrapping modes.</p>
<ul>
<li>Members:<ul>
<li>magFilter:      Magnification filter.</li>
<li>minFilter:      Minification filter.</li>
<li>wrapS:      s wrapping mode.</li>
<li>wrapT:      t wrapping mode.</li>
</ul>
</li>
</ul>
<h4>Struct glTFScene</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFScene</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>The root nodes of a scene.</p>
<ul>
<li>Members:<ul>
<li>nodes:      The indices of each root node.</li>
</ul>
</li>
</ul>
<h4>Struct glTFSkin</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTFSkin</span> <span class="p">:</span> <span class="n">glTFChildOfRootProperty</span> <span class="p">{</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;</span> <span class="n">inverseBindMatrices</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;</span> <span class="n">skeleton</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;&gt;</span> <span class="n">joints</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div>


<p>Joints and matrices defining a skin.</p>
<ul>
<li>Members:<ul>
<li>inverseBindMatrices:      The index of the accessor containing the floating-point 4x4 inverse-bind
 matrices.  The default is that each matrix is a 4x4 identity matrix,
 which implies that inverse-bind matrices were pre-applied.</li>
<li>skeleton:      The index of the node used as a skeleton root. When undefined, joints
 transforms resolve to scene root.</li>
<li>joints:      Indices of skeleton nodes, used as joints in this skin. [required]</li>
</ul>
</li>
</ul>
<h4>Struct glTF</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="nl">glTF</span> <span class="p">:</span> <span class="n">glTFProperty</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">extensionsUsed</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">extensionsRequired</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">*&gt;</span> <span class="n">accessors</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFAnimation</span><span class="o">*&gt;</span> <span class="n">animations</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAsset</span><span class="o">*</span> <span class="n">asset</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFBuffer</span><span class="o">*&gt;</span> <span class="n">buffers</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">*&gt;</span> <span class="n">bufferViews</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFCamera</span><span class="o">*&gt;</span> <span class="n">cameras</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFImage</span><span class="o">*&gt;</span> <span class="n">images</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFMaterial</span><span class="o">*&gt;</span> <span class="n">materials</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFMesh</span><span class="o">*&gt;</span> <span class="n">meshes</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">*&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFSampler</span><span class="o">*&gt;</span> <span class="n">samplers</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFScene</span><span class="o">&gt;</span> <span class="n">scene</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFScene</span><span class="o">*&gt;</span> <span class="n">scenes</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFSkin</span><span class="o">*&gt;</span> <span class="n">skins</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">glTFTexture</span><span class="o">*&gt;</span> <span class="n">textures</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">glTFAccessor</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAccessor</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFAnimation</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFAnimation</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFBuffer</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBuffer</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFBufferView</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFBufferView</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFCamera</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFCamera</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFImage</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFImage</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFMaterial</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFMaterial</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFMesh</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFMesh</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFNode</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFNode</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFSampler</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFSampler</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFScene</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFScene</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFSkin</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFSkin</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">glTFTexture</span><span class="o">*</span> <span class="nf">get</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFid</span><span class="o">&lt;</span><span class="n">glTFTexture</span><span class="o">&gt;&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="o">~</span><span class="n">glTF</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>The root object for a glTF asset.</p>
<ul>
<li>Members:<ul>
<li>extensionsUsed:      Names of glTF extensions used somewhere in this asset.</li>
<li>extensionsRequired:      Names of glTF extensions required to properly load this asset.</li>
<li>accessors:      An array of accessors.</li>
<li>animations:      An array of keyframe animations.</li>
<li>asset:      Metadata about the glTF asset. [required]</li>
<li>buffers:      An array of buffers.</li>
<li>bufferViews:      An array of bufferViews.</li>
<li>cameras:      An array of cameras.</li>
<li>images:      An array of images.</li>
<li>materials:      An array of materials.</li>
<li>meshes:      An array of meshes.</li>
<li>nodes:      An array of nodes.</li>
<li>samplers:      An array of samplers.</li>
<li>scene:      The index of the default scene.</li>
<li>scenes:      An array of scenes.</li>
<li>skins:      An array of skins.</li>
<li>textures:      An array of textures.</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>get():      typed access for nodes</li>
<li>~glTF():      Cleanup</li>
</ul>
</li>
</ul>
<h4>Function load_gltf()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">glTF</span><span class="o">*</span> <span class="nf">load_gltf</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">load_bin</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">load_img</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Loads a gltf file from disk</p>
<ul>
<li>Parameters:<ul>
<li>filename: scene filename</li>
<li>load_bin/load_img: load binary data</li>
<li>skip_missing: do not throw an exception if a file is missing</li>
</ul>
</li>
<li>Returns:<ul>
<li>gltf data loaded (nullptr on error)</li>
</ul>
</li>
</ul>
<h4>Function load_binary_gltf()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">glTF</span><span class="o">*</span> <span class="nf">load_binary_gltf</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">load_bin</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">load_img</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">skip_missing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Loads a binary gltf file from disk</p>
<ul>
<li>Parameters:<ul>
<li>filename: scene filename</li>
<li>other params as above</li>
</ul>
</li>
<li>Returns:<ul>
<li>gltf data loaded (nullptr on error)</li>
</ul>
</li>
</ul>
<h4>Function save_gltf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">save_gltf</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">glTF</span><span class="o">*</span> <span class="n">gltf</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">save_bin</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">save_images</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Saves a scene to disk</p>
<ul>
<li>Parameters:<ul>
<li>filename: scene filename</li>
<li>gltf: data to save</li>
<li>save_bin/save_images: save binary data</li>
</ul>
</li>
</ul>
<h4>Function save_binary_gltf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">save_binary_gltf</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">glTF</span><span class="o">*</span> <span class="n">gltf</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">save_bin</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">save_images</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Saves a scene to disk</p>
<ul>
<li>Parameters:<ul>
<li>filename: scene filename</li>
<li>gltf: data to save</li>
<li>save_bin/save_images: save binary data</li>
</ul>
</li>
</ul>
<h4>Function node_transform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">mat4f</span> <span class="nf">node_transform</span><span class="p">(</span><span class="k">const</span> <span class="n">glTFNode</span><span class="o">*</span> <span class="n">node</span><span class="p">);</span>
</code></pre></div>


<p>Computes the local node transform and its inverse.</p>
<h4>Struct accessor_view</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">accessor_view</span> <span class="p">{</span>
    <span class="n">accessor_view</span><span class="p">(</span><span class="k">const</span> <span class="n">glTF</span><span class="o">*</span> <span class="n">gltf</span><span class="p">,</span> <span class="k">const</span> <span class="n">glTFAccessor</span><span class="o">*</span> <span class="n">accessor</span><span class="p">);</span> 
    <span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="nf">count</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="nf">ncomp</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">bool</span> <span class="nf">valid</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec2f</span> <span class="n">getv2f</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span> 
    <span class="n">vec3f</span> <span class="n">getv3f</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span> 
    <span class="n">vec4f</span> <span class="n">getv4f</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span> 
    <span class="n">mat4f</span> <span class="nf">getm4f</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="kt">float</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
    <span class="n">vec2i</span> <span class="n">getv2i</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span> 
    <span class="n">vec3i</span> <span class="n">getv3i</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span> 
    <span class="n">vec4i</span> <span class="n">getv4i</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="nf">geti</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>


<p>A view for gltf array buffers that allows for typed access.</p>
<ul>
<li>Members:<ul>
<li>accessor_view():      construct a view from an accessor</li>
<li>size():      number of elements in the view</li>
<li>count():      number of elements in the view</li>
<li>ncomp():      number of components per element</li>
<li>valid():      check whether the view is valid</li>
<li>getv2f():      get the idx-th element of fixed length width default values</li>
<li>getv3f():      get the idx-th element of fixed length width default values</li>
<li>getv4f():      get the idx-th element of fixed length width default values</li>
<li>getm4f():      get the idx-th element of fixed length as a matrix</li>
<li>get():      get the c-th component of the idx-th element</li>
<li>getv2i():      get the idx-th element as integer with fixed length</li>
<li>getv3i():      get the idx-th element as integer with fixed length</li>
<li>getv4i():      get the idx-th element as integer with fixed length</li>
<li>geti():      get the c-th component of the idx-th element as integer</li>
</ul>
</li>
</ul>
<h4>Function startswith()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">startswith</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">substr</span><span class="p">);</span>
</code></pre></div>


<p>Checks if a string starts with a prefix.</p>
<h4>Function endswith()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">endswith</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">substr</span><span class="p">);</span>
</code></pre></div>


<p>Checks if a string ends with a prefix.</p>
<h4>Function contains()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">substr</span><span class="p">);</span>
</code></pre></div>


<p>Check is a string contains a substring.</p>
<h4>Function splitlines()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">splitlines</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keep_newline</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Splits a string into lines at the '\n' character. The line
terminator is kept if keep_newline. This function does not work on
Window if keep_newline is true.</p>
<h4>Function partition()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">partition</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">split</span><span class="p">);</span>
</code></pre></div>


<p>Partition the string.</p>
<h4>Function split()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">split</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Splits the string.</p>
<h4>Function split()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">split</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">substr</span><span class="p">);</span>
</code></pre></div>


<p>Splits the string.</p>
<h4>Function split()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">split</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="kt">char</span> <span class="n">substr</span><span class="p">);</span>
</code></pre></div>


<p>Splits the string.</p>
<h4>Function rstrip()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">string</span> <span class="nf">rstrip</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Strip the string.</p>
<h4>Function lstrip()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">string</span> <span class="nf">lstrip</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Strip the string.</p>
<h4>Function strip()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">string</span> <span class="nf">strip</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Strip the string.</p>
<h4>Function join()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">string</span> <span class="nf">join</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">strs</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">sep</span><span class="p">);</span>
</code></pre></div>


<p>Joins a list of string with a string as separator.</p>
<h4>Function lower()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">string</span> <span class="nf">lower</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Converts an ASCII string to lowercase.</p>
<h4>Function upper()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">string</span> <span class="nf">upper</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Converts an ASCII string to uppercase.</p>
<h4>Function isspace()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">isspace</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Check if a string is space.</p>
<h4>Function replace()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">string</span> <span class="nf">replace</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s2</span><span class="p">);</span>
</code></pre></div>


<p>Replace s1 with s2 in str.</p>
<h4>Function path_dirname()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">string</span> <span class="nf">path_dirname</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Get directory name (including '/').</p>
<h4>Function path_extension()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">string</span> <span class="nf">path_extension</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Get extension (including '.').</p>
<h4>Function path_basename()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">string</span> <span class="nf">path_basename</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Get file basename.</p>
<h4>Function path_filename()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">string</span> <span class="nf">path_filename</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Get filename without directory (equiv to get_basename() +
get_extension()).</p>
<h4>Function replace_path_extension()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">string</span> <span class="nf">replace_path_extension</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">ext</span><span class="p">);</span>
</code></pre></div>


<p>Replace extension.</p>
<h4>Function prepend_path_extension()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">string</span> <span class="nf">prepend_path_extension</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">prep</span><span class="p">);</span>
</code></pre></div>


<p>Prepend a string to the extension.</p>
<h4>Function split_path()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">split_path</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">dirname</span><span class="p">,</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">basename</span><span class="p">,</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">ext</span><span class="p">);</span>
</code></pre></div>


<p>Splits a path calling the above functions.</p>
<h4>Function format()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">string</span> <span class="nf">format</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Really-minimal Python like string format. The implementation is not fast
nor memory efficient. But it is good enough for some needs.</p>
<h4>Function format()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">string</span> <span class="n">format</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Really-minimal Python like string format. Internally uses streams for
generality and supports for now only the '{}' operator. The implementation
is not fast nor memory efficient. But it is good enough for some needs.</p>
<h4>Function print()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Wrapper for the above function that prints to stdout.</p>
<h4>Function println()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">println</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Wrapper for the above function that prints to stdout with endline.</p>
<h4>Function load_binfile()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">load_binfile</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Loads the contents of a binary file in an in-memory array.</p>
<h4>Function load_txtfile()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">string</span> <span class="nf">load_txtfile</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
</code></pre></div>


<p>Loads the contents of a text file into a string.</p>
<h4>Function save_binfile()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_binfile</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">);</span>
</code></pre></div>


<p>Saves binary data to a file.</p>
<h4>Function save_txtfile()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_txtfile</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Saves a string to a text file.</p>
<h4>Struct cmdline_parser</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">cmdline_parser</span><span class="p">;</span>
</code></pre></div>


<p>Immediate mode command line parser (opaque type)</p>
<h4>Struct cmdline_parser</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">cmdline_parser</span> <span class="p">{</span>
</code></pre></div>


<p>Immediate mode command line parser</p>
<h4>Function should_exit()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">should_exit</span><span class="p">(</span><span class="n">cmdline_parser</span><span class="o">&amp;</span> <span class="n">parser</span><span class="p">);</span>
</code></pre></div>


<p>check unused arguments</p>
<h4>Function get_usage()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">string</span> <span class="nf">get_usage</span><span class="p">(</span><span class="k">const</span> <span class="n">cmdline_parser</span><span class="o">&amp;</span> <span class="n">parser</span><span class="p">);</span>
</code></pre></div>


<p>returns the usage string</p>
<h4>Function parse_flag()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">parse_flag</span><span class="p">(</span><span class="n">cmdline_parser</span><span class="o">&amp;</span> <span class="n">parser</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">flag</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">help</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">def</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">req</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>parse a flag from the command line</p>
<h4>Function parse_opt()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">parse_opt</span><span class="p">(</span><span class="n">cmdline_parser</span><span class="o">&amp;</span> <span class="n">parser</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">flag</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">help</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">def</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>parse an option from the command line</p>
<h4>Function parse_opt()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">parse_opt</span><span class="p">(</span><span class="n">cmdline_parser</span><span class="o">&amp;</span> <span class="n">parser</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">flag</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">help</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;&amp;</span> <span class="n">key_values</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">def</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">req</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">choices</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>parse an enum option from the command line</p>
<h4>Function make_parser()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">cmdline_parser</span> <span class="nf">make_parser</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">help</span><span class="p">);</span>
</code></pre></div>


<p>initialize the command line</p>
<h4>Struct logger</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">logger</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">_verbose</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">_console</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">_file</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Logger object. A logger can output messages to multiple streams.
Use add streams commands for it.</p>
<ul>
<li>Members:<ul>
<li>_verbose:      whether to output verbose</li>
<li>_console:      whether to output to console</li>
<li>_file:      file stream for stream output</li>
</ul>
</li>
</ul>
<h4>Function make_logger()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">logger</span><span class="o">*</span> <span class="nf">make_logger</span><span class="p">(</span><span class="kt">bool</span> <span class="n">console</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">verbose</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Make a logger with an optional console stream and a verbosity level</p>
<h4>Function add_file_stream()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_file_stream</span><span class="p">(</span><span class="n">logger</span><span class="o">*</span> <span class="n">lgr</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">append</span><span class="p">);</span>
</code></pre></div>


<p>Add a file stream to a logger.</p>
<ul>
<li>Parameters:<ul>
<li>lgr: logger</li>
<li>filename: filename</li>
<li>append: append or write open mode for file logger</li>
<li>short_message: whether to use a short message version</li>
<li>output_level: output level</li>
<li>flush_level: output level</li>
</ul>
</li>
<li>Returns:<ul>
<li>true if ok</li>
</ul>
</li>
</ul>
<h4>Function get_default_logger()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">logger</span><span class="o">*</span> <span class="nf">get_default_logger</span><span class="p">();</span>
</code></pre></div>


<p>Get default logger.
By default a non-verbose stdout logger is creater.</p>
<h4>Function log_info()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">log_info</span><span class="p">(</span><span class="n">logger</span><span class="o">*</span> <span class="n">lgr</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Log a info message</p>
<h4>Function log_warning()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">log_warning</span><span class="p">(</span><span class="n">logger</span><span class="o">*</span> <span class="n">lgr</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Log a info message</p>
<h4>Function log_error()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">log_error</span><span class="p">(</span><span class="n">logger</span><span class="o">*</span> <span class="n">lgr</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Log an error message</p>
<h4>Function log_fatal()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">log_fatal</span><span class="p">(</span><span class="n">logger</span><span class="o">*</span> <span class="n">lgr</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Log a fatal message and exit</p>
<h4>Function add_file_stream()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_file_stream</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">append</span><span class="p">);</span>
</code></pre></div>


<p>Adds a file stream to the default logger</p>
<h4>Function log_info()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">log_info</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Logs a message to the default loggers</p>
<h4>Function log_error()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">log_error</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Logs a message to the default loggers</p>
<h4>Function log_fatal()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">log_fatal</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Logs a message to the default loggers</p>
<h4>Struct thread_pool</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">thread_pool</span> <span class="p">{</span>
</code></pre></div>


<p>Thread pool for concurrency. This code is derived from LLVM ThreadPool</p>
<h4>Function make_pool()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">thread_pool</span><span class="o">*</span> <span class="nf">make_pool</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">nthreads</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">());</span>
</code></pre></div>


<p>Makes a thread pool</p>
<h4>Function run_async()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">run_async</span><span class="p">(</span>
    <span class="n">thread_pool</span><span class="o">*</span> <span class="n">pool</span><span class="p">,</span> <span class="k">const</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&amp;</span> <span class="n">task</span><span class="p">);</span>
</code></pre></div>


<p>Runs a task asynchronously onto the global thread pool</p>
<h4>Function wait_pool()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wait_pool</span><span class="p">(</span><span class="n">thread_pool</span><span class="o">*</span> <span class="n">pool</span><span class="p">);</span>
</code></pre></div>


<p>Wait for all jobs to finish on the global thread pool</p>
<h4>Function clear_pool()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_pool</span><span class="p">(</span><span class="n">thread_pool</span><span class="o">*</span> <span class="n">pool</span><span class="p">);</span>
</code></pre></div>


<p>Clear all jobs on the global thread pool</p>
<h4>Function parallel_for()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">parallel_for</span><span class="p">(</span>
    <span class="n">thread_pool</span><span class="o">*</span> <span class="n">pool</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span><span class="o">&gt;&amp;</span> <span class="n">task</span><span class="p">);</span>
</code></pre></div>


<p>Parallel for implementation on the global thread pool</p>
<h4>Function get_global_pool()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">thread_pool</span><span class="o">*</span> <span class="nf">get_global_pool</span><span class="p">();</span>
</code></pre></div>


<p>Global pool</p>
<h4>Function run_async()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">run_async</span><span class="p">(</span><span class="k">const</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&amp;</span> <span class="n">task</span><span class="p">);</span>
</code></pre></div>


<p>Runs a task asynchronously onto the global thread pool</p>
<h4>Function wait_pool()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wait_pool</span><span class="p">();</span>
</code></pre></div>


<p>Wait for all jobs to finish on the global thread pool</p>
<h4>Function clear_pool()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_pool</span><span class="p">();</span>
</code></pre></div>


<p>Clear all jobs on the global thread pool</p>
<h4>Function parallel_for()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">parallel_for</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span><span class="o">&gt;&amp;</span> <span class="n">task</span><span class="p">);</span>
</code></pre></div>


<p>Parallel for implementation on the global thread pool</p>
<h4>Struct timer</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">timer</span> <span class="p">{</span>
    <span class="n">timer</span><span class="p">(</span><span class="kt">bool</span> <span class="n">autostart</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span> 
    <span class="kt">void</span> <span class="nf">start</span><span class="p">();</span> 
    <span class="kt">void</span> <span class="nf">stop</span><span class="p">();</span> 
    <span class="kt">double</span> <span class="nf">elapsed</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div>


<p>A simple wrapper for std::chrono.</p>
<ul>
<li>Members:<ul>
<li>timer():      initialize a timer and start it if necessary</li>
<li>start():      start a timer</li>
<li>stop():      stops a timer</li>
<li>elapsed():      elapsed time</li>
</ul>
</li>
</ul>
<h4>Enum gl_etype : int</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="nl">gl_etype</span> <span class="p">:</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">line</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">triangle</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">quad</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Shape types</p>
<ul>
<li>Values:<ul>
<li>point:      points</li>
<li>line:      lines</li>
<li>triangle:      triangles</li>
<li>quad:      quads</li>
</ul>
</li>
</ul>
<h4>Enum gl_ltype : int</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="nl">gl_ltype</span> <span class="p">:</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">directional</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Light types</p>
<ul>
<li>Values:<ul>
<li>point:      point lights</li>
<li>directional:      directional lights</li>
</ul>
</li>
</ul>
<h4>Function gl_check_error()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">gl_check_error</span><span class="p">(</span><span class="kt">bool</span> <span class="n">print</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div>


<p>Checks for GL error and then prints</p>
<h4>Function gl_clear_buffers()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="n">gl_clear_buffers</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">background</span> <span class="o">=</span><span class="p">;</span>
</code></pre></div>


<p>Clear window</p>
<h4>Function gl_enable_depth_test()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_enable_depth_test</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">);</span>
</code></pre></div>


<p>Enable/disable depth test</p>
<h4>Function gl_enable_culling()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_enable_culling</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">);</span>
</code></pre></div>


<p>Enable/disable culling</p>
<h4>Function gl_enable_wireframe()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_enable_wireframe</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">);</span>
</code></pre></div>


<p>Enable/disable wireframe</p>
<h4>Function gl_enable_edges()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_enable_edges</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tolerance</span> <span class="o">=</span> <span class="mf">0.9999f</span><span class="p">);</span>
</code></pre></div>


<p>Enable/disable edges. Attempts to avoid z-fighting but the method is not
robust.</p>
<h4>Function gl_enable_blending()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_enable_blending</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">);</span>
</code></pre></div>


<p>Enable/disable blending</p>
<h4>Function gl_set_blend_over()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_set_blend_over</span><span class="p">();</span>
</code></pre></div>


<p>Set blending to over operator</p>
<h4>Function gl_line_width()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_line_width</span><span class="p">(</span><span class="kt">float</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div>


<p>Line width</p>
<h4>Function gl_set_viewport()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_set_viewport</span><span class="p">(</span><span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>Set viewport</p>
<h4>Function gl_set_viewport()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">gl_set_viewport</span><span class="p">(</span><span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>


<p>Set viewport</p>
<h4>Struct gl_texture</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_texture</span> <span class="p">{</span>
</code></pre></div>


<p>Opengl texture object</p>
<h4>Function make_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_texture</span> <span class="nf">make_texture</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">pixels</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">linear</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">mipmap</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">as_float</span><span class="p">);</span>
</code></pre></div>


<p>Creates a texture with pixels values of size w, h with nc number of
components (1-4).
Internally use float if as_float and filtering if filter.
Returns the texture id.</p>
<h4>Function make_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_texture</span> <span class="nf">make_texture</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nc</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pixels</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">linear</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">mipmap</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">as_srgb</span><span class="p">);</span>
</code></pre></div>


<p>Creates a texture with pixels values of size w, h with nc number of
components (1-4).
Internally use srgb lookup if as_srgb and filtering if filter.
Returns the texture id.</p>
<h4>Function make_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_texture</span> <span class="nf">make_texture</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">linear</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">mipmap</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">as_float</span><span class="p">);</span>
</code></pre></div>


<p>Creates a texture from an image.
Internally use float if as_float and filtering if filter.
Returns the texture id.</p>
<h4>Function make_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_texture</span> <span class="nf">make_texture</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">image4b</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">linear</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">mipmap</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">as_srgb</span><span class="p">);</span>
</code></pre></div>


<p>Creates a texture from an image.
Internally use srgb lookup if as_srgb and filtering if filter.
Returns the texture id.</p>
<h4>Function update_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_texture</span><span class="p">(</span>
    <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">pixels</span><span class="p">);</span>
</code></pre></div>


<p>Updates the texture tid with new image data.</p>
<h4>Function update_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_texture</span><span class="p">(</span>
    <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pixels</span><span class="p">);</span>
</code></pre></div>


<p>Updates the texture tid with new image data.</p>
<h4>Function update_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_texture</span><span class="p">(</span><span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span> <span class="k">const</span> <span class="n">image4f</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">);</span>
</code></pre></div>


<p>Updates the texture tid with new image data.</p>
<h4>Function update_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_texture</span><span class="p">(</span><span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span> <span class="k">const</span> <span class="n">image4b</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">);</span>
</code></pre></div>


<p>Updates the texture tid with new image data.</p>
<h4>Function bind_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">bind_texture</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span> <span class="n">uint</span> <span class="n">unit</span><span class="p">);</span>
</code></pre></div>


<p>Binds a texture to a texture unit</p>
<h4>Function unbind_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">unbind_texture</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span> <span class="n">uint</span> <span class="n">unit</span><span class="p">);</span>
</code></pre></div>


<p>Unbinds</p>
<h4>Function get_texture_id()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">uint</span> <span class="nf">get_texture_id</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">);</span>
</code></pre></div>


<p>Get id</p>
<h4>Function is_texture_valid()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_texture_valid</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">);</span>
</code></pre></div>


<p>Check if defined</p>
<h4>Function clear_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">clear_texture</span><span class="p">(</span><span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">);</span>
</code></pre></div>


<p>Destroys the texture tid.</p>
<h4>Enum gl_texture_wrap</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">gl_texture_wrap</span> <span class="p">{</span>
    <span class="n">not_set</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">repeat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">clamp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">mirror</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Wrap values for texture</p>
<ul>
<li>Values:<ul>
<li>not_set:      not set</li>
<li>repeat:      repeat</li>
<li>clamp:      clamp to edge</li>
<li>mirror:      mirror</li>
</ul>
</li>
</ul>
<h4>Enum gl_texture_filter</h4>
<div class="codehilite"><pre><code><span></span><span class="k">enum</span> <span class="k">struct</span> <span class="n">gl_texture_filter</span> <span class="p">{</span>
    <span class="n">not_set</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">linear</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">nearest</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">linear_mipmap_linear</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">nearest_mipmap_nearest</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">linear_mipmap_nearest</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">nearest_mipmap_linear</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>


<p>Filter values for texture</p>
<ul>
<li>Values:<ul>
<li>not_set:      not set</li>
<li>linear:      linear</li>
<li>nearest:      nearest</li>
<li>linear_mipmap_linear:      mip-mapping</li>
<li>nearest_mipmap_nearest:      mip-mapping</li>
<li>linear_mipmap_nearest:      mip-mapping</li>
<li>nearest_mipmap_linear:      mip-mapping</li>
</ul>
</li>
</ul>
<h4>Struct gl_texture_info</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_texture_info</span> <span class="p">{</span>
    <span class="n">gl_texture</span> <span class="n">txt</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">texcoord</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">gl_texture_wrap</span> <span class="n">wrap_s</span> <span class="o">=</span> <span class="n">gl_texture_wrap</span><span class="o">::</span><span class="n">not_set</span><span class="p">;</span>
    <span class="n">gl_texture_wrap</span> <span class="n">wrap_t</span> <span class="o">=</span> <span class="n">gl_texture_wrap</span><span class="o">::</span><span class="n">not_set</span><span class="p">;</span>
    <span class="n">gl_texture_filter</span> <span class="n">filter_mag</span> <span class="o">=</span> <span class="n">gl_texture_filter</span><span class="o">::</span><span class="n">not_set</span><span class="p">;</span>
    <span class="n">gl_texture_filter</span> <span class="n">filter_min</span> <span class="o">=</span> <span class="n">gl_texture_filter</span><span class="o">::</span><span class="n">not_set</span><span class="p">;</span>
    <span class="n">gl_texture_info</span><span class="p">();</span> 
    <span class="n">gl_texture_info</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">tid</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div>


<p>Texture information for parameter setting.</p>
<ul>
<li>Members:<ul>
<li>txt:      texture</li>
<li>texcoord:      texture coordinate set</li>
<li>scale:      texture strength/scale (used by some models)</li>
<li>wrap_s:      wrap mode</li>
<li>wrap_t:      wrap mode</li>
<li>filter_mag:      filter mode</li>
<li>filter_min:      filter mode</li>
<li>gl_texture_info():      default constructor</li>
<li>gl_texture_info():      constructor from texture id only</li>
</ul>
</li>
</ul>
<h4>Struct gl_vertex_buffer</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_vertex_buffer</span> <span class="p">{</span>
</code></pre></div>


<p>OpenGL vertex/element buffer</p>
<h4>Function make_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_vertex_buffer</span> <span class="nf">make_vertex_buffer</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Creates a buffer.</p>
<h4>Function make_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_vertex_buffer</span> <span class="nf">make_vertex_buffer</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Creates a buffer.</p>
<h4>Function make_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_vertex_buffer</span> <span class="nf">make_vertex_buffer</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Creates a buffer.</p>
<h4>Function make_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_vertex_buffer</span> <span class="nf">make_vertex_buffer</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Creates a buffer.</p>
<h4>Function make_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_vertex_buffer</span> <span class="nf">make_vertex_buffer</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Creates a buffer.</p>
<h4>Function make_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_vertex_buffer</span> <span class="nf">make_vertex_buffer</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Creates a buffer.</p>
<h4>Function make_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_vertex_buffer</span> <span class="nf">make_vertex_buffer</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Creates a buffer.</p>
<h4>Function make_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_vertex_buffer</span> <span class="nf">make_vertex_buffer</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Creates a buffer.</p>
<h4>Function make_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_vertex_buffer</span> <span class="nf">make_vertex_buffer</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Creates a buffer.</p>
<h4>Function make_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_vertex_buffer</span> <span class="nf">make_vertex_buffer</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Creates a buffer.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span>
    <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span>
    <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span>
    <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer bid with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span>
    <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2f</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer bid with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span>
    <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3f</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer bid with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span>
    <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4f</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer bid with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span>
    <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer bid with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span>
    <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer bid with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span>
    <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer bid with new data.</p>
<h4>Function update_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_vertex_buffer</span><span class="p">(</span>
    <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer bid with new data.</p>
<h4>Function bind_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">bind_vertex_buffer</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="n">uint</span> <span class="n">vattr</span><span class="p">);</span>
</code></pre></div>


<p>Bind the buffer at a particular attribute location</p>
<h4>Function unbind_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">unbind_vertex_buffer</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="n">uint</span> <span class="n">vattr</span><span class="p">);</span>
</code></pre></div>


<p>Unbind the buffer</p>
<h4>Function unbind_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">unbind_vertex_buffer</span><span class="p">(</span><span class="n">uint</span> <span class="n">vattr</span><span class="p">);</span>
</code></pre></div>


<p>Unbind the buffer</p>
<h4>Function get_vertex_buffer_id()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">uint</span> <span class="nf">get_vertex_buffer_id</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<p>Get id</p>
<h4>Function is_vertex_buffer_valid()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_vertex_buffer_valid</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<p>Check if defined</p>
<h4>Function clear_vertex_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">clear_vertex_buffer</span><span class="p">(</span><span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<p>Destroys the buffer</p>
<h4>Struct gl_element_buffer</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_element_buffer</span> <span class="p">{</span>
</code></pre></div>


<p>OpenGL vertex/element buffer</p>
<h4>Function make_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_element_buffer</span> <span class="nf">make_element_buffer</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Creates a buffer.</p>
<h4>Function make_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_element_buffer</span> <span class="nf">make_element_buffer</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Creates a buffer.</p>
<h4>Function make_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_element_buffer</span> <span class="nf">make_element_buffer</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Creates a buffer.</p>
<h4>Function make_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_element_buffer</span> <span class="nf">make_element_buffer</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Creates a buffer.</p>
<h4>Function make_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">gl_element_buffer</span> <span class="nf">make_element_buffer</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dynamic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Creates a buffer.</p>
<h4>Function update_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_element_buffer</span><span class="p">(</span>
    <span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer with new data.</p>
<h4>Function update_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_element_buffer</span><span class="p">(</span>
    <span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer bid with new data.</p>
<h4>Function update_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_element_buffer</span><span class="p">(</span>
    <span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec2i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer bid with new data.</p>
<h4>Function update_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_element_buffer</span><span class="p">(</span>
    <span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec3i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer bid with new data.</p>
<h4>Function update_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_element_buffer</span><span class="p">(</span>
    <span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4i</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div>


<p>Updates the buffer bid with new data.</p>
<h4>Function draw_elems()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_elems</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<p>Draws elements.</p>
<h4>Function get_element_buffer_id()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="n">uint</span> <span class="nf">get_element_buffer_id</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<p>Get id</p>
<h4>Function is_element_buffer_valid()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_element_buffer_valid</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<p>Check if defined</p>
<h4>Function clear_element_buffer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">clear_element_buffer</span><span class="p">(</span><span class="n">gl_element_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<p>Destroys the buffer</p>
<h4>Struct gl_program</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_program</span> <span class="p">{</span>
</code></pre></div>


<p>OpenGL program</p>
<h4>Function make_program()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">gl_program</span> <span class="nf">make_program</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">vertex</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">fragment</span><span class="p">);</span>
</code></pre></div>


<p>Creates and OpenGL program from vertex and fragment code. Returns the
program id. Optionally return vertex and fragment shader ids. A VAO is
created.</p>
<h4>Function clear_program()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">clear_program</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Destroys the program pid and optionally the sahders vid and fid.</p>
<h4>Function get_program_uniform_location()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">get_program_uniform_location</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>
</code></pre></div>


<p>Get uniform location (simple GL wrapper that avoids GL includes)</p>
<h4>Function get_program_attrib_location()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">get_program_attrib_location</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>
</code></pre></div>


<p>Get uniform location (simple GL wrapper that avoids GL includes)</p>
<h4>Function get_program_uniforms_names()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">get_program_uniforms_names</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Get the names of all uniforms</p>
<h4>Function get_program_attributes_names()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">get_program_attributes_names</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Get the names of all attributes</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform integer values val for program pid and variable loc.
The values have nc number of components (1-4) and count elements
(for arrays).</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.
The values have nc number of components (1-4) and count elements
(for arrays).</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="kt">float</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3i</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4i</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">set_program_uniform</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform float values val for program pid and variable var.</p>
<h4>Function set_program_uniform_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">set_program_uniform_texture</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">tinfo</span><span class="p">,</span> <span class="n">uint</span> <span class="n">tunit</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform texture id tid and unit tunit for program pid and variable
var.</p>
<h4>Function set_program_uniform_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform_texture</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="kt">int</span> <span class="n">varon</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">tinfo</span><span class="p">,</span> <span class="n">uint</span> <span class="n">tunit</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform texture id tid and unit tunit for program pid and variable
var. Optionally sets the int variable varon to 0/1 whether the texture
is enable on not.</p>
<h4>Function set_program_uniform_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform_texture</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">var</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">tinfo</span><span class="p">,</span> <span class="n">uint</span> <span class="n">tunit</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform texture id tid and unit tunit for program pid and variable
var.</p>
<h4>Function set_program_uniform_texture()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_uniform_texture</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">var</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">varon</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">tinfo</span><span class="p">,</span> <span class="n">uint</span> <span class="n">tunit</span><span class="p">);</span>
</code></pre></div>


<p>Set uniform texture id tid and unit tunit for program pid and variable
var. Optionally sets the int variable varon to 0/1 whether the texture
is enable on not.</p>
<h4>Function set_program_vertattr()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">set_program_vertattr</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nc</span><span class="p">);</span>
</code></pre></div>


<p>Sets a constant value for a vertex attribute for program pid and
variable var. The attribute has nc components.</p>
<h4>Function set_program_vertattr()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">set_program_vertattr</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nc</span><span class="p">);</span>
</code></pre></div>


<p>Sets a constant value for a vertex attribute for program pid and
variable var. The attribute has nc components.</p>
<h4>Function set_program_vertattr()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">set_program_vertattr</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<p>Sets a vartex attribute for program pid and variable var to the buffer
bid. The attribute has nc components and per-vertex values values.</p>
<h4>Function set_program_vertattr()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">set_program_vertattr</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">def</span><span class="p">);</span>
</code></pre></div>


<p>Sets a vartex attribute for program pid and variable var. The attribute
has nc components and either buffer bid or a single value def
(if bid is zero). Convenience wrapper to above functions.</p>
<h4>Function set_program_vertattr()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_vertattr</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">def</span><span class="p">);</span>
</code></pre></div>


<p>Sets a vartex attribute for program pid and variable var. The attribute
is either a buffer bid or a single value def
(if bid is zero). Convenience wrapper to above functions.</p>
<h4>Function set_program_vertattr()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_vertattr</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">def</span><span class="p">);</span>
</code></pre></div>


<p>Sets a vartex attribute for program pid and variable var. The attribute
is either a buffer bid or a single value def
(if bid is zero). Convenience wrapper to above functions.</p>
<h4>Function set_program_vertattr()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_vertattr</span><span class="p">(</span>
    <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">def</span><span class="p">);</span>
</code></pre></div>


<p>Sets a vartex attribute for program pid and variable var. The attribute
is either a buffer bid or a single value def
(if bid is zero). Convenience wrapper to above functions.</p>
<h4>Function set_program_vertattr()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_vertattr</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">var</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">def</span><span class="p">);</span>
</code></pre></div>


<p>Sets a vartex attribute for program pid and variable var. The attribute
is either a buffer bid or a single value def
(if bid is zero). Convenience wrapper to above functions.</p>
<h4>Function set_program_vertattr()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_vertattr</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">var</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">def</span><span class="p">);</span>
</code></pre></div>


<p>Sets a vartex attribute for program pid and variable var. The attribute
is either a buffer bid or a single value def
(if bid is zero). Convenience wrapper to above functions.</p>
<h4>Function set_program_vertattr()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">set_program_vertattr</span><span class="p">(</span><span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">var</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">def</span><span class="p">);</span>
</code></pre></div>


<p>Sets a vartex attribute for program pid and variable var. The attribute
is either a buffer bid or a single value def
(if bid is zero). Convenience wrapper to above functions.</p>
<h4>Function is_program_valid()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_program_valid</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Check whether it is valid</p>
<h4>Function bind_program()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">bind_program</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Binds a program</p>
<h4>Function unbind_program()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">unbind_program</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Unbind a program</p>
<h4>Struct gl_stdimage_program</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_stdimage_program</span> <span class="p">{</span>
</code></pre></div>


<p>A shader for displaying images</p>
<h4>Function make_stdimage_program()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">gl_stdimage_program</span> <span class="nf">make_stdimage_program</span><span class="p">();</span>
</code></pre></div>


<p>Initialize the program. Call with true only after the GL is initialized.</p>
<h4>Function draw_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">draw_image</span><span class="p">(</span><span class="n">gl_stdimage_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">win_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">float</span> <span class="n">zoom</span><span class="p">,</span> <span class="kt">float</span> <span class="n">exposure</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">gamma</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">filmic</span><span class="p">);</span>
</code></pre></div>


<p>As above but includes an exposure/gamma correction.</p>
<h4>Function draw_image()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">draw_image</span><span class="p">(</span><span class="n">gl_stdimage_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_texture</span><span class="o">&amp;</span> <span class="n">txt</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">win_size</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">float</span> <span class="n">zoom</span><span class="p">);</span>
</code></pre></div>


<p>Draw an texture tid of size img_w, img_h on a window of size win_w,
win_h with top-left corner at ox, oy with a zoom zoom.</p>
<h4>Struct gl_stdsurface_program</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_stdsurface_program</span> <span class="p">{</span>
</code></pre></div>


<p>Shade with a physically-based standard shader based on Phong/GGX.
Filmic tone mapping from
https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/</p>
<h4>Function make_stdsurface_program()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">gl_stdsurface_program</span> <span class="nf">make_stdsurface_program</span><span class="p">();</span>
</code></pre></div>


<p>Initialize a standard shader. Call with true only after the gl has
been initialized</p>
<h4>Function is_program_valid()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_program_valid</span><span class="p">(</span><span class="k">const</span> <span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Check if the program is valid</p>
<h4>Function begin_stdsurface_frame()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">begin_stdsurface_frame</span><span class="p">(</span><span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">shade_eyelight</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tonemap_exposure</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tonemap_gamma</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">tonemap_filmic</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">camera_xform</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">camera_xform_inv</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">camera_proj</span><span class="p">);</span>
</code></pre></div>


<p>Starts a frame by setting exposure/gamma values, camera transforms and
projection. Sets also whether to use full shading or a quick eyelight
preview.</p>
<h4>Function end_stdsurface_frame()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">end_stdsurface_frame</span><span class="p">(</span><span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Ends a frame.</p>
<h4>Function set_stdsurface_lights()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_stdsurface_lights</span><span class="p">(</span><span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">amb</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">*</span> <span class="n">ke</span><span class="p">,</span> <span class="n">gl_ltype</span><span class="o">*</span> <span class="n">type</span><span class="p">);</span>
</code></pre></div>


<p>Set num lights with position pos, color ke, type ltype. Also set the
ambient illumination amb.</p>
<h4>Function begin_stdsurface_shape()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">begin_stdsurface_shape</span><span class="p">(</span>
    <span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">xform</span><span class="p">);</span>
</code></pre></div>


<p>Begins drawing a shape with transform xform.</p>
<h4>Function end_stdsurface_shape()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">end_stdsurface_shape</span><span class="p">(</span><span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>End shade drawing.</p>
<h4>Function set_stdsurface_highlight()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_stdsurface_highlight</span><span class="p">(</span>
    <span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">highlight</span><span class="p">);</span>
</code></pre></div>


<p>Set the object as highlighted.</p>
<h4>Function set_stdsurface_material()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_stdsurface_material</span><span class="p">(</span><span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span>
    <span class="n">material_type</span> <span class="n">mtype</span><span class="p">,</span> <span class="n">gl_etype</span> <span class="n">etype</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ke</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">kd</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">ks</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rs</span><span class="p">,</span> <span class="kt">float</span> <span class="n">op</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">ke_txt</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">kd_txt</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">ks_txt</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">rs_txt</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">norm_txt</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_texture_info</span><span class="o">&amp;</span> <span class="n">occ_txt</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">use_phong</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">double_sided</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">alpha_cutout</span><span class="p">);</span>
</code></pre></div>


<p>Set material values with emission ke, diffuse kd, specular ks and
specular roughness rs, opacity op. Indicates textures ids with the
correspoinding XXX_txt variables. Sets also normal and occlusion
maps. Works for points/lines/triangles (diffuse for points,
Kajiya-Kay for lines, GGX/Phong for triangles).
Material type matches the scene material type.</p>
<h4>Function set_stdsurface_vert()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_stdsurface_vert</span><span class="p">(</span><span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">norm</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">texcoord</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">color</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">tangsp</span><span class="p">);</span>
</code></pre></div>


<p>Set vertex data with buffers for position pos, normals norm, texture
coordinates texcoord, per-vertex color color and tangent space tangsp.</p>
<h4>Function set_stdsurface_vert_skinning()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_stdsurface_vert_skinning</span><span class="p">(</span><span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">weights</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">joints</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">nxforms</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">*</span> <span class="n">xforms</span><span class="p">);</span>
</code></pre></div>


<p>Set vertex data with buffers for skinning.</p>
<h4>Function set_stdsurface_vert_gltf_skinning()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_stdsurface_vert_gltf_skinning</span><span class="p">(</span><span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">weights</span><span class="p">,</span> <span class="k">const</span> <span class="n">gl_vertex_buffer</span><span class="o">&amp;</span> <span class="n">joints</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">nxforms</span><span class="p">,</span> <span class="k">const</span> <span class="n">mat4f</span><span class="o">*</span> <span class="n">xforms</span><span class="p">);</span>
</code></pre></div>


<p>Set vertex data with buffers for skinning.</p>
<h4>Function set_stdsurface_vert_skinning_off()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_stdsurface_vert_skinning_off</span><span class="p">(</span><span class="n">gl_stdsurface_program</span><span class="o">&amp;</span> <span class="n">prog</span><span class="p">);</span>
</code></pre></div>


<p>Disables vertex skinning.</p>
<h4>Struct gl_stdsurface_state</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_stdsurface_state</span> <span class="p">{</span>
</code></pre></div>


<p>State object for gl_stdsurface_program drawing. Members are not part of the
public API.</p>
<h4>Struct gl_stdsurface_params</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_stdsurface_params</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">camera_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">360</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">360</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">exposure</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">2.2f</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">filmic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">wireframe</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">edges</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">cutout</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">camera_lights</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">vec4f</span> <span class="n">background</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">vec3f</span> <span class="n">ambient</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">hilighted</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>Params for  gl_stdsurface_program drawing</p>
<ul>
<li>Members:<ul>
<li>camera_id:      camera id</li>
<li>width:      image width</li>
<li>height:      image height</li>
<li>exposure:      image exposure</li>
<li>gamma:      image gamma</li>
<li>filmic:      image filmic tonemapping</li>
<li>wireframe:      draw as wireframe</li>
<li>edges:      draw with overlaid edges</li>
<li>cutout:      draw with an alpha cutout for binary transparency</li>
<li>camera_lights:      camera light mode</li>
<li>background:      window background</li>
<li>ambient:      ambient illumination</li>
<li>hilighted:      highlighted object</li>
</ul>
</li>
</ul>
<h4>Function make_stdsurface_state()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">gl_stdsurface_state</span><span class="o">*</span> <span class="nf">make_stdsurface_state</span><span class="p">();</span>
</code></pre></div>


<p>Initialize gl_stdsurface_program draw state</p>
<h4>Function update_stdsurface_state()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">update_stdsurface_state</span><span class="p">(</span><span class="n">gl_stdsurface_state</span><span class="o">*</span> <span class="n">st</span><span class="p">,</span> <span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_stdsurface_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Update gl_stdsurface_program draw state. This updates stdsurface meshes
and textures on the GPU.</p>
<h4>Function clear_stdsurface_state()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">clear_stdsurface_state</span><span class="p">(</span><span class="n">gl_stdsurface_state</span><span class="o">*</span> <span class="n">st</span><span class="p">);</span>
</code></pre></div>


<p>Clear gl_stdsurface_program draw state</p>
<h4>Function draw_stdsurface_scene()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_stdsurface_scene</span><span class="p">(</span><span class="n">gl_stdsurface_state</span><span class="o">*</span> <span class="n">st</span><span class="p">,</span> <span class="k">const</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">gl_stdsurface_params</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">);</span>
</code></pre></div>


<p>Draw whole scene</p>
<h4>Function void()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">gl_text_callback</span><span class="p">)(</span><span class="n">gl_window</span><span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
</code></pre></div>


<p>Text callback</p>
<h4>Function void()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">gl_mouse_callback</span><span class="p">)(</span><span class="n">gl_window</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">button</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">press</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mods</span><span class="p">);</span>
</code></pre></div>


<p>Mouse callback</p>
<h4>Function void()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">gl_refresh_callback</span><span class="p">)(</span><span class="n">gl_window</span><span class="o">*</span><span class="p">);</span>
</code></pre></div>


<p>Window refresh callback</p>
<h4>Struct gl_window</h4>
<div class="codehilite"><pre><code><span></span><span class="k">struct</span> <span class="n">gl_window</span> <span class="p">{</span>
</code></pre></div>


<p>Window</p>
<h4>Function make_window()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">gl_window</span><span class="o">*</span> <span class="nf">make_window</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">title</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">user_pointer</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></div>


<p>Initialize gl_window</p>
<h4>Function set_window_callbacks()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_window_callbacks</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="n">gl_text_callback</span> <span class="n">text_cb</span><span class="p">,</span>
    <span class="n">gl_mouse_callback</span> <span class="n">mouse_cb</span><span class="p">,</span> <span class="n">gl_refresh_callback</span> <span class="n">refresh_cb</span><span class="p">);</span>
</code></pre></div>


<p>Set gl_window callbacks</p>
<h4>Function clear_window()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">clear_window</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Clear gl_window</p>
<h4>Function get_user_pointer()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">get_user_pointer</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Gets the user poiner</p>
<h4>Function set_window_title()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">set_window_title</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">title</span><span class="p">);</span>
</code></pre></div>


<p>Set gl_window title</p>
<h4>Function wait_events()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">wait_events</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Wait events</p>
<h4>Function poll_events()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">poll_events</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Poll events</p>
<h4>Function swap_buffers()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">swap_buffers</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Swap buffers</p>
<h4>Function should_close()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">should_close</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Should close</p>
<h4>Function get_mouse_button()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">int</span> <span class="nf">get_mouse_button</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Mouse button</p>
<h4>Function get_mouse_pos()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec2i</span> <span class="nf">get_mouse_pos</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Mouse position</p>
<h4>Function get_mouse_posf()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec2f</span> <span class="nf">get_mouse_posf</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Mouse position</p>
<h4>Function get_window_size()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec2i</span> <span class="nf">get_window_size</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Window size</p>
<h4>Function get_key()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">get_key</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">);</span>
</code></pre></div>


<p>Check if a key is pressed (not all keys are supported)</p>
<h4>Function get_framebuffer_size()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vec2i</span> <span class="nf">get_framebuffer_size</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Framebuffer size</p>
<h4>Function get_widget_size()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_widget_size</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Widgets</p>
<h4>Function get_screenshot()</h4>
<div class="codehilite"><pre><code><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vec4b</span><span class="o">&gt;</span> <span class="n">get_screenshot</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">wh</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flipy</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">back</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>


<p>Read pixels</p>
<h4>Function save_screenshot()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">save_screenshot</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">imfilename</span><span class="p">);</span>
</code></pre></div>


<p>Save a screenshot to disk</p>
<h4>Function handle_camera_navigation()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">handle_camera_navigation</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="n">camera</span><span class="o">*</span> <span class="n">cam</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">navigation_fps</span><span class="p">);</span>
</code></pre></div>


<p>Handle camera navigation.</p>
<h4>Function init_widgets()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">init_widgets</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Initialize widgets</p>
<h4>Function begin_widgets()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">begin_widgets</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">title</span><span class="p">);</span>
</code></pre></div>


<p>Begin draw widget</p>
<h4>Function end_widgets()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">end_widgets</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>End draw widget</p>
<h4>Function get_widget_active()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">get_widget_active</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Whether widget are active</p>
<h4>Function draw_separator_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_separator_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Horizontal separator</p>
<h4>Function draw_indent_widget_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_indent_widget_begin</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Indent widget</p>
<h4>Function draw_indent_widget_end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_indent_widget_end</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Indent widget</p>
<h4>Function draw_continue_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_continue_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Continue line with next widget</p>
<h4>Function draw_label_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_label_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">);</span>
</code></pre></div>


<p>Label widget</p>
<h4>Function draw_label_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">draw_label_widget</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">fmt</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>


<p>Label widget</p>
<h4>Function draw_label_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">draw_label_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Label widget</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</code></pre></div>


<p>Value widget</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Value widget</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncomp</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Value widget</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Value widget</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Value widget</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec3i</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Value widget</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec4i</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Value widget</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Value widget</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec2f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Value widget</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Value widget</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Value widget</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">mat4f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Slider widget</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">frame3f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Slider widget</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">quat4f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="kt">float</span> <span class="n">incr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>


<p>Slider widget</p>
<h4>Function draw_color_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_color_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Color widget</p>
<h4>Function draw_color_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_color_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec4b</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Color widget</p>
<h4>Function draw_color_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_color_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">vec3f</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Color widget</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">labels</span><span class="p">);</span>
</code></pre></div>


<p>Enum widget</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;&amp;</span> <span class="n">labels</span><span class="p">);</span>
</code></pre></div>


<p>Enum widget</p>
<h4>Function draw_value_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_value_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div>


<p>Bool widget</p>
<h4>Function draw_button_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_button_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">);</span>
</code></pre></div>


<p>Button widget</p>
<h4>Function draw_header_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_header_widget</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">);</span>
</code></pre></div>


<p>Collapsible header</p>
<h4>Function draw_tree_widget_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_tree_widget_begin</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">);</span>
</code></pre></div>


<p>Start tree node</p>
<h4>Function draw_tree_widget_end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_tree_widget_end</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Collapsible header</p>
<h4>Function draw_tree_widget_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_tree_widget_begin</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">void</span><span class="o">*&amp;</span> <span class="n">selection</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">content</span><span class="p">);</span>
</code></pre></div>


<p>Start selectable tree node</p>
<h4>Function draw_tree_widget_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_tree_widget_begin</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">void</span><span class="o">*&amp;</span> <span class="n">selection</span><span class="p">,</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">content</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">col</span><span class="p">);</span>
</code></pre></div>


<p>Start selectable tree node</p>
<h4>Function draw_tree_widget_end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_tree_widget_end</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">content</span><span class="p">);</span>
</code></pre></div>


<p>End selectable tree node</p>
<h4>Function draw_tree_widget_leaf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_tree_widget_leaf</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">void</span><span class="o">*&amp;</span> <span class="n">selection</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">content</span><span class="p">);</span>
</code></pre></div>


<p>Selectable tree leaf node</p>
<h4>Function draw_tree_widget_leaf()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_tree_widget_leaf</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">void</span><span class="o">*&amp;</span> <span class="n">selection</span><span class="p">,</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">content</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">col</span><span class="p">);</span>
</code></pre></div>


<p>Selectable tree leaf node</p>
<h4>Function draw_image_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_image_widget</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tid</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec2i</span><span class="o">&amp;</span> <span class="n">imsize</span><span class="p">);</span>
</code></pre></div>


<p>Image widget</p>
<h4>Function draw_scroll_widget_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_scroll_widget_begin</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">border</span><span class="p">);</span>
</code></pre></div>


<p>Scroll region</p>
<h4>Function draw_scroll_widget_end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_scroll_widget_end</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Scroll region</p>
<h4>Function draw_scroll_widget_here()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_scroll_widget_here</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Scroll region</p>
<h4>Function draw_groupid_widget_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_groupid_widget_begin</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gid</span><span class="p">);</span>
</code></pre></div>


<p>Group ids</p>
<h4>Function draw_groupid_widget_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_groupid_widget_begin</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">gid</span><span class="p">);</span>
</code></pre></div>


<p>Group ids</p>
<h4>Function draw_groupid_widget_end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_groupid_widget_end</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Group ids</p>
<h4>Function draw_tree_widget_color_begin()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_tree_widget_color_begin</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec4f</span><span class="o">&amp;</span> <span class="n">color</span><span class="p">);</span>
</code></pre></div>


<p>Text color</p>
<h4>Function draw_tree_widget_color_end()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">void</span> <span class="nf">draw_tree_widget_color_end</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">);</span>
</code></pre></div>


<p>Text color</p>
<h4>Function draw_tonemap_widgets()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">draw_tonemap_widgets</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span>
    <span class="kt">float</span><span class="o">&amp;</span> <span class="n">exposure</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">gamma</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&amp;</span> <span class="n">filmic</span><span class="p">);</span>
</code></pre></div>


<p>Tonemapping widgets</p>
<h4>Function draw_camera_widget()</h4>
<div class="codehilite"><pre><code><span></span><span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">draw_camera_widget</span><span class="p">(</span>
    <span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">cam_idx</span><span class="p">);</span>
</code></pre></div>


<p>Draws a widget that can selected the camera</p>
<h4>Function draw_scene_widgets()</h4>
<div class="codehilite"><pre><code><span></span><span class="kt">bool</span> <span class="nf">draw_scene_widgets</span><span class="p">(</span><span class="n">gl_window</span><span class="o">*</span> <span class="n">win</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">scene</span><span class="o">*</span> <span class="n">scn</span><span class="p">,</span>
    <span class="kt">void</span><span class="o">*&amp;</span> <span class="n">selection</span><span class="p">,</span> <span class="k">const</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">texture</span><span class="o">*</span><span class="p">,</span> <span class="n">gl_texture</span><span class="o">&gt;&amp;</span> <span class="n">gl_txt</span><span class="p">);</span>
</code></pre></div>


<p>Draws widgets for a whole scene. Used for quickly making demos.</p>
    <article>
    <footer></footer>
    </body>
    </html>
